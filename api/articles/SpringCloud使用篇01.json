<<<<<<< HEAD
{"title":"SpringCloud 实用篇 01","uid":"eaa06ed45453f389a4efa6b3c6981c30","slug":"SpringCloud使用篇01","date":"2023-08-15T10:49:36.000Z","updated":"2023-12-28T07:02:41.554Z","comments":true,"path":"api/articles/SpringCloud使用篇01.json","keywords":null,"cover":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","content":"<h1 id=\"SpringCloud01\"><a href=\"#SpringCloud01\" class=\"headerlink\" title=\"SpringCloud01\"></a>SpringCloud01</h1><h1 id=\"1-认识微服务\"><a href=\"#1-认识微服务\" class=\"headerlink\" title=\"1.认识微服务\"></a>1.认识微服务</h1><p><strong>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</strong></p>\n<h2 id=\"1-0-学习目标\"><a href=\"#1-0-学习目标\" class=\"headerlink\" title=\"1.0.学习目标\"></a>1.0.学习目标</h2><p><strong>了解微服务架构的优缺点</strong></p>\n<h2 id=\"1-1-单体架构\"><a href=\"#1-1-单体架构\" class=\"headerlink\" title=\"1.1.单体架构\"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1930435349.png\" alt=\"请输入图片描述\"></p>\n<p><strong>单体架构的优缺点如下：</strong></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>架构简单</strong></li>\n<li><strong>部署成本低</strong></li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>耦合度高（维护困难、升级困难）</strong></li>\n</ul>\n<h2 id=\"1-2-分布式架构\"><a href=\"#1-2-分布式架构\" class=\"headerlink\" title=\"1.2.分布式架构\"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1589518135.png\" alt=\"请输入图片描述\"></p>\n<p><strong>分布式架构的优缺点：</strong></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>降低服务耦合</strong></li>\n<li><strong>有利于服务升级和拓展</strong></li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>服务调用关系错综复杂</strong></li>\n</ul>\n<p><strong>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</strong></p>\n<ul>\n<li><strong>服务拆分的粒度如何界定？</strong></li>\n<li><strong>服务之间如何调用？</strong></li>\n<li><strong>服务的调用关系如何管理？</strong></li>\n</ul>\n<p><strong>人们需要制定一套行之有效的标准来约束分布式架构。</strong></p>\n<h2 id=\"1-3-微服务\"><a href=\"#1-3-微服务\" class=\"headerlink\" title=\"1.3.微服务\"></a>1.3.微服务</h2><p><strong>微服务的架构特征：</strong></p>\n<ul>\n<li><strong>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</strong></li>\n<li><strong>自治：团队独立、技术独立、数据独立，独立部署和交付</strong></li>\n<li><strong>面向服务：服务提供统一标准的接口，与语言和技术无关</strong></li>\n<li><strong>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</strong></li>\n</ul>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3312298924.png\" alt=\"请输入图片描述\"></p>\n<p><strong>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</strong></p>\n<p><strong>因此，可以认为****微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p>\n<p><strong>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</strong></p>\n<p><strong>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</strong></p>\n<h2 id=\"1-4-SpringCloud\"><a href=\"#1-4-SpringCloud\" class=\"headerlink\" title=\"1.4.SpringCloud\"></a>1.4.SpringCloud</h2><p><strong>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：</strong><a href=\"https://spring.io/projects/spring-cloud\">https://spring.io/projects/spring-cloud</a>。</p>\n<p><strong>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</strong></p>\n<p><strong>其中常见的组件包括：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2124846292.png\" alt=\"请输入图片描述\"></p>\n<p><strong>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1116769699.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</strong></p>\n<h2 id=\"1-5-总结\"><a href=\"#1-5-总结\" class=\"headerlink\" title=\"1.5.总结\"></a>1.5.总结</h2><ul>\n<li><strong>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</strong></li>\n<li><strong>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</strong></li>\n<li><strong>微服务：一种良好的分布式架构方案</strong><br><strong>①优点：拆分粒度更小、服务更独立、耦合度更低</strong><br><strong>②缺点：架构非常复杂，运维、监控、部署难度提高</strong></li>\n<li><strong>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</strong></li>\n</ul>\n<h1 id=\"2-服务拆分和远程调用\"><a href=\"#2-服务拆分和远程调用\" class=\"headerlink\" title=\"2.服务拆分和远程调用\"></a>2.服务拆分和远程调用</h1><p><strong>任何分布式架构都离不开服务的拆分，微服务也是一样。</strong></p>\n<h2 id=\"2-1-服务拆分原则\"><a href=\"#2-1-服务拆分原则\" class=\"headerlink\" title=\"2.1.服务拆分原则\"></a>2.1.服务拆分原则</h2><p><strong>这里我总结了微服务拆分时的几个原则：</strong></p>\n<ul>\n<li><strong>不同微服务，不要重复开发相同业务</strong></li>\n<li><strong>微服务数据独立，不要访问其它微服务的数据库</strong></li>\n<li><strong>微服务可以将自己的业务暴露为接口，供其它微服务调用</strong></li>\n</ul>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/743242425.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-2-服务拆分示例\"><a href=\"#2-2-服务拆分示例\" class=\"headerlink\" title=\"2.2.服务拆分示例\"></a>2.2.服务拆分示例</h2><p><strong>以课前资料中的微服务cloud-demo为例，其结构如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2958180924.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-demo：父工程，管理依赖</strong></p>\n<ul>\n<li><strong>order-service：订单微服务，负责订单相关业务</strong></li>\n<li><strong>user-service：用户微服务，负责用户相关业务</strong></li>\n</ul>\n<p><strong>要求：</strong></p>\n<ul>\n<li><strong>订单微服务和用户微服务都必须有各自的数据库，相互独立</strong></li>\n<li><strong>订单服务和用户服务都对外暴露Restful的接口</strong></li>\n<li><strong>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</strong></li>\n</ul>\n<h3 id=\"2-2-1-导入Sql语句\"><a href=\"#2-2-1-导入Sql语句\" class=\"headerlink\" title=\"2.2.1.导入Sql语句\"></a>2.2.1.导入Sql语句</h3><p><strong>首先，将课前资料提供的</strong><code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/276624830.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-user表中初始数据如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/646977056.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-order表中初始数据如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/230156166.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-order表中持有cloud-user表中的id字段。</strong></p>\n<h3 id=\"2-2-2-导入demo工程\"><a href=\"#2-2-2-导入demo工程\" class=\"headerlink\" title=\"2.2.2.导入demo工程\"></a>2.2.2.导入demo工程</h3><p><strong>用IDEA导入课前资料提供的Demo：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/259698597.png\" alt=\"请输入图片描述\"></p>\n<p><strong>项目结构如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2087602036.png\" alt=\"请输入图片描述\"></p>\n<p><strong>导入后，会在IDEA右下角出现弹窗：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4014462343.png\" alt=\"请输入图片描述\"></p>\n<p><strong>点击弹窗，然后按下图选择：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2758611873.png\" alt=\"请输入图片描述\"></p>\n<p><strong>会出现这样的菜单：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2878946380.png\" alt=\"请输入图片描述\"></p>\n<p><strong>配置下项目使用的JDK：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1704992619.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-3-实现远程调用案例\"><a href=\"#2-3-实现远程调用案例\" class=\"headerlink\" title=\"2.3.实现远程调用案例\"></a>2.3.实现远程调用案例</h2><p><strong>在order-service服务中，有一个根据id查询订单的接口：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/997322769.png\" alt=\"请输入图片描述\"></p>\n<p><strong>根据id查询订单，返回值是Order对象，如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3761978351.png\" alt=\"请输入图片描述\"></p>\n<p><strong>其中的user为null</strong></p>\n<p><strong>在user-service中有一个根据id查询用户的接口：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3496087221.png\" alt=\"请输入图片描述\"></p>\n<p><strong>查询的结果如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1480743671.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"2-3-1-案例需求：\"><a href=\"#2-3-1-案例需求：\" class=\"headerlink\" title=\"2.3.1.案例需求：\"></a>2.3.1.案例需求：</h3><p><strong>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</strong></p>\n<p><strong>因此，我们需要在order-service中 向user-service发起一个http的请求，调用</strong><a href=\"http://localhost:8081/user/\">http://localhost:8081/user/</a>{userId}这个接口。</p>\n<p><strong>大概的步骤是这样的：</strong></p>\n<ul>\n<li><strong>注册一个RestTemplate的实例到Spring容器</strong></li>\n<li><strong>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</strong></li>\n<li><strong>将查询的User填充到Order对象，一起返回</strong></li>\n</ul>\n<h3 id=\"2-3-2-注册RestTemplate\"><a href=\"#2-3-2-注册RestTemplate\" class=\"headerlink\" title=\"2.3.2.注册RestTemplate\"></a>2.3.2.注册RestTemplate</h3><p><strong>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.order;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.mybatis.spring.annotation.MapperScan;</span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\">import org.springframework.context.annotation.Bean;</span><br><span class=\"line\">import org.springframework.web.client.RestTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class OrderApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(OrderApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public RestTemplate restTemplate() &#123;</span><br><span class=\"line\">        return new RestTemplate();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3-实现远程调用\"><a href=\"#2-3-3-实现远程调用\" class=\"headerlink\" title=\"2.3.3.实现远程调用\"></a>2.3.3.实现远程调用</h3><p><strong>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3877304843.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-4-提供者与消费者\"><a href=\"#2-4-提供者与消费者\" class=\"headerlink\" title=\"2.4.提供者与消费者\"></a>2.4.提供者与消费者</h2><p><strong>在服务调用关系中，会有两个不同的角色：</strong></p>\n<p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p>\n<p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4014088050.png\" alt=\"请输入图片描述\"></p>\n<p><strong>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</strong></p>\n<p><strong>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</strong></p>\n<ul>\n<li><strong>对于A调用B的业务而言：A是服务消费者，B是服务提供者</strong></li>\n<li><strong>对于B调用C的业务而言：B是服务消费者，C是服务提供者</strong></li>\n</ul>\n<p><strong>因此，服务B既可以是服务提供者，也可以是服务消费者。</strong></p>\n<h1 id=\"3-Eureka注册中心\"><a href=\"#3-Eureka注册中心\" class=\"headerlink\" title=\"3.Eureka注册中心\"></a>3.Eureka注册中心</h1><p><strong>假如我们的服务提供者user-service部署了多个实例，如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4224733546.png\" alt=\"请输入图片描述\"></p>\n<p><strong>大家思考几个问题：</strong></p>\n<ul>\n<li><strong>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</strong></li>\n<li><strong>有多个user-service实例地址，order-service调用时该如何选择？</strong></li>\n<li><strong>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></li>\n</ul>\n<h2 id=\"3-1-Eureka的结构和作用\"><a href=\"#3-1-Eureka的结构和作用\" class=\"headerlink\" title=\"3.1.Eureka的结构和作用\"></a>3.1.Eureka的结构和作用</h2><p><strong>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2752427792.png\" alt=\"请输入图片描述\"></p>\n<p><strong>回答之前的各个问题。</strong></p>\n<p><strong>问题1：order-service如何得知user-service实例地址？</strong></p>\n<p><strong>获取地址信息的流程如下：</strong></p>\n<ul>\n<li><strong>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</strong></li>\n<li><strong>eureka-server保存服务名称到服务实例地址列表的映射关系</strong></li>\n<li><strong>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</strong></li>\n</ul>\n<p><strong>问题2：order-service如何从多个user-service实例中选择具体的实例？</strong></p>\n<ul>\n<li><strong>order-service从实例列表中利用负载均衡算法选中一个实例地址</strong></li>\n<li><strong>向该实例地址发起远程调用</strong></li>\n</ul>\n<p><strong>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p>\n<ul>\n<li><strong>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</strong></li>\n<li><strong>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</strong></li>\n<li><strong>order-service拉取服务时，就能将故障实例排除了</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</strong></p></blockquote>\n<p><strong>因此，接下来我们动手实践的步骤包括：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1313548687.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"3-2-搭建eureka-server\"><a href=\"#3-2-搭建eureka-server\" class=\"headerlink\" title=\"3.2.搭建eureka-server\"></a>3.2.搭建eureka-server</h2><p><strong>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</strong></p>\n<h3 id=\"3-2-1-创建eureka-server服务\"><a href=\"#3-2-1-创建eureka-server服务\" class=\"headerlink\" title=\"3.2.1.创建eureka-server服务\"></a>3.2.1.创建eureka-server服务</h3><p><strong>在cloud-demo父工程下，创建一个子模块：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3841721388.png\" alt=\"请输入图片描述\"></p>\n<p><strong>填写模块信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1592319894.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后填写服务信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/778676265.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3-2-2-引入eureka依赖\"><a href=\"#3-2-2-引入eureka依赖\" class=\"headerlink\" title=\"3.2.2.引入eureka依赖\"></a>3.2.2.引入eureka依赖</h3><p><strong>引入SpringCloud为eureka提供的starter依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-3-编写启动类\"><a href=\"#3-2-3-编写启动类\" class=\"headerlink\" title=\"3.2.3.编写启动类\"></a>3.2.3.编写启动类</h3><p><strong>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.eureka;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class=\"line\"></span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">@EnableEurekaServer</span><br><span class=\"line\">public class EurekaApplication &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-4-编写配置文件\"><a href=\"#3-2-4-编写配置文件\" class=\"headerlink\" title=\"3.2.4.编写配置文件\"></a>3.2.4.编写配置文件</h3><p><strong>编写一个application.yml文件，内容如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 10086</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: eureka-server</span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    service-url: </span><br><span class=\"line\">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-5-启动服务\"><a href=\"#3-2-5-启动服务\" class=\"headerlink\" title=\"3.2.5.启动服务\"></a>3.2.5.启动服务</h3><p><strong>启动微服务，然后在浏览器访问：</strong><a href=\"http://127.0.0.1:10086/\">http://127.0.0.1:10086</a></p>\n<p><strong>看到下面结果应该是成功了：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/561278136.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"3-3-服务注册\"><a href=\"#3-3-服务注册\" class=\"headerlink\" title=\"3.3.服务注册\"></a>3.3.服务注册</h2><p><strong>下面，我们将user-service注册到eureka-server中去。</strong></p>\n<h3 id=\"1）引入依赖\"><a href=\"#1）引入依赖\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>在user-service的pom文件中，引入下面的eureka-client依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）配置文件\"><a href=\"#2）配置文件\" class=\"headerlink\" title=\"2）配置文件\"></a>2）配置文件</h3><p><strong>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: userservice</span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    service-url:</span><br><span class=\"line\">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3）启动多个user-service实例\"><a href=\"#3）启动多个user-service实例\" class=\"headerlink\" title=\"3）启动多个user-service实例\"></a>3）启动多个user-service实例</h3><p><strong>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</strong></p>\n<p><strong>首先，复制原来的user-service启动配置：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1492811656.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后，在弹出的窗口中，填写信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1195114028.png\" alt=\"请输入图片描述\"></p>\n<p><strong>现在，SpringBoot窗口会出现两个user-service启动配置：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3079890542.png\" alt=\"请输入图片描述\"></p>\n<p><strong>不过，第一个是8081端口，第二个是8082端口。</strong></p>\n<p><strong>启动两个user-service实例：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/219406862.png\" alt=\"请输入图片描述\"></p>\n<p><strong>查看eureka-server管理页面：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2688307359.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"3-4-服务发现\"><a href=\"#3-4-服务发现\" class=\"headerlink\" title=\"3.4.服务发现\"></a>3.4.服务发现</h2><p><strong>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</strong></p>\n<h3 id=\"1）引入依赖-1\"><a href=\"#1）引入依赖-1\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</strong></p>\n<p><strong>在order-service的pom文件中，引入下面的eureka-client依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）配置文件-1\"><a href=\"#2）配置文件-1\" class=\"headerlink\" title=\"2）配置文件\"></a>2）配置文件</h3><p><strong>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</strong></p>\n<p><strong>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: orderservice</span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    service-url:</span><br><span class=\"line\">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3）服务拉取和负载均衡\"><a href=\"#3）服务拉取和负载均衡\" class=\"headerlink\" title=\"3）服务拉取和负载均衡\"></a>3）服务拉取和负载均衡</h3><p><strong>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</strong></p>\n<p><strong>不过这些动作不用我们去做，只需要添加一些注解即可。</strong></p>\n<p><strong>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1650867891.png\" alt=\"请输入图片描述\"></p>\n<p><strong>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1949514255.png\" alt=\"请输入图片描述\"></p>\n<p><strong>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</strong></p>\n<h1 id=\"4-Ribbon负载均衡\"><a href=\"#4-Ribbon负载均衡\" class=\"headerlink\" title=\"4.Ribbon负载均衡\"></a>4.Ribbon负载均衡</h1><p><strong>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</strong></p>\n<h2 id=\"4-1-负载均衡原理\"><a href=\"#4-1-负载均衡原理\" class=\"headerlink\" title=\"4.1.负载均衡原理\"></a>4.1.负载均衡原理</h2><p><strong>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1655186028.png\" alt=\"请输入图片描述\"></p>\n<p><strong>那么我们发出的请求明明是</strong><a href=\"http://userservice/user/1\">http://userservice/user/1</a>，怎么变成了<a href=\"http://localhost:8081/\">http://localhost:8081</a>的呢？</p>\n<h2 id=\"4-2-源码跟踪\"><a href=\"#4-2-源码跟踪\" class=\"headerlink\" title=\"4.2.源码跟踪\"></a>4.2.源码跟踪</h2><p><strong>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</strong></p>\n<p><strong>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是</strong><code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p>\n<p><strong>我们进行源码跟踪：</strong></p>\n<h3 id=\"1）LoadBalancerIntercepor\"><a href=\"#1）LoadBalancerIntercepor\" class=\"headerlink\" title=\"1）LoadBalancerIntercepor\"></a>1）LoadBalancerIntercepor</h3><p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3965529458.png\" alt=\"请输入图片描述\"></p>\n<p><strong>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</strong></p>\n<ul>\n<li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href=\"http://user-service/user/8\">http://user-service/user/8</a></li>\n<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li>\n<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li>\n</ul>\n<p><strong>这里的</strong><code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p>\n<h3 id=\"2）LoadBalancerClient\"><a href=\"#2）LoadBalancerClient\" class=\"headerlink\" title=\"2）LoadBalancerClient\"></a>2）LoadBalancerClient</h3><p><strong>继续跟入execute方法：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2194489919.png\" alt=\"请输入图片描述\"></p>\n<p><strong>代码是这样的：</strong></p>\n<ul>\n<li><strong>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</strong></li>\n<li><strong>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</strong></li>\n</ul>\n<p><strong>放行后，再次访问并跟踪，发现获取的是8081：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2180952791.png\" alt=\"请输入图片描述\"></p>\n<p><strong>果然实现了负载均衡。</strong></p>\n<h3 id=\"3）负载均衡策略IRule\"><a href=\"#3）负载均衡策略IRule\" class=\"headerlink\" title=\"3）负载均衡策略IRule\"></a>3）负载均衡策略IRule</h3><p><strong>在刚才的代码中，可以看到获取服务使通过一个</strong><code>getServer</code>方法来做负载均衡:</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2180952791.png\" alt=\"请输入图片描述\">!</p>\n<p><strong>我们继续跟入：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3554728783.png\" alt=\"请输入图片描述\"></p>\n<p><strong>继续跟踪源码chooseServer方法，发现这么一段代码：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/715945055.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们看看这个rule是谁：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1144925770.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这里的rule默认值是一个</strong><code>RoundRobinRule</code>，看类的介绍：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2415655125.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这不就是轮询的意思嘛。</strong></p>\n<p><strong>到这里，整个负载均衡的流程我们就清楚了。</strong></p>\n<h3 id=\"4）总结\"><a href=\"#4）总结\" class=\"headerlink\" title=\"4）总结\"></a>4）总结</h3><p><strong>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2692996040.png\" alt=\"请输入图片描述\"></p>\n<p><strong>基本流程如下：</strong></p>\n<ul>\n<li><strong>拦截我们的RestTemplate请求</strong><a href=\"http://userservice/user/1\">http://userservice/user/1</a></li>\n<li><strong>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</strong></li>\n<li><strong>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</strong></li>\n<li><strong>eureka返回列表，localhost:8081、localhost:8082</strong></li>\n<li><strong>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</strong></li>\n<li><strong>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到</strong><a href=\"http://localhost:8081/user/1\">http://localhost:8081/user/1</a>，发起真实请求</li>\n</ul>\n<h2 id=\"4-3-负载均衡策略\"><a href=\"#4-3-负载均衡策略\" class=\"headerlink\" title=\"4.3.负载均衡策略\"></a>4.3.负载均衡策略</h2><h3 id=\"4-3-1-负载均衡策略\"><a href=\"#4-3-1-负载均衡策略\" class=\"headerlink\" title=\"4.3.1.负载均衡策略\"></a>4.3.1.负载均衡策略</h3><p><strong>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2862678284.png\" alt=\"请输入图片描述\"></p>\n<p><strong>不同规则的含义如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>内置负载均衡规则类</strong></th>\n<th><strong>规则描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>RoundRobinRule</strong></td>\n<td><strong>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</strong></td>\n</tr>\n<tr>\n<td><strong>AvailabilityFilteringRule</strong></td>\n<td><strong>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的</strong><clientName><strong>.</strong><clientConfigNameSpace><strong>.ActiveConnectionsLimit属性进行配置。</strong></td>\n</tr>\n<tr>\n<td><strong>WeightedResponseTimeRule</strong></td>\n<td><strong>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</strong></td>\n</tr>\n<tr>\n<td><strong>ZoneAvoidanceRule</strong></td>\n<td><strong>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</strong></td>\n</tr>\n<tr>\n<td><strong>BestAvailableRule</strong></td>\n<td><strong>忽略那些短路的服务器，并选择并发数较低的服务器。</strong></td>\n</tr>\n<tr>\n<td><strong>RandomRule</strong></td>\n<td><strong>随机选择一个可用的服务器。</strong></td>\n</tr>\n<tr>\n<td><strong>RetryRule</strong></td>\n<td><strong>重试机制的选择逻辑</strong></td>\n</tr>\n</tbody></table>\n<p><strong>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</strong></p>\n<h3 id=\"4-3-2-自定义负载均衡策略\"><a href=\"#4-3-2-自定义负载均衡策略\" class=\"headerlink\" title=\"4.3.2.自定义负载均衡策略\"></a>4.3.2.自定义负载均衡策略</h3><p><strong>通过定义IRule实现可以修改负载均衡规则，有两种方式：</strong></p>\n<ol>\n<li><strong>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public IRule randomRule()&#123;</span><br><span class=\"line\">    return new RandomRule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote>\n<h2 id=\"4-4-饥饿加载\"><a href=\"#4-4-饥饿加载\" class=\"headerlink\" title=\"4.4.饥饿加载\"></a>4.4.饥饿加载</h2><p><strong>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</strong></p>\n<p><strong>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ribbon:</span><br><span class=\"line\">  eager-load:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    clients: userservice</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-Nacos注册中心\"><a href=\"#5-Nacos注册中心\" class=\"headerlink\" title=\"5.Nacos注册中心\"></a>5.Nacos注册中心</h1><p><strong>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</strong></p>\n<h2 id=\"5-1-认识和安装Nacos\"><a href=\"#5-1-认识和安装Nacos\" class=\"headerlink\" title=\"5.1.认识和安装Nacos\"></a>5.1.认识和安装Nacos</h2><p><a href=\"https://nacos.io/\">Nacos</a>是阿里巴巴的产品，现在是<a href=\"https://spring.io/projects/spring-cloud\">SpringCloud</a>中的一个组件。相比<a href=\"https://github.com/Netflix/eureka\">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1962161475.png\" alt=\"请输入图片描述\"></p>\n<p><strong>安装方式可以参考课前资料《Nacos安装指南.md》</strong></p>\n<h2 id=\"5-2-服务注册到nacos\"><a href=\"#5-2-服务注册到nacos\" class=\"headerlink\" title=\"5.2.服务注册到nacos\"></a>5.2.服务注册到nacos</h2><p><strong>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</strong></p>\n<p><strong>主要差异在于：</strong></p>\n<ul>\n<li><strong>依赖不同</strong></li>\n<li><strong>服务地址不同</strong></li>\n</ul>\n<h3 id=\"1）引入依赖-2\"><a href=\"#1）引入依赖-2\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>在cloud-demo父工程的pom文件中的</strong><code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote>\n<h3 id=\"2）配置nacos地址\"><a href=\"#2）配置nacos地址\" class=\"headerlink\" title=\"2）配置nacos地址\"></a>2）配置nacos地址</h3><p><strong>在user-service和order-service的application.yml中添加nacos地址：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote>\n<h3 id=\"3）重启\"><a href=\"#3）重启\" class=\"headerlink\" title=\"3）重启\"></a>3）重启</h3><p><strong>重启微服务后，登录nacos管理页面，可以看到微服务信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2227711537.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"5-3-服务分级存储模型\"><a href=\"#5-3-服务分级存储模型\" class=\"headerlink\" title=\"5.3.服务分级存储模型\"></a>5.3.服务分级存储模型</h2><p><strong>一个****服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p>\n<ul>\n<li><strong>127.0.0.1:8081</strong></li>\n<li><strong>127.0.0.1:8082</strong></li>\n<li><strong>127.0.0.1:8083</strong></li>\n</ul>\n<p><strong>假如这些实例分布于全国各地的不同机房，例如：</strong></p>\n<ul>\n<li><strong>127.0.0.1:8081，在上海机房</strong></li>\n<li><strong>127.0.0.1:8082，在上海机房</strong></li>\n<li><strong>127.0.0.1:8083，在杭州机房</strong></li>\n</ul>\n<p><strong>Nacos就将同一机房内的实例 划分为一个****集群</strong>。</p>\n<p><strong>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1971170818.png\" alt=\"请输入图片描述\"></p>\n<p><strong>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1537336509.png\" alt=\"请输入图片描述\"></p>\n<p><strong>杭州机房内的order-service应该优先访问同机房的user-service。</strong></p>\n<h3 id=\"5-3-1-给user-service配置集群\"><a href=\"#5-3-1-给user-service配置集群\" class=\"headerlink\" title=\"5.3.1.给user-service配置集群\"></a>5.3.1.给user-service配置集群</h3><p><strong>修改user-service的application.yml文件，添加集群配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        cluster-name: HZ # 集群名称</span><br></pre></td></tr></table></figure>\n\n<p><strong>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2633449767.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们再次复制一个user-service启动配置，添加属性：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure>\n\n<p><strong>配置如图所示：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3724162407.png\" alt=\"请输入图片描述\"></p>\n<p><strong>启动UserApplication3后再次查看nacos控制台：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1733530142.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"5-3-2-同集群优先的负载均衡\"><a href=\"#5-3-2-同集群优先的负载均衡\" class=\"headerlink\" title=\"5.3.2.同集群优先的负载均衡\"></a>5.3.2.同集群优先的负载均衡</h3><p><strong>默认的</strong><code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p>\n<p><strong>因此Nacos中提供了一个</strong><code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p>\n<p><strong>1）给order-service配置集群信息</strong></p>\n<p><strong>修改order-service的application.yml文件，添加集群配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        cluster-name: HZ # 集群名称</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）修改负载均衡规则</strong></p>\n<p><strong>修改order-service的application.yml文件，修改负载均衡规则：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userservice:</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-权重配置\"><a href=\"#5-4-权重配置\" class=\"headerlink\" title=\"5.4.权重配置\"></a>5.4.权重配置</h2><p><strong>实际部署中会出现这样的场景：</strong></p>\n<p><strong>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</strong></p>\n<p><strong>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</strong></p>\n<p><strong>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</strong></p>\n<p><strong>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3136365653.png\" alt=\"请输入图片描述\"></p>\n<p><strong>在弹出的编辑窗口，修改权重：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2429177452.png\" alt=\"请输入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote>\n<h2 id=\"5-5-环境隔离\"><a href=\"#5-5-环境隔离\" class=\"headerlink\" title=\"5.5.环境隔离\"></a>5.5.环境隔离</h2><p><strong>Nacos提供了namespace来实现环境隔离功能。</strong></p>\n<ul>\n<li><strong>nacos中可以有多个namespace</strong></li>\n<li><strong>namespace下可以有group、service等</strong></li>\n<li><strong>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</strong></li>\n</ul>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3494748668.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"5-5-1-创建namespace\"><a href=\"#5-5-1-创建namespace\" class=\"headerlink\" title=\"5.5.1.创建namespace\"></a>5.5.1.创建namespace</h3><p><strong>默认情况下，所有service、data、group都在同一个namespace，名为public：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1372118520.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们可以点击页面新增按钮，添加一个namespace：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3779707690.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后，填写表单：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3324467829.png\" alt=\"请输入图片描述\"></p>\n<p><strong>就能在页面看到一个新的namespace：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1260870042.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"5-5-2-给微服务配置namespace\"><a href=\"#5-5-2-给微服务配置namespace\" class=\"headerlink\" title=\"5.5.2.给微服务配置namespace\"></a>5.5.2.给微服务配置namespace</h3><p><strong>给微服务配置namespace只能通过修改配置来实现。</strong></p>\n<p><strong>例如，修改order-service的application.yml文件：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        cluster-name: HZ</span><br><span class=\"line\">        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID</span><br></pre></td></tr></table></figure>\n\n<p><strong>重启order-service后，访问控制台，可以看到下面的结果：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1772694162.png\" alt=\"请输入图片描述\"></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/146473831.png\" alt=\"请输入图片描述\"></p>\n<p><strong>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1993890733.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"5-6-Nacos与Eureka的区别\"><a href=\"#5-6-Nacos与Eureka的区别\" class=\"headerlink\" title=\"5.6.Nacos与Eureka的区别\"></a>5.6.Nacos与Eureka的区别</h2><p><strong>Nacos的服务实例分为两种l类型：</strong></p>\n<ul>\n<li><strong>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</strong></li>\n<li><strong>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</strong></li>\n</ul>\n<p><strong>配置一个服务实例为永久实例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        ephemeral: false # 设置为非临时实例</span><br></pre></td></tr></table></figure>\n\n<p><strong>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4167214107.png\" alt=\"请输入图片描述\"></p>\n<ul>\n<li><strong>Nacos与eureka的共同点</strong><ul>\n<li><strong>都支持服务注册和服务拉取</strong></li>\n<li><strong>都支持服务提供者心跳方式做健康检测</strong></li>\n</ul>\n</li>\n<li><strong>Nacos与Eureka的区别</strong><ul>\n<li><strong>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</strong></li>\n<li><strong>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</strong></li>\n<li><strong>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</strong></li>\n<li><strong>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</strong></li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差...","permalink":"/post/SpringCloud使用篇01","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":2,"path":"api/tags/SpringCloud.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SpringCloud01\"><span class=\"toc-text\">SpringCloud01</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">1.认识微服务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-0-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">1.0.学习目标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.1.单体架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.2.分布式架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">1.3.微服务</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-SpringCloud\"><span class=\"toc-text\">1.4.SpringCloud</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">1.5.总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.服务拆分和远程调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">2.1.服务拆分原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">2.2.服务拆分示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-%E5%AF%BC%E5%85%A5Sql%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">2.2.1.导入Sql语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-%E5%AF%BC%E5%85%A5demo%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\">2.2.2.导入demo工程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2.3.实现远程调用案例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-1-%E6%A1%88%E4%BE%8B%E9%9C%80%E6%B1%82%EF%BC%9A\"><span class=\"toc-text\">2.3.1.案例需求：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-2-%E6%B3%A8%E5%86%8CRestTemplate\"><span class=\"toc-text\">2.3.2.注册RestTemplate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-3-%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.3.3.实现远程调用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%8F%90%E4%BE%9B%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">2.4.提供者与消费者</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">3.Eureka注册中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Eureka%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">3.1.Eureka的结构和作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E6%90%AD%E5%BB%BAeureka-server\"><span class=\"toc-text\">3.2.搭建eureka-server</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E5%88%9B%E5%BB%BAeureka-server%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">3.2.1.创建eureka-server服务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E5%BC%95%E5%85%A5eureka%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">3.2.2.引入eureka依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E7%BC%96%E5%86%99%E5%90%AF%E5%8A%A8%E7%B1%BB\"><span class=\"toc-text\">3.2.3.编写启动类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-4-%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3.2.4.编写配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-5-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">3.2.5.启动服务</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">3.3.服务注册</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2）配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAuser-service%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">3）启动多个user-service实例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0\"><span class=\"toc-text\">3.4.服务发现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-1\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1\"><span class=\"toc-text\">2）配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">3）服务拉取和负载均衡</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">4.Ribbon负载均衡</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4.1.负载均衡原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">4.2.源码跟踪</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89LoadBalancerIntercepor\"><span class=\"toc-text\">1）LoadBalancerIntercepor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89LoadBalancerClient\"><span class=\"toc-text\">2）LoadBalancerClient</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5IRule\"><span class=\"toc-text\">3）负载均衡策略IRule</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4）总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.3.负载均衡策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.3.1.负载均衡策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.3.2.自定义负载均衡策略</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">4.4.饥饿加载</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">5.Nacos注册中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AE%89%E8%A3%85Nacos\"><span class=\"toc-text\">5.1.认识和安装Nacos</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%88%B0nacos\"><span class=\"toc-text\">5.2.服务注册到nacos</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-2\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E9%85%8D%E7%BD%AEnacos%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">2）配置nacos地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E9%87%8D%E5%90%AF\"><span class=\"toc-text\">3）重启</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">5.3.服务分级存储模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-1-%E7%BB%99user-service%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">5.3.1.给user-service配置集群</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-2-%E5%90%8C%E9%9B%86%E7%BE%A4%E4%BC%98%E5%85%88%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">5.3.2.同集群优先的负载均衡</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-%E6%9D%83%E9%87%8D%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">5.4.权重配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB\"><span class=\"toc-text\">5.5.环境隔离</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-1-%E5%88%9B%E5%BB%BAnamespace\"><span class=\"toc-text\">5.5.1.创建namespace</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-2-%E7%BB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEnamespace\"><span class=\"toc-text\">5.5.2.给微服务配置namespace</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-Nacos%E4%B8%8EEureka%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">5.6.Nacos与Eureka的区别</span></a></li></ol></li></ol>","author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"每日新闻60s","uid":"df2bd4a3cae38597aabb2824e73aaab3","slug":"60s","date":"2023-08-25T10:49:36.000Z","updated":"2023-12-27T09:55:08.759Z","comments":true,"path":"api/articles/60s.json","keywords":null,"cover":[],"text":" ","permalink":"/post/60s","photos":[],"count_time":{"symbolsCount":1,"symbolsTime":"1 mins."},"categories":[{"name":"实用","slug":"实用","count":1,"path":"api/categories/实用.json"}],"tags":[{"name":"新闻","slug":"新闻","count":1,"path":"api/tags/新闻.json"}],"author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{"title":"SpringCloud 实用篇 02","uid":"6984a25a0e4d84e9bb902e845682c284","slug":"SpringCloud使用篇02","date":"2023-08-14T10:49:36.000Z","updated":"2023-12-28T07:02:50.223Z","comments":true,"path":"api/articles/SpringCloud使用篇02.json","keywords":null,"cover":[],"text":"SpringCloud 实用篇 020.学习目标1.Nacos 配置管理Nacos 除了可以做注册中心，同样可以做配置管理来使用。 1.1.统一配置管理当微服务...","permalink":"/post/SpringCloud使用篇02","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":2,"path":"api/tags/SpringCloud.json"},{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":1,"path":"api/tags/Spring.json"}],"author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true}}
=======
{"title":"SpringCloud 实用篇 01","uid":"eaa06ed45453f389a4efa6b3c6981c30","slug":"SpringCloud使用篇01","date":"2023-08-15T10:49:36.000Z","updated":"2024-01-01T01:14:58.889Z","comments":true,"path":"api/articles/SpringCloud使用篇01.json","keywords":null,"cover":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","content":"<h1 id=\"SpringCloud01\"><a href=\"#SpringCloud01\" class=\"headerlink\" title=\"SpringCloud01\"></a>SpringCloud01</h1><h1 id=\"1-认识微服务\"><a href=\"#1-认识微服务\" class=\"headerlink\" title=\"1.认识微服务\"></a>1.认识微服务</h1><p><strong>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</strong></p>\n<h2 id=\"1-0-学习目标\"><a href=\"#1-0-学习目标\" class=\"headerlink\" title=\"1.0.学习目标\"></a>1.0.学习目标</h2><p><strong>了解微服务架构的优缺点</strong></p>\n<h2 id=\"1-1-单体架构\"><a href=\"#1-1-单体架构\" class=\"headerlink\" title=\"1.1.单体架构\"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1930435349.png\" alt=\"请输入图片描述\"></p>\n<p><strong>单体架构的优缺点如下：</strong></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>架构简单</strong></li>\n<li><strong>部署成本低</strong></li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>耦合度高（维护困难、升级困难）</strong></li>\n</ul>\n<h2 id=\"1-2-分布式架构\"><a href=\"#1-2-分布式架构\" class=\"headerlink\" title=\"1.2.分布式架构\"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1589518135.png\" alt=\"请输入图片描述\"></p>\n<p><strong>分布式架构的优缺点：</strong></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>降低服务耦合</strong></li>\n<li><strong>有利于服务升级和拓展</strong></li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>服务调用关系错综复杂</strong></li>\n</ul>\n<p><strong>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</strong></p>\n<ul>\n<li><strong>服务拆分的粒度如何界定？</strong></li>\n<li><strong>服务之间如何调用？</strong></li>\n<li><strong>服务的调用关系如何管理？</strong></li>\n</ul>\n<p><strong>人们需要制定一套行之有效的标准来约束分布式架构。</strong></p>\n<h2 id=\"1-3-微服务\"><a href=\"#1-3-微服务\" class=\"headerlink\" title=\"1.3.微服务\"></a>1.3.微服务</h2><p><strong>微服务的架构特征：</strong></p>\n<ul>\n<li><strong>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</strong></li>\n<li><strong>自治：团队独立、技术独立、数据独立，独立部署和交付</strong></li>\n<li><strong>面向服务：服务提供统一标准的接口，与语言和技术无关</strong></li>\n<li><strong>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</strong></li>\n</ul>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3312298924.png\" alt=\"请输入图片描述\"></p>\n<p><strong>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</strong></p>\n<p><strong>因此，可以认为****微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p>\n<p><strong>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</strong></p>\n<p><strong>其中在Java领域最引人注目的就是SpringCloud提供的方案了。</strong></p>\n<h2 id=\"1-4-SpringCloud\"><a href=\"#1-4-SpringCloud\" class=\"headerlink\" title=\"1.4.SpringCloud\"></a>1.4.SpringCloud</h2><p><strong>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：</strong><a href=\"https://spring.io/projects/spring-cloud\">https://spring.io/projects/spring-cloud</a>。</p>\n<p><strong>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</strong></p>\n<p><strong>其中常见的组件包括：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2124846292.png\" alt=\"请输入图片描述\"></p>\n<p><strong>另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1116769699.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。</strong></p>\n<h2 id=\"1-5-总结\"><a href=\"#1-5-总结\" class=\"headerlink\" title=\"1.5.总结\"></a>1.5.总结</h2><ul>\n<li><strong>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</strong></li>\n<li><strong>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</strong></li>\n<li><strong>微服务：一种良好的分布式架构方案</strong><br><strong>①优点：拆分粒度更小、服务更独立、耦合度更低</strong><br><strong>②缺点：架构非常复杂，运维、监控、部署难度提高</strong></li>\n<li><strong>SpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</strong></li>\n</ul>\n<h1 id=\"2-服务拆分和远程调用\"><a href=\"#2-服务拆分和远程调用\" class=\"headerlink\" title=\"2.服务拆分和远程调用\"></a>2.服务拆分和远程调用</h1><p><strong>任何分布式架构都离不开服务的拆分，微服务也是一样。</strong></p>\n<h2 id=\"2-1-服务拆分原则\"><a href=\"#2-1-服务拆分原则\" class=\"headerlink\" title=\"2.1.服务拆分原则\"></a>2.1.服务拆分原则</h2><p><strong>这里我总结了微服务拆分时的几个原则：</strong></p>\n<ul>\n<li><strong>不同微服务，不要重复开发相同业务</strong></li>\n<li><strong>微服务数据独立，不要访问其它微服务的数据库</strong></li>\n<li><strong>微服务可以将自己的业务暴露为接口，供其它微服务调用</strong></li>\n</ul>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/743242425.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-2-服务拆分示例\"><a href=\"#2-2-服务拆分示例\" class=\"headerlink\" title=\"2.2.服务拆分示例\"></a>2.2.服务拆分示例</h2><p><strong>以课前资料中的微服务cloud-demo为例，其结构如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2958180924.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-demo：父工程，管理依赖</strong></p>\n<ul>\n<li><strong>order-service：订单微服务，负责订单相关业务</strong></li>\n<li><strong>user-service：用户微服务，负责用户相关业务</strong></li>\n</ul>\n<p><strong>要求：</strong></p>\n<ul>\n<li><strong>订单微服务和用户微服务都必须有各自的数据库，相互独立</strong></li>\n<li><strong>订单服务和用户服务都对外暴露Restful的接口</strong></li>\n<li><strong>订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库</strong></li>\n</ul>\n<h3 id=\"2-2-1-导入Sql语句\"><a href=\"#2-2-1-导入Sql语句\" class=\"headerlink\" title=\"2.2.1.导入Sql语句\"></a>2.2.1.导入Sql语句</h3><p><strong>首先，将课前资料提供的</strong><code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到mysql中：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/276624830.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-user表中初始数据如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/646977056.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-order表中初始数据如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/230156166.png\" alt=\"请输入图片描述\"></p>\n<p><strong>cloud-order表中持有cloud-user表中的id字段。</strong></p>\n<h3 id=\"2-2-2-导入demo工程\"><a href=\"#2-2-2-导入demo工程\" class=\"headerlink\" title=\"2.2.2.导入demo工程\"></a>2.2.2.导入demo工程</h3><p><strong>用IDEA导入课前资料提供的Demo：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/259698597.png\" alt=\"请输入图片描述\"></p>\n<p><strong>项目结构如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2087602036.png\" alt=\"请输入图片描述\"></p>\n<p><strong>导入后，会在IDEA右下角出现弹窗：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4014462343.png\" alt=\"请输入图片描述\"></p>\n<p><strong>点击弹窗，然后按下图选择：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2758611873.png\" alt=\"请输入图片描述\"></p>\n<p><strong>会出现这样的菜单：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2878946380.png\" alt=\"请输入图片描述\"></p>\n<p><strong>配置下项目使用的JDK：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1704992619.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-3-实现远程调用案例\"><a href=\"#2-3-实现远程调用案例\" class=\"headerlink\" title=\"2.3.实现远程调用案例\"></a>2.3.实现远程调用案例</h2><p><strong>在order-service服务中，有一个根据id查询订单的接口：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/997322769.png\" alt=\"请输入图片描述\"></p>\n<p><strong>根据id查询订单，返回值是Order对象，如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3761978351.png\" alt=\"请输入图片描述\"></p>\n<p><strong>其中的user为null</strong></p>\n<p><strong>在user-service中有一个根据id查询用户的接口：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3496087221.png\" alt=\"请输入图片描述\"></p>\n<p><strong>查询的结果如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1480743671.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"2-3-1-案例需求：\"><a href=\"#2-3-1-案例需求：\" class=\"headerlink\" title=\"2.3.1.案例需求：\"></a>2.3.1.案例需求：</h3><p><strong>修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。</strong></p>\n<p><strong>因此，我们需要在order-service中 向user-service发起一个http的请求，调用</strong><a href=\"http://localhost:8081/user/\">http://localhost:8081/user/</a>{userId}这个接口。</p>\n<p><strong>大概的步骤是这样的：</strong></p>\n<ul>\n<li><strong>注册一个RestTemplate的实例到Spring容器</strong></li>\n<li><strong>修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User</strong></li>\n<li><strong>将查询的User填充到Order对象，一起返回</strong></li>\n</ul>\n<h3 id=\"2-3-2-注册RestTemplate\"><a href=\"#2-3-2-注册RestTemplate\" class=\"headerlink\" title=\"2.3.2.注册RestTemplate\"></a>2.3.2.注册RestTemplate</h3><p><strong>首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.itcast.order;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.client.RestTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OrderApplication</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(OrderApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RestTemplate <span class=\"title function_\">restTemplate</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3-实现远程调用\"><a href=\"#2-3-3-实现远程调用\" class=\"headerlink\" title=\"2.3.3.实现远程调用\"></a>2.3.3.实现远程调用</h3><p><strong>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3877304843.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-4-提供者与消费者\"><a href=\"#2-4-提供者与消费者\" class=\"headerlink\" title=\"2.4.提供者与消费者\"></a>2.4.提供者与消费者</h2><p><strong>在服务调用关系中，会有两个不同的角色：</strong></p>\n<p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p>\n<p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4014088050.png\" alt=\"请输入图片描述\"></p>\n<p><strong>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</strong></p>\n<p><strong>如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？</strong></p>\n<ul>\n<li><strong>对于A调用B的业务而言：A是服务消费者，B是服务提供者</strong></li>\n<li><strong>对于B调用C的业务而言：B是服务消费者，C是服务提供者</strong></li>\n</ul>\n<p><strong>因此，服务B既可以是服务提供者，也可以是服务消费者。</strong></p>\n<h1 id=\"3-Eureka注册中心\"><a href=\"#3-Eureka注册中心\" class=\"headerlink\" title=\"3.Eureka注册中心\"></a>3.Eureka注册中心</h1><p><strong>假如我们的服务提供者user-service部署了多个实例，如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4224733546.png\" alt=\"请输入图片描述\"></p>\n<p><strong>大家思考几个问题：</strong></p>\n<ul>\n<li><strong>order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？</strong></li>\n<li><strong>有多个user-service实例地址，order-service调用时该如何选择？</strong></li>\n<li><strong>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></li>\n</ul>\n<h2 id=\"3-1-Eureka的结构和作用\"><a href=\"#3-1-Eureka的结构和作用\" class=\"headerlink\" title=\"3.1.Eureka的结构和作用\"></a>3.1.Eureka的结构和作用</h2><p><strong>这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2752427792.png\" alt=\"请输入图片描述\"></p>\n<p><strong>回答之前的各个问题。</strong></p>\n<p><strong>问题1：order-service如何得知user-service实例地址？</strong></p>\n<p><strong>获取地址信息的流程如下：</strong></p>\n<ul>\n<li><strong>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</strong></li>\n<li><strong>eureka-server保存服务名称到服务实例地址列表的映射关系</strong></li>\n<li><strong>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</strong></li>\n</ul>\n<p><strong>问题2：order-service如何从多个user-service实例中选择具体的实例？</strong></p>\n<ul>\n<li><strong>order-service从实例列表中利用负载均衡算法选中一个实例地址</strong></li>\n<li><strong>向该实例地址发起远程调用</strong></li>\n</ul>\n<p><strong>问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</strong></p>\n<ul>\n<li><strong>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</strong></li>\n<li><strong>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</strong></li>\n<li><strong>order-service拉取服务时，就能将故障实例排除了</strong></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</strong></p></blockquote>\n<p><strong>因此，接下来我们动手实践的步骤包括：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1313548687.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"3-2-搭建eureka-server\"><a href=\"#3-2-搭建eureka-server\" class=\"headerlink\" title=\"3.2.搭建eureka-server\"></a>3.2.搭建eureka-server</h2><p><strong>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</strong></p>\n<h3 id=\"3-2-1-创建eureka-server服务\"><a href=\"#3-2-1-创建eureka-server服务\" class=\"headerlink\" title=\"3.2.1.创建eureka-server服务\"></a>3.2.1.创建eureka-server服务</h3><p><strong>在cloud-demo父工程下，创建一个子模块：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3841721388.png\" alt=\"请输入图片描述\"></p>\n<p><strong>填写模块信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1592319894.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后填写服务信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/778676265.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3-2-2-引入eureka依赖\"><a href=\"#3-2-2-引入eureka依赖\" class=\"headerlink\" title=\"3.2.2.引入eureka依赖\"></a>3.2.2.引入eureka依赖</h3><p><strong>引入SpringCloud为eureka提供的starter依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-3-编写启动类\"><a href=\"#3-2-3-编写启动类\" class=\"headerlink\" title=\"3.2.3.编写启动类\"></a>3.2.3.编写启动类</h3><p><strong>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> cn.itcast.eureka;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-4-编写配置文件\"><a href=\"#3-2-4-编写配置文件\" class=\"headerlink\" title=\"3.2.4.编写配置文件\"></a>3.2.4.编写配置文件</h3><p><strong>编写一个application.yml文件，内容如下：</strong></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">10086</span></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">eureka-server</span></span><br><span class=\"line\"><span class=\"attr\">eureka:</span></span><br><span class=\"line\">  <span class=\"attr\">client:</span></span><br><span class=\"line\">    <span class=\"attr\">service-url:</span> </span><br><span class=\"line\">      <span class=\"attr\">defaultZone:</span> <span class=\"string\">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-5-启动服务\"><a href=\"#3-2-5-启动服务\" class=\"headerlink\" title=\"3.2.5.启动服务\"></a>3.2.5.启动服务</h3><p><strong>启动微服务，然后在浏览器访问：</strong><a href=\"http://127.0.0.1:10086/\">http://127.0.0.1:10086</a></p>\n<p><strong>看到下面结果应该是成功了：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/561278136.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"3-3-服务注册\"><a href=\"#3-3-服务注册\" class=\"headerlink\" title=\"3.3.服务注册\"></a>3.3.服务注册</h2><p><strong>下面，我们将user-service注册到eureka-server中去。</strong></p>\n<h3 id=\"1）引入依赖\"><a href=\"#1）引入依赖\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>在user-service的pom文件中，引入下面的eureka-client依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）配置文件\"><a href=\"#2）配置文件\" class=\"headerlink\" title=\"2）配置文件\"></a>2）配置文件</h3><p><strong>在user-service中，修改application.yml文件，添加服务名称、eureka地址：</strong></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">userservice</span></span><br><span class=\"line\"><span class=\"attr\">eureka:</span></span><br><span class=\"line\">  <span class=\"attr\">client:</span></span><br><span class=\"line\">    <span class=\"attr\">service-url:</span></span><br><span class=\"line\">      <span class=\"attr\">defaultZone:</span> <span class=\"string\">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3）启动多个user-service实例\"><a href=\"#3）启动多个user-service实例\" class=\"headerlink\" title=\"3）启动多个user-service实例\"></a>3）启动多个user-service实例</h3><p><strong>为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。</strong></p>\n<p><strong>首先，复制原来的user-service启动配置：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1492811656.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后，在弹出的窗口中，填写信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1195114028.png\" alt=\"请输入图片描述\"></p>\n<p><strong>现在，SpringBoot窗口会出现两个user-service启动配置：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3079890542.png\" alt=\"请输入图片描述\"></p>\n<p><strong>不过，第一个是8081端口，第二个是8082端口。</strong></p>\n<p><strong>启动两个user-service实例：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/219406862.png\" alt=\"请输入图片描述\"></p>\n<p><strong>查看eureka-server管理页面：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2688307359.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"3-4-服务发现\"><a href=\"#3-4-服务发现\" class=\"headerlink\" title=\"3.4.服务发现\"></a>3.4.服务发现</h2><p><strong>下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</strong></p>\n<h3 id=\"1）引入依赖-1\"><a href=\"#1）引入依赖-1\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</strong></p>\n<p><strong>在order-service的pom文件中，引入下面的eureka-client依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）配置文件-1\"><a href=\"#2）配置文件-1\" class=\"headerlink\" title=\"2）配置文件\"></a>2）配置文件</h3><p><strong>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</strong></p>\n<p><strong>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: orderservice</span><br><span class=\"line\">eureka:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    service-url:</span><br><span class=\"line\">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3）服务拉取和负载均衡\"><a href=\"#3）服务拉取和负载均衡\" class=\"headerlink\" title=\"3）服务拉取和负载均衡\"></a>3）服务拉取和负载均衡</h3><p><strong>最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</strong></p>\n<p><strong>不过这些动作不用我们去做，只需要添加一些注解即可。</strong></p>\n<p><strong>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1650867891.png\" alt=\"请输入图片描述\"></p>\n<p><strong>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1949514255.png\" alt=\"请输入图片描述\"></p>\n<p><strong>spring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</strong></p>\n<h1 id=\"4-Ribbon负载均衡\"><a href=\"#4-Ribbon负载均衡\" class=\"headerlink\" title=\"4.Ribbon负载均衡\"></a>4.Ribbon负载均衡</h1><p><strong>上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？</strong></p>\n<h2 id=\"4-1-负载均衡原理\"><a href=\"#4-1-负载均衡原理\" class=\"headerlink\" title=\"4.1.负载均衡原理\"></a>4.1.负载均衡原理</h2><p><strong>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1655186028.png\" alt=\"请输入图片描述\"></p>\n<p><strong>那么我们发出的请求明明是</strong><a href=\"http://userservice/user/1\">http://userservice/user/1</a>，怎么变成了<a href=\"http://localhost:8081/\">http://localhost:8081</a>的呢？</p>\n<h2 id=\"4-2-源码跟踪\"><a href=\"#4-2-源码跟踪\" class=\"headerlink\" title=\"4.2.源码跟踪\"></a>4.2.源码跟踪</h2><p><strong>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</strong></p>\n<p><strong>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是</strong><code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p>\n<p><strong>我们进行源码跟踪：</strong></p>\n<h3 id=\"1）LoadBalancerIntercepor\"><a href=\"#1）LoadBalancerIntercepor\" class=\"headerlink\" title=\"1）LoadBalancerIntercepor\"></a>1）LoadBalancerIntercepor</h3><p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3965529458.png\" alt=\"请输入图片描述\"></p>\n<p><strong>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</strong></p>\n<ul>\n<li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href=\"http://user-service/user/8\">http://user-service/user/8</a></li>\n<li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li>\n<li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li>\n</ul>\n<p><strong>这里的</strong><code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p>\n<h3 id=\"2）LoadBalancerClient\"><a href=\"#2）LoadBalancerClient\" class=\"headerlink\" title=\"2）LoadBalancerClient\"></a>2）LoadBalancerClient</h3><p><strong>继续跟入execute方法：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2194489919.png\" alt=\"请输入图片描述\"></p>\n<p><strong>代码是这样的：</strong></p>\n<ul>\n<li><strong>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</strong></li>\n<li><strong>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</strong></li>\n</ul>\n<p><strong>放行后，再次访问并跟踪，发现获取的是8081：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2180952791.png\" alt=\"请输入图片描述\"></p>\n<p><strong>果然实现了负载均衡。</strong></p>\n<h3 id=\"3）负载均衡策略IRule\"><a href=\"#3）负载均衡策略IRule\" class=\"headerlink\" title=\"3）负载均衡策略IRule\"></a>3）负载均衡策略IRule</h3><p><strong>在刚才的代码中，可以看到获取服务使通过一个</strong><code>getServer</code>方法来做负载均衡:</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2180952791.png\" alt=\"请输入图片描述\">!</p>\n<p><strong>我们继续跟入：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3554728783.png\" alt=\"请输入图片描述\"></p>\n<p><strong>继续跟踪源码chooseServer方法，发现这么一段代码：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/715945055.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们看看这个rule是谁：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1144925770.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这里的rule默认值是一个</strong><code>RoundRobinRule</code>，看类的介绍：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2415655125.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这不就是轮询的意思嘛。</strong></p>\n<p><strong>到这里，整个负载均衡的流程我们就清楚了。</strong></p>\n<h3 id=\"4）总结\"><a href=\"#4）总结\" class=\"headerlink\" title=\"4）总结\"></a>4）总结</h3><p><strong>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2692996040.png\" alt=\"请输入图片描述\"></p>\n<p><strong>基本流程如下：</strong></p>\n<ul>\n<li><strong>拦截我们的RestTemplate请求</strong><a href=\"http://userservice/user/1\">http://userservice/user/1</a></li>\n<li><strong>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</strong></li>\n<li><strong>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</strong></li>\n<li><strong>eureka返回列表，localhost:8081、localhost:8082</strong></li>\n<li><strong>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</strong></li>\n<li><strong>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到</strong><a href=\"http://localhost:8081/user/1\">http://localhost:8081/user/1</a>，发起真实请求</li>\n</ul>\n<h2 id=\"4-3-负载均衡策略\"><a href=\"#4-3-负载均衡策略\" class=\"headerlink\" title=\"4.3.负载均衡策略\"></a>4.3.负载均衡策略</h2><h3 id=\"4-3-1-负载均衡策略\"><a href=\"#4-3-1-负载均衡策略\" class=\"headerlink\" title=\"4.3.1.负载均衡策略\"></a>4.3.1.负载均衡策略</h3><p><strong>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2862678284.png\" alt=\"请输入图片描述\"></p>\n<p><strong>不同规则的含义如下：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>内置负载均衡规则类</strong></th>\n<th><strong>规则描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>RoundRobinRule</strong></td>\n<td><strong>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</strong></td>\n</tr>\n<tr>\n<td><strong>AvailabilityFilteringRule</strong></td>\n<td><strong>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的</strong><clientName><strong>.</strong><clientConfigNameSpace><strong>.ActiveConnectionsLimit属性进行配置。</strong></td>\n</tr>\n<tr>\n<td><strong>WeightedResponseTimeRule</strong></td>\n<td><strong>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</strong></td>\n</tr>\n<tr>\n<td><strong>ZoneAvoidanceRule</strong></td>\n<td><strong>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</strong></td>\n</tr>\n<tr>\n<td><strong>BestAvailableRule</strong></td>\n<td><strong>忽略那些短路的服务器，并选择并发数较低的服务器。</strong></td>\n</tr>\n<tr>\n<td><strong>RandomRule</strong></td>\n<td><strong>随机选择一个可用的服务器。</strong></td>\n</tr>\n<tr>\n<td><strong>RetryRule</strong></td>\n<td><strong>重试机制的选择逻辑</strong></td>\n</tr>\n</tbody></table>\n<p><strong>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</strong></p>\n<h3 id=\"4-3-2-自定义负载均衡策略\"><a href=\"#4-3-2-自定义负载均衡策略\" class=\"headerlink\" title=\"4.3.2.自定义负载均衡策略\"></a>4.3.2.自定义负载均衡策略</h3><p><strong>通过定义IRule实现可以修改负载均衡规则，有两种方式：</strong></p>\n<ol>\n<li><strong>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public IRule randomRule()&#123;</span><br><span class=\"line\">    return new RandomRule();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote>\n<h2 id=\"4-4-饥饿加载\"><a href=\"#4-4-饥饿加载\" class=\"headerlink\" title=\"4.4.饥饿加载\"></a>4.4.饥饿加载</h2><p><strong>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</strong></p>\n<p><strong>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ribbon:</span><br><span class=\"line\">  eager-load:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    clients: userservice</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5-Nacos注册中心\"><a href=\"#5-Nacos注册中心\" class=\"headerlink\" title=\"5.Nacos注册中心\"></a>5.Nacos注册中心</h1><p><strong>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。</strong></p>\n<h2 id=\"5-1-认识和安装Nacos\"><a href=\"#5-1-认识和安装Nacos\" class=\"headerlink\" title=\"5.1.认识和安装Nacos\"></a>5.1.认识和安装Nacos</h2><p><a href=\"https://nacos.io/\">Nacos</a>是阿里巴巴的产品，现在是<a href=\"https://spring.io/projects/spring-cloud\">SpringCloud</a>中的一个组件。相比<a href=\"https://github.com/Netflix/eureka\">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1962161475.png\" alt=\"请输入图片描述\"></p>\n<p><strong>安装方式可以参考课前资料《Nacos安装指南.md》</strong></p>\n<h2 id=\"5-2-服务注册到nacos\"><a href=\"#5-2-服务注册到nacos\" class=\"headerlink\" title=\"5.2.服务注册到nacos\"></a>5.2.服务注册到nacos</h2><p><strong>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</strong></p>\n<p><strong>主要差异在于：</strong></p>\n<ul>\n<li><strong>依赖不同</strong></li>\n<li><strong>服务地址不同</strong></li>\n</ul>\n<h3 id=\"1）引入依赖-2\"><a href=\"#1）引入依赖-2\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>在cloud-demo父工程的pom文件中的</strong><code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;</span><br><span class=\"line\">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p></blockquote>\n<h3 id=\"2）配置nacos地址\"><a href=\"#2）配置nacos地址\" class=\"headerlink\" title=\"2）配置nacos地址\"></a>2）配置nacos地址</h3><p><strong>在user-service和order-service的application.yml中添加nacos地址：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote>\n<h3 id=\"3）重启\"><a href=\"#3）重启\" class=\"headerlink\" title=\"3）重启\"></a>3）重启</h3><p><strong>重启微服务后，登录nacos管理页面，可以看到微服务信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2227711537.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"5-3-服务分级存储模型\"><a href=\"#5-3-服务分级存储模型\" class=\"headerlink\" title=\"5.3.服务分级存储模型\"></a>5.3.服务分级存储模型</h2><p><strong>一个****服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p>\n<ul>\n<li><strong>127.0.0.1:8081</strong></li>\n<li><strong>127.0.0.1:8082</strong></li>\n<li><strong>127.0.0.1:8083</strong></li>\n</ul>\n<p><strong>假如这些实例分布于全国各地的不同机房，例如：</strong></p>\n<ul>\n<li><strong>127.0.0.1:8081，在上海机房</strong></li>\n<li><strong>127.0.0.1:8082，在上海机房</strong></li>\n<li><strong>127.0.0.1:8083，在杭州机房</strong></li>\n</ul>\n<p><strong>Nacos就将同一机房内的实例 划分为一个****集群</strong>。</p>\n<p><strong>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1971170818.png\" alt=\"请输入图片描述\"></p>\n<p><strong>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1537336509.png\" alt=\"请输入图片描述\"></p>\n<p><strong>杭州机房内的order-service应该优先访问同机房的user-service。</strong></p>\n<h3 id=\"5-3-1-给user-service配置集群\"><a href=\"#5-3-1-给user-service配置集群\" class=\"headerlink\" title=\"5.3.1.给user-service配置集群\"></a>5.3.1.给user-service配置集群</h3><p><strong>修改user-service的application.yml文件，添加集群配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        cluster-name: HZ # 集群名称</span><br></pre></td></tr></table></figure>\n\n<p><strong>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2633449767.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们再次复制一个user-service启动配置，添加属性：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure>\n\n<p><strong>配置如图所示：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3724162407.png\" alt=\"请输入图片描述\"></p>\n<p><strong>启动UserApplication3后再次查看nacos控制台：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1733530142.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"5-3-2-同集群优先的负载均衡\"><a href=\"#5-3-2-同集群优先的负载均衡\" class=\"headerlink\" title=\"5.3.2.同集群优先的负载均衡\"></a>5.3.2.同集群优先的负载均衡</h3><p><strong>默认的</strong><code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p>\n<p><strong>因此Nacos中提供了一个</strong><code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p>\n<p><strong>1）给order-service配置集群信息</strong></p>\n<p><strong>修改order-service的application.yml文件，添加集群配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        cluster-name: HZ # 集群名称</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）修改负载均衡规则</strong></p>\n<p><strong>修改order-service的application.yml文件，修改负载均衡规则：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">userservice:</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-权重配置\"><a href=\"#5-4-权重配置\" class=\"headerlink\" title=\"5.4.权重配置\"></a>5.4.权重配置</h2><p><strong>实际部署中会出现这样的场景：</strong></p>\n<p><strong>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</strong></p>\n<p><strong>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</strong></p>\n<p><strong>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</strong></p>\n<p><strong>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3136365653.png\" alt=\"请输入图片描述\"></p>\n<p><strong>在弹出的编辑窗口，修改权重：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2429177452.png\" alt=\"请输入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote>\n<h2 id=\"5-5-环境隔离\"><a href=\"#5-5-环境隔离\" class=\"headerlink\" title=\"5.5.环境隔离\"></a>5.5.环境隔离</h2><p><strong>Nacos提供了namespace来实现环境隔离功能。</strong></p>\n<ul>\n<li><strong>nacos中可以有多个namespace</strong></li>\n<li><strong>namespace下可以有group、service等</strong></li>\n<li><strong>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</strong></li>\n</ul>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3494748668.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"5-5-1-创建namespace\"><a href=\"#5-5-1-创建namespace\" class=\"headerlink\" title=\"5.5.1.创建namespace\"></a>5.5.1.创建namespace</h3><p><strong>默认情况下，所有service、data、group都在同一个namespace，名为public：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1372118520.png\" alt=\"请输入图片描述\"></p>\n<p><strong>我们可以点击页面新增按钮，添加一个namespace：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3779707690.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后，填写表单：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3324467829.png\" alt=\"请输入图片描述\"></p>\n<p><strong>就能在页面看到一个新的namespace：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1260870042.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"5-5-2-给微服务配置namespace\"><a href=\"#5-5-2-给微服务配置namespace\" class=\"headerlink\" title=\"5.5.2.给微服务配置namespace\"></a>5.5.2.给微服务配置namespace</h3><p><strong>给微服务配置namespace只能通过修改配置来实现。</strong></p>\n<p><strong>例如，修改order-service的application.yml文件：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        cluster-name: HZ</span><br><span class=\"line\">        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID</span><br></pre></td></tr></table></figure>\n\n<p><strong>重启order-service后，访问控制台，可以看到下面的结果：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1772694162.png\" alt=\"请输入图片描述\"></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/146473831.png\" alt=\"请输入图片描述\"></p>\n<p><strong>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1993890733.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"5-6-Nacos与Eureka的区别\"><a href=\"#5-6-Nacos与Eureka的区别\" class=\"headerlink\" title=\"5.6.Nacos与Eureka的区别\"></a>5.6.Nacos与Eureka的区别</h2><p><strong>Nacos的服务实例分为两种l类型：</strong></p>\n<ul>\n<li><strong>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</strong></li>\n<li><strong>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</strong></li>\n</ul>\n<p><strong>配置一个服务实例为永久实例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      discovery:</span><br><span class=\"line\">        ephemeral: false # 设置为非临时实例</span><br></pre></td></tr></table></figure>\n\n<p><strong>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4167214107.png\" alt=\"请输入图片描述\"></p>\n<ul>\n<li><strong>Nacos与eureka的共同点</strong><ul>\n<li><strong>都支持服务注册和服务拉取</strong></li>\n<li><strong>都支持服务提供者心跳方式做健康检测</strong></li>\n</ul>\n</li>\n<li><strong>Nacos与Eureka的区别</strong><ul>\n<li><strong>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</strong></li>\n<li><strong>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</strong></li>\n<li><strong>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</strong></li>\n<li><strong>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</strong></li>\n</ul>\n</li>\n</ul>\n","feature":true,"text":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差...","permalink":"/post/SpringCloud使用篇01","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Java","slug":"Java","count":3,"path":"api/categories/Java.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":2,"path":"api/tags/SpringCloud.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SpringCloud01\"><span class=\"toc-text\">SpringCloud01</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">1.认识微服务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-0-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">1.0.学习目标</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.1.单体架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.2.分布式架构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">1.3.微服务</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-SpringCloud\"><span class=\"toc-text\">1.4.SpringCloud</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">1.5.总结</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.服务拆分和远程调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">2.1.服务拆分原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">2.2.服务拆分示例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-%E5%AF%BC%E5%85%A5Sql%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">2.2.1.导入Sql语句</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-%E5%AF%BC%E5%85%A5demo%E5%B7%A5%E7%A8%8B\"><span class=\"toc-text\">2.2.2.导入demo工程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2.3.实现远程调用案例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-1-%E6%A1%88%E4%BE%8B%E9%9C%80%E6%B1%82%EF%BC%9A\"><span class=\"toc-text\">2.3.1.案例需求：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-2-%E6%B3%A8%E5%86%8CRestTemplate\"><span class=\"toc-text\">2.3.2.注册RestTemplate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-3-%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.3.3.实现远程调用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%8F%90%E4%BE%9B%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85\"><span class=\"toc-text\">2.4.提供者与消费者</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">3.Eureka注册中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-Eureka%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">3.1.Eureka的结构和作用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-%E6%90%AD%E5%BB%BAeureka-server\"><span class=\"toc-text\">3.2.搭建eureka-server</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-1-%E5%88%9B%E5%BB%BAeureka-server%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">3.2.1.创建eureka-server服务</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-2-%E5%BC%95%E5%85%A5eureka%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">3.2.2.引入eureka依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-3-%E7%BC%96%E5%86%99%E5%90%AF%E5%8A%A8%E7%B1%BB\"><span class=\"toc-text\">3.2.3.编写启动类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-4-%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">3.2.4.编写配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-5-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">3.2.5.启动服务</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">3.3.服务注册</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">2）配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AAuser-service%E5%AE%9E%E4%BE%8B\"><span class=\"toc-text\">3）启动多个user-service实例</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0\"><span class=\"toc-text\">3.4.服务发现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-1\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1\"><span class=\"toc-text\">2）配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">3）服务拉取和负载均衡</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">4.Ribbon负载均衡</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4.1.负载均衡原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-2-%E6%BA%90%E7%A0%81%E8%B7%9F%E8%B8%AA\"><span class=\"toc-text\">4.2.源码跟踪</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89LoadBalancerIntercepor\"><span class=\"toc-text\">1）LoadBalancerIntercepor</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89LoadBalancerClient\"><span class=\"toc-text\">2）LoadBalancerClient</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5IRule\"><span class=\"toc-text\">3）负载均衡策略IRule</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4）总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.3.负载均衡策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.3.1.负载均衡策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">4.3.2.自定义负载均衡策略</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-4-%E9%A5%A5%E9%A5%BF%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">4.4.饥饿加载</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">5.Nacos注册中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-1-%E8%AE%A4%E8%AF%86%E5%92%8C%E5%AE%89%E8%A3%85Nacos\"><span class=\"toc-text\">5.1.认识和安装Nacos</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-2-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%88%B0nacos\"><span class=\"toc-text\">5.2.服务注册到nacos</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-2\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E9%85%8D%E7%BD%AEnacos%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">2）配置nacos地址</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E9%87%8D%E5%90%AF\"><span class=\"toc-text\">3）重启</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-3-%E6%9C%8D%E5%8A%A1%E5%88%86%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">5.3.服务分级存储模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-1-%E7%BB%99user-service%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">5.3.1.给user-service配置集群</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-2-%E5%90%8C%E9%9B%86%E7%BE%A4%E4%BC%98%E5%85%88%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">5.3.2.同集群优先的负载均衡</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-4-%E6%9D%83%E9%87%8D%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">5.4.权重配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-5-%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB\"><span class=\"toc-text\">5.5.环境隔离</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-1-%E5%88%9B%E5%BB%BAnamespace\"><span class=\"toc-text\">5.5.1.创建namespace</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-2-%E7%BB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEnamespace\"><span class=\"toc-text\">5.5.2.给微服务配置namespace</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-6-Nacos%E4%B8%8EEureka%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">5.6.Nacos与Eureka的区别</span></a></li></ol></li></ol>","author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"每日新闻60s","uid":"df2bd4a3cae38597aabb2824e73aaab3","slug":"60s","date":"2023-08-25T10:49:36.000Z","updated":"2023-12-27T09:55:08.759Z","comments":true,"path":"api/articles/60s.json","keywords":null,"cover":[],"text":" ","permalink":"/post/60s","photos":[],"count_time":{"symbolsCount":1,"symbolsTime":"1 mins."},"categories":[{"name":"实用","slug":"实用","count":1,"path":"api/categories/实用.json"}],"tags":[{"name":"新闻","slug":"新闻","count":1,"path":"api/tags/新闻.json"}],"author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2023-12-27T08:45:00.000Z","updated":"2023-12-28T08:57:49.337Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":448,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}}}
>>>>>>> 9eb1465 (second)
