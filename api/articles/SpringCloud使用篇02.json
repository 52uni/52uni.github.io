<<<<<<< HEAD
{"title":"SpringCloud 实用篇 02","uid":"6984a25a0e4d84e9bb902e845682c284","slug":"SpringCloud使用篇02","date":"2023-08-14T10:49:36.000Z","updated":"2023-12-28T07:02:50.223Z","comments":true,"path":"api/articles/SpringCloud使用篇02.json","keywords":null,"cover":[],"content":"<h1 id=\"SpringCloud-实用篇-02\"><a href=\"#SpringCloud-实用篇-02\" class=\"headerlink\" title=\"SpringCloud 实用篇 02\"></a>SpringCloud 实用篇 02</h1><h1 id=\"0-学习目标\"><a href=\"#0-学习目标\" class=\"headerlink\" title=\"0.学习目标\"></a>0.学习目标</h1><h1 id=\"1-Nacos-配置管理\"><a href=\"#1-Nacos-配置管理\" class=\"headerlink\" title=\"1.Nacos 配置管理\"></a>1.Nacos 配置管理</h1><p><strong>Nacos 除了可以做注册中心，同样可以做配置管理来使用。</strong></p>\n<h2 id=\"1-1-统一配置管理\"><a href=\"#1-1-统一配置管理\" class=\"headerlink\" title=\"1.1.统一配置管理\"></a>1.1.统一配置管理</h2><p><strong>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1125086243.png\" alt=\"请输入图片描述\"></p>\n<p><strong>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</strong></p>\n<h3 id=\"1-1-1-在-nacos-中添加配置文件\"><a href=\"#1-1-1-在-nacos-中添加配置文件\" class=\"headerlink\" title=\"1.1.1.在 nacos 中添加配置文件\"></a>1.1.1.在 nacos 中添加配置文件</h3><p><strong>如何在 nacos 中管理配置呢？</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2955026738.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后在弹出的表单中，填写配置信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/430074037.png\" alt=\"请输入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</strong></p></blockquote>\n<h3 id=\"1-1-2-从微服务拉取配置\"><a href=\"#1-1-2-从微服务拉取配置\" class=\"headerlink\" title=\"1.1.2.从微服务拉取配置\"></a>1.1.2.从微服务拉取配置</h3><p><strong>微服务要拉取 nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。</strong></p>\n<p><strong>但如果尚未读取 application.yml，又如何得知 nacos 地址呢？</strong></p>\n<p><strong>因此 spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/506346522.png\" alt=\"请输入图片描述\"></p>\n<p><strong>1）引入 nacos-config 依赖</strong></p>\n<p><strong>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--nacos配置管理依赖--&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）添加 bootstrap.yaml</strong></p>\n<p><strong>然后，在 user-service 中添加一个 bootstrap.yaml 文件，内容如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: userservice # 服务名称</span><br><span class=\"line\">  profiles:</span><br><span class=\"line\">    active: dev #开发环境，这里是dev</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848 # Nacos地址</span><br><span class=\"line\">      config:</span><br><span class=\"line\">        file-extension: yaml # 文件后缀名</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里会根据 spring.cloud.nacos.server-addr 获取 nacos 地址，再根据</strong></p>\n<p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件 id，来读取配置。</p>\n<p><strong>本例中，就是去读取</strong><code>userservice-dev.yaml</code>：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3048058808.png\" alt=\"请输入图片描述\"></p>\n<p><strong>3）读取 nacos 配置</strong></p>\n<p><strong>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4099625314.png\" alt=\"请输入图片描述\"></p>\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.user.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import cn.itcast.user.pojo.User;</span><br><span class=\"line\">import cn.itcast.user.service.UserService;</span><br><span class=\"line\">import lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDateTime;</span><br><span class=\"line\">import java.time.format.DateTimeFormatter;</span><br><span class=\"line\"></span><br><span class=\"line\">@Slf4j</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/user&quot;)</span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br><span class=\"line\">    private String dateformat;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @GetMapping(&quot;now&quot;)</span><br><span class=\"line\">    public String now()&#123;</span><br><span class=\"line\">        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // ...略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在页面访问，可以看到效果：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3759614107.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"1-2-配置热更新\"><a href=\"#1-2-配置热更新\" class=\"headerlink\" title=\"1.2.配置热更新\"></a>1.2.配置热更新</h2><p>**我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是****配置热更新**。</p>\n<p><strong>要实现配置热更新，可以使用两种方式：</strong></p>\n<h3 id=\"1-2-1-方式一\"><a href=\"#1-2-1-方式一\" class=\"headerlink\" title=\"1.2.1.方式一\"></a>1.2.1.方式一</h3><p><strong>在@Value 注入的变量所在类上添加注解@RefreshScope：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2124578473.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"1-2-2-方式二\"><a href=\"#1-2-2-方式二\" class=\"headerlink\" title=\"1.2.2.方式二\"></a>1.2.2.方式二</h3><p><strong>使用@ConfigurationProperties 注解代替@Value 注解。</strong></p>\n<p><strong>在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.user.config;</span><br><span class=\"line\"></span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component</span><br><span class=\"line\">@Data</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class=\"line\">public class PatternProperties &#123;</span><br><span class=\"line\">    private String dateformat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 UserController 中使用这个类代替@Value：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1790634262.png\" alt=\"请输入图片描述\"></p>\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.user.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import cn.itcast.user.config.PatternProperties;</span><br><span class=\"line\">import cn.itcast.user.pojo.User;</span><br><span class=\"line\">import cn.itcast.user.service.UserService;</span><br><span class=\"line\">import lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDateTime;</span><br><span class=\"line\">import java.time.format.DateTimeFormatter;</span><br><span class=\"line\"></span><br><span class=\"line\">@Slf4j</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/user&quot;)</span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatternProperties patternProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(&quot;now&quot;)</span><br><span class=\"line\">    public String now()&#123;</span><br><span class=\"line\">        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-配置共享\"><a href=\"#1-3-配置共享\" class=\"headerlink\" title=\"1.3.配置共享\"></a>1.3.配置共享</h2><p><strong>其实微服务启动时，会去 nacos 读取多个配置文件，例如：</strong></p>\n<ul>\n<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>\n<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li>\n</ul>\n<p><strong>而</strong><code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p>\n<p><strong>下面我们通过案例来测试配置共享</strong></p>\n<h3 id=\"1）添加一个环境共享配置\"><a href=\"#1）添加一个环境共享配置\" class=\"headerlink\" title=\"1）添加一个环境共享配置\"></a>1）添加一个环境共享配置</h3><p><strong>我们在 nacos 中添加一个 userservice.yaml 文件：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4255474564.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"2）在-user-service-中读取共享配置\"><a href=\"#2）在-user-service-中读取共享配置\" class=\"headerlink\" title=\"2）在 user-service 中读取共享配置\"></a>2）在 user-service 中读取共享配置</h3><p><strong>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1527405082.png\" alt=\"请输入图片描述\"></p>\n<p><strong>在 user-service 服务中，修改 UserController，添加一个方法：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2758212015.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3）运行两个-UserApplication，使用不同的-profile\"><a href=\"#3）运行两个-UserApplication，使用不同的-profile\" class=\"headerlink\" title=\"3）运行两个 UserApplication，使用不同的 profile\"></a>3）运行两个 UserApplication，使用不同的 profile</h3><p><strong>修改 UserApplication2 这个启动项，改变其 profile 值：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/399072175.png\" alt=\"请输入图片描述\"></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3251838110.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这样，UserApplication(8081)使用的 profile 是 dev，UserApplication2(8082)使用的 profile 是 test。</strong></p>\n<p><strong>启动 UserApplication 和 UserApplication2</strong></p>\n<p><strong>访问</strong><a href=\"http://localhost:8081/user/prop\">http://localhost:8081/user/prop</a>，结果：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1153437790.png\" alt=\"请输入图片描述\"></p>\n<p><strong>访问</strong><a href=\"http://localhost:8082/user/prop\">http://localhost:8082/user/prop</a>，结果：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1274812329.png\" alt=\"请输入图片描述\"></p>\n<p><strong>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</strong></p>\n<h3 id=\"4）配置共享的优先级\"><a href=\"#4）配置共享的优先级\" class=\"headerlink\" title=\"4）配置共享的优先级\"></a>4）配置共享的优先级</h3><p><strong>当 nacos、服务本地同时出现相同属性时，优先级有高低之分：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2896504755.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"1-4-搭建-Nacos-集群\"><a href=\"#1-4-搭建-Nacos-集群\" class=\"headerlink\" title=\"1.4.搭建 Nacos 集群\"></a>1.4.搭建 Nacos 集群</h2><p><strong>Nacos 生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3913142232.png\" alt=\"请输入图片描述\"></p>\n<h1 id=\"2-Feign-远程调用\"><a href=\"#2-Feign-远程调用\" class=\"headerlink\" title=\"2.Feign 远程调用\"></a>2.Feign 远程调用</h1><p><strong>先来看我们以前利用 RestTemplate 发起远程调用的代码：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4205281578.png\" alt=\"请输入图片描述\"></p>\n<p><strong>存在下面的问题：</strong></p>\n<p><strong>•代码可读性差，编程体验不统一</strong></p>\n<p><strong>•参数复杂 URL 难以维护</strong></p>\n<p><strong>Feign 是一个声明式的 http 客户端，官方地址：</strong><a href=\"https://github.com/OpenFeign/feign\">https://github.com/OpenFeign/feign</a></p>\n<p><strong>其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1629857719.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-1-Feign-替代-RestTemplate\"><a href=\"#2-1-Feign-替代-RestTemplate\" class=\"headerlink\" title=\"2.1.Feign 替代 RestTemplate\"></a>2.1.Feign 替代 RestTemplate</h2><p><strong>Fegin 的使用步骤如下：</strong></p>\n<h3 id=\"1）引入依赖\"><a href=\"#1）引入依赖\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>我们在 order-service 服务的 pom 文件中引入 feign 的依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）添加注解\"><a href=\"#2）添加注解\" class=\"headerlink\" title=\"2）添加注解\"></a>2）添加注解</h3><p><strong>在 order-service 的启动类添加注解开启 Feign 的功能：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1193055115.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3）编写-Feign-的客户端\"><a href=\"#3）编写-Feign-的客户端\" class=\"headerlink\" title=\"3）编写 Feign 的客户端\"></a>3）编写 Feign 的客户端</h3><p><strong>在 order-service 中新建一个接口，内容如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.order.client;</span><br><span class=\"line\"></span><br><span class=\"line\">import cn.itcast.order.pojo.User;</span><br><span class=\"line\">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"></span><br><span class=\"line\">@FeignClient(&quot;userservice&quot;)</span><br><span class=\"line\">public interface UserClient &#123;</span><br><span class=\"line\">    @GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class=\"line\">    User findById(@PathVariable(&quot;id&quot;) Long id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：</strong></p>\n<ul>\n<li><strong>服务名称：userservice</strong></li>\n<li><strong>请求方式：GET</strong></li>\n<li><strong>请求路径：&#x2F;user&#x2F;{id}</strong></li>\n<li><strong>请求参数：Long id</strong></li>\n<li><strong>返回值类型：User</strong></li>\n</ul>\n<p><strong>这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</strong></p>\n<h3 id=\"4）测试\"><a href=\"#4）测试\" class=\"headerlink\" title=\"4）测试\"></a>4）测试</h3><p><strong>修改 order-service 中的 OrderService 类中的 queryOrderById 方法，使用 Feign 客户端代替 RestTemplate：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1980193915.png\" alt=\"请输入图片描述\"></p>\n<p><strong>是不是看起来优雅多了。</strong></p>\n<h3 id=\"5）总结\"><a href=\"#5）总结\" class=\"headerlink\" title=\"5）总结\"></a>5）总结</h3><p><strong>使用 Feign 的步骤：</strong></p>\n<p><strong>① 引入依赖</strong></p>\n<p><strong>② 添加@EnableFeignClients 注解</strong></p>\n<p><strong>③ 编写 FeignClient 接口</strong></p>\n<p><strong>④ 使用 FeignClient 中定义的方法代替 RestTemplate</strong></p>\n<h2 id=\"2-2-自定义配置\"><a href=\"#2-2-自定义配置\" class=\"headerlink\" title=\"2.2.自定义配置\"></a>2.2.自定义配置</h2><p><strong>Feign 可以支持很多的自定义配置，如下表所示：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>类型</strong></th>\n<th><strong>作用</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>feign.Logger.Level</strong></td>\n<td><strong>修改日志级别</strong></td>\n<td><strong>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</strong></td>\n</tr>\n<tr>\n<td><strong>feign.codec.Decoder</strong></td>\n<td><strong>响应结果的解析器</strong></td>\n<td><strong>http 远程调用的结果做解析，例如解析 json 字符串为 java 对象</strong></td>\n</tr>\n<tr>\n<td><strong>feign.codec.Encoder</strong></td>\n<td><strong>请求参数编码</strong></td>\n<td><strong>将请求参数编码，便于通过 http 请求发送</strong></td>\n</tr>\n<tr>\n<td><strong>feign. Contract</strong></td>\n<td><strong>支持的注解格式</strong></td>\n<td><strong>默认是 SpringMVC 的注解</strong></td>\n</tr>\n<tr>\n<td><strong>feign. Retryer</strong></td>\n<td><strong>失败重试机制</strong></td>\n<td><strong>请求失败的重试机制，默认是没有，不过会使用 Ribbon 的重试</strong></td>\n</tr>\n</tbody></table>\n<p><strong>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean 覆盖默认 Bean 即可。</strong></p>\n<p><strong>下面以日志为例来演示如何自定义配置。</strong></p>\n<h3 id=\"2-2-1-配置文件方式\"><a href=\"#2-2-1-配置文件方式\" class=\"headerlink\" title=\"2.2.1.配置文件方式\"></a>2.2.1.配置文件方式</h3><p><strong>基于配置文件修改 feign 的日志级别可以针对单个服务：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign:  </span><br><span class=\"line\">  client:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      userservice: # 针对某个微服务的配置</span><br><span class=\"line\">        loggerLevel: FULL #  日志级别</span><br></pre></td></tr></table></figure>\n\n<p><strong>也可以针对所有服务：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign:  </span><br><span class=\"line\">  client:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br><span class=\"line\">        loggerLevel: FULL #  日志级别</span><br></pre></td></tr></table></figure>\n\n<p><strong>而日志的级别分为四种：</strong></p>\n<ul>\n<li><strong>NONE：不记录任何日志信息，这是默认值。</strong></li>\n<li><strong>BASIC：仅记录请求的方法，URL 以及响应状态码和执行时间</strong></li>\n<li><strong>HEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息</strong></li>\n<li><strong>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</strong></li>\n</ul>\n<h3 id=\"2-2-2-Java-代码方式\"><a href=\"#2-2-2-Java-代码方式\" class=\"headerlink\" title=\"2.2.2.Java 代码方式\"></a>2.2.2.Java 代码方式</h3><p><strong>也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefaultFeignConfiguration  &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Logger.Level feignLogLevel()&#123;</span><br><span class=\"line\">        return Logger.Level.BASIC; // 日志级别为BASIC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>**如果要****全局生效**，将其放到启动类的@EnableFeignClients 这个注解中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span><br></pre></td></tr></table></figure>\n\n<p>**如果是****局部生效**，则把它放到对应的@FeignClient 这个注解中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Feign-使用优化\"><a href=\"#2-3-Feign-使用优化\" class=\"headerlink\" title=\"2.3.Feign 使用优化\"></a>2.3.Feign 使用优化</h2><p><strong>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：</strong></p>\n<p><strong>•URLConnection：默认实现，不支持连接池</strong></p>\n<p><strong>•Apache HttpClient ：支持连接池</strong></p>\n<p><strong>•OKHttp：支持连接池</strong></p>\n<p>**因此提高 Feign 的性能主要手段就是使用****连接池**代替默认的 URLConnection。</p>\n<p><strong>这里我们用 Apache 的 HttpClient 来演示。</strong></p>\n<p><strong>1）引入依赖</strong></p>\n<p><strong>在 order-service 的 pom 文件中引入 Apache 的 HttpClient 依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--httpClient的依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）配置连接池</strong></p>\n<p><strong>在 order-service 的 application.yml 中添加配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      default: # default全局的配置</span><br><span class=\"line\">        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息</span><br><span class=\"line\">  httpclient:</span><br><span class=\"line\">    enabled: true # 开启feign对HttpClient的支持</span><br><span class=\"line\">    max-connections: 200 # 最大的连接数</span><br><span class=\"line\">    max-connections-per-route: 50 # 每个路径的最大连接数</span><br></pre></td></tr></table></figure>\n\n<p><strong>接下来，在 FeignClientFactoryBean 中的 loadBalance 方法中打断点：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3416768888.png\" alt=\"请输入图片描述\"></p>\n<p><strong>Debug 方式启动 order-service 服务，可以看到这里的 client，底层就是 Apache HttpClient：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3071575752.png\" alt=\"请输入图片描述\"></p>\n<p><strong>总结，Feign 的优化：</strong></p>\n<p><strong>1.日志级别尽量用 basic</strong></p>\n<p><strong>2.使用 HttpClient 或 OKHttp 代替 URLConnection</strong></p>\n<p><strong>① 引入 feign-httpClient 依赖</strong></p>\n<p><strong>② 配置文件开启 httpClient 功能，设置连接池参数</strong></p>\n<h2 id=\"2-4-最佳实践\"><a href=\"#2-4-最佳实践\" class=\"headerlink\" title=\"2.4.最佳实践\"></a>2.4.最佳实践</h2><p><strong>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</strong></p>\n<p><strong>自习观察可以发现，Feign 的客户端与服务提供者的 controller 代码非常相似：</strong></p>\n<p><strong>feign 客户端：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3052501456.png\" alt=\"请输入图片描述\"></p>\n<p><strong>UserController：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4011192970.png\" alt=\"请输入图片描述\"></p>\n<p><strong>有没有一种办法简化这种重复的代码编写呢？</strong></p>\n<h3 id=\"2-4-1-继承方式\"><a href=\"#2-4-1-继承方式\" class=\"headerlink\" title=\"2.4.1.继承方式\"></a>2.4.1.继承方式</h3><p><strong>一样的代码可以通过继承来共享：</strong></p>\n<p><strong>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明。</strong></p>\n<p><strong>2）Feign 客户端和 Controller 都集成改接口</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3750477059.png\" alt=\"请输入图片描述\"></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>简单</strong></li>\n<li><strong>实现了代码共享</strong></li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>服务提供方、服务消费方紧耦合</strong></li>\n<li><strong>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</strong></li>\n</ul>\n<h3 id=\"2-4-2-抽取方式\"><a href=\"#2-4-2-抽取方式\" class=\"headerlink\" title=\"2.4.2.抽取方式\"></a>2.4.2.抽取方式</h3><p><strong>将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</strong></p>\n<p><strong>例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4056594834.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"2-4-3-实现基于抽取的最佳实践\"><a href=\"#2-4-3-实现基于抽取的最佳实践\" class=\"headerlink\" title=\"2.4.3.实现基于抽取的最佳实践\"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id=\"1）抽取\"><a href=\"#1）抽取\" class=\"headerlink\" title=\"1）抽取\"></a>1）抽取</h4><p><strong>首先创建一个 module，命名为 feign-api：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1640147792.png\" alt=\"请输入图片描述\"></p>\n<p><strong>项目结构：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4187903423.png\" alt=\"请输入图片描述\"></p>\n<p><strong>在 feign-api 中然后引入 feign 的 starter 依赖</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后，order-service 中编写的 UserClient、User、DefaultFeignConfiguration 都复制到 feign-api 项目中</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/962664599.png\" alt=\"请输入图片描述\"></p>\n<h4 id=\"2）在-order-service-中使用-feign-api\"><a href=\"#2）在-order-service-中使用-feign-api\" class=\"headerlink\" title=\"2）在 order-service 中使用 feign-api\"></a>2）在 order-service 中使用 feign-api</h4><p><strong>首先，删除 order-service 中的 UserClient、User、DefaultFeignConfiguration 等类或接口。</strong></p>\n<p><strong>在 order-service 的 pom 文件中中引入 feign-api 的依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;feign-api&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>修改 order-service 中的所有与上述三个组件有关的导包部分，改成导入 feign-api 中的包</strong></p>\n<h4 id=\"3）重启测试\"><a href=\"#3）重启测试\" class=\"headerlink\" title=\"3）重启测试\"></a>3）重启测试</h4><p><strong>重启后，发现服务报错了：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/316459633.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这是因为 UserClient 现在在 cn.itcast.feign.clients 包下，</strong></p>\n<p><strong>而 order-service 的@EnableFeignClients 注解是在 cn.itcast.order 包下，不在同一个包，无法扫描到 UserClient。</strong></p>\n<h4 id=\"4）解决扫描包问题\"><a href=\"#4）解决扫描包问题\" class=\"headerlink\" title=\"4）解决扫描包问题\"></a>4）解决扫描包问题</h4><p><strong>方式一：</strong></p>\n<p><strong>指定 Feign 应该扫描的包：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>方式二：</strong></p>\n<p><strong>指定需要加载的 Client 接口：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-Gateway-服务网关\"><a href=\"#3-Gateway-服务网关\" class=\"headerlink\" title=\"3.Gateway 服务网关\"></a>3.Gateway 服务网关</h1><p><strong>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</strong></p>\n<h2 id=\"3-1-为什么需要网关\"><a href=\"#3-1-为什么需要网关\" class=\"headerlink\" title=\"3.1.为什么需要网关\"></a>3.1.为什么需要网关</h2><p><strong>Gateway 网关是我们服务的守门神，所有微服务的统一入口。</strong></p>\n<p>**网关的****核心功能特性**：</p>\n<ul>\n<li><strong>请求路由</strong></li>\n<li><strong>权限控制</strong></li>\n<li><strong>限流</strong></li>\n</ul>\n<p><strong>架构图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2908797109.png\" alt=\"请输入图片描述\"></p>\n<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>\n<p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>\n<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>\n<p><strong>在 SpringCloud 中网关的实现包括两种：</strong></p>\n<ul>\n<li><strong>gateway</strong></li>\n<li><strong>zuul</strong></li>\n</ul>\n<p><strong>Zuul 是基于 Servlet 的实现，属于阻塞式编程。而 SpringCloudGateway 则是基于 Spring5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。</strong></p>\n<h2 id=\"3-2-gateway-快速入门\"><a href=\"#3-2-gateway-快速入门\" class=\"headerlink\" title=\"3.2.gateway 快速入门\"></a>3.2.gateway 快速入门</h2><p><strong>下面，我们就演示下网关的基本路由功能。基本步骤如下：</strong></p>\n<ol>\n<li><strong>创建 SpringBoot 工程 gateway，引入网关依赖</strong></li>\n<li><strong>编写启动类</strong></li>\n<li><strong>编写基础配置和路由规则</strong></li>\n<li><strong>启动网关服务进行测试</strong></li>\n</ol>\n<h3 id=\"1）创建-gateway-服务，引入依赖\"><a href=\"#1）创建-gateway-服务，引入依赖\" class=\"headerlink\" title=\"1）创建 gateway 服务，引入依赖\"></a>1）创建 gateway 服务，引入依赖</h3><p><strong>创建服务：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3715852231.png\" alt=\"请输入图片描述\"></p>\n<p><strong>引入依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--网关--&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;!--nacos服务发现依赖--&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）编写启动类\"><a href=\"#2）编写启动类\" class=\"headerlink\" title=\"2）编写启动类\"></a>2）编写启动类</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.gateway;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class GatewayApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">SpringApplication.run(GatewayApplication.class, args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3）编写基础配置和路由规则\"><a href=\"#3）编写基础配置和路由规则\" class=\"headerlink\" title=\"3）编写基础配置和路由规则\"></a>3）编写基础配置和路由规则</h3><p><strong>创建 application.yml 文件，内容如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 10010 # 网关端口</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: gateway # 服务名称</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848 # nacos地址</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      routes: # 网关路由配置</span><br><span class=\"line\">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class=\"line\">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class=\"line\">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class=\"line\">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class=\"line\">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们将符合</strong><code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>\n<p>**本例中，我们将 **<code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb 是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p>\n<h3 id=\"4）重启测试\"><a href=\"#4）重启测试\" class=\"headerlink\" title=\"4）重启测试\"></a>4）重启测试</h3><p><strong>重启网关，访问</strong><a href=\"http://localhost:10010/user/1\">http://localhost:10010/user/1</a>时，符合<code>/user/**</code>规则，请求转发到 uri：<a href=\"http://userservice/user/1\">http://userservice/user/1</a>，得到了结果：</p>\n<p><img src=\"file://D:\\study\\java\\Spring%20Cloud%20%E9%BB%91%E9%A9%AC\\day02-SpringCloud02%E8%AE%B2%E4%B9%89\\assets\\image-20210714211908341.png?lastModify=1692268019\" alt=\"image-20210714211908341\"></p>\n<h3 id=\"5）网关路由的流程图\"><a href=\"#5）网关路由的流程图\" class=\"headerlink\" title=\"5）网关路由的流程图\"></a>5）网关路由的流程图</h3><p><strong>整个访问的流程如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2448446115.png\" alt=\"请输入图片描述\"></p>\n<p><strong>总结：</strong></p>\n<p><strong>网关搭建步骤：</strong></p>\n<ol>\n<li><strong>创建项目，引入 nacos 服务发现和 gateway 依赖</strong></li>\n<li><strong>配置 application.yml，包括服务基本信息、nacos 地址、路由</strong></li>\n</ol>\n<p><strong>路由配置包括：</strong></p>\n<ol>\n<li><strong>路由 id：路由的唯一标示</strong></li>\n<li><strong>路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡</strong></li>\n<li><strong>路由断言（predicates）：判断路由的规则，</strong></li>\n<li><strong>路由过滤器（filters）：对请求或响应做处理</strong></li>\n</ol>\n<p><strong>接下来，就重点来学习路由断言和路由过滤器的详细知识</strong></p>\n<h2 id=\"3-3-断言工厂\"><a href=\"#3-3-断言工厂\" class=\"headerlink\" title=\"3.3.断言工厂\"></a>3.3.断言工厂</h2><p><strong>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件</strong></p>\n<p>**例如 Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由**</p>\n<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p>\n<p><strong>处理的，像这样的断言工厂在 SpringCloudGateway 还有十几个:</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>示例</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>After</strong></td>\n<td><strong>是某个时间点后的请求</strong></td>\n<td><strong>- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</strong></td>\n</tr>\n<tr>\n<td><strong>Before</strong></td>\n<td><strong>是某个时间点之前的请求</strong></td>\n<td><strong>- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</strong></td>\n</tr>\n<tr>\n<td><strong>Between</strong></td>\n<td><strong>是某两个时间点之前的请求</strong></td>\n<td><strong>- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</strong></td>\n</tr>\n<tr>\n<td><strong>Cookie</strong></td>\n<td><strong>请求必须包含某些 cookie</strong></td>\n<td><strong>- Cookie&#x3D;chocolate, ch.p</strong></td>\n</tr>\n<tr>\n<td><strong>Header</strong></td>\n<td><strong>请求必须包含某些 header</strong></td>\n<td><strong>- Header&#x3D;X-Request-Id, \\d+</strong></td>\n</tr>\n<tr>\n<td><strong>Host</strong></td>\n<td><strong>请求必须是访问某个 host（域名）</strong></td>\n<td><strong>- Host&#x3D;**</strong>.somehost.org,**.anotherhost.org</td>\n</tr>\n<tr>\n<td><strong>Method</strong></td>\n<td><strong>请求方式必须是指定方式</strong></td>\n<td><strong>- Method&#x3D;GET,POST</strong></td>\n</tr>\n<tr>\n<td><strong>Path</strong></td>\n<td><strong>请求路径必须符合指定规则</strong></td>\n<td><strong>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</strong></td>\n</tr>\n<tr>\n<td><strong>Query</strong></td>\n<td><strong>请求参数必须包含指定参数</strong></td>\n<td><strong>- Query&#x3D;name, Jack 或者- Query&#x3D;name</strong></td>\n</tr>\n<tr>\n<td><strong>RemoteAddr</strong></td>\n<td><strong>请求者的 ip 必须是指定范围</strong></td>\n<td><strong>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</strong></td>\n</tr>\n<tr>\n<td><strong>Weight</strong></td>\n<td><strong>权重处理</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>我们只需要掌握 Path 这种路由工程就可以了。</strong></p>\n<h2 id=\"3-4-过滤器工厂\"><a href=\"#3-4-过滤器工厂\" class=\"headerlink\" title=\"3.4.过滤器工厂\"></a>3.4.过滤器工厂</h2><p><strong>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/739164028.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3-4-1-路由过滤器的种类\"><a href=\"#3-4-1-路由过滤器的种类\" class=\"headerlink\" title=\"3.4.1.路由过滤器的种类\"></a>3.4.1.路由过滤器的种类</h3><p><strong>Spring 提供了 31 种不同的路由过滤器工厂。例如：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>AddRequestHeader</strong></td>\n<td><strong>给当前请求添加一个请求头</strong></td>\n</tr>\n<tr>\n<td><strong>RemoveRequestHeader</strong></td>\n<td><strong>移除请求中的一个请求头</strong></td>\n</tr>\n<tr>\n<td><strong>AddResponseHeader</strong></td>\n<td><strong>给响应结果中添加一个响应头</strong></td>\n</tr>\n<tr>\n<td><strong>RemoveResponseHeader</strong></td>\n<td><strong>从响应结果中移除有一个响应头</strong></td>\n</tr>\n<tr>\n<td><strong>RequestRateLimiter</strong></td>\n<td><strong>限制请求的流量</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"3-4-2-请求头过滤器\"><a href=\"#3-4-2-请求头过滤器\" class=\"headerlink\" title=\"3.4.2.请求头过滤器\"></a>3.4.2.请求头过滤器</h3><p><strong>下面我们以 AddRequestHeader 为例来讲解。</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p></blockquote>\n<p><strong>只需要修改 gateway 服务的 application.yml 文件，添加路由过滤即可：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      routes:</span><br><span class=\"line\">      - id: user-service</span><br><span class=\"line\">        uri: lb://userservice</span><br><span class=\"line\">        predicates:</span><br><span class=\"line\">        - Path=/user/**</span><br><span class=\"line\">        filters: # 过滤器</span><br><span class=\"line\">        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头</span><br></pre></td></tr></table></figure>\n\n<p><strong>当前过滤器写在 userservice 路由下，因此仅仅对访问 userservice 的请求有效。</strong></p>\n<h3 id=\"3-4-3-默认过滤器\"><a href=\"#3-4-3-默认过滤器\" class=\"headerlink\" title=\"3.4.3.默认过滤器\"></a>3.4.3.默认过滤器</h3><p><strong>如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      routes:</span><br><span class=\"line\">      - id: user-service</span><br><span class=\"line\">        uri: lb://userservice</span><br><span class=\"line\">        predicates:</span><br><span class=\"line\">        - Path=/user/**</span><br><span class=\"line\">      default-filters: # 默认过滤项</span><br><span class=\"line\">      - AddRequestHeader=Truth, Itcast is freaking awesome!</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-4-总结\"><a href=\"#3-4-4-总结\" class=\"headerlink\" title=\"3.4.4.总结\"></a>3.4.4.总结</h3><p><strong>过滤器的作用是什么？</strong></p>\n<p><strong>① 对路由的请求或响应做加工处理，比如添加请求头</strong></p>\n<p><strong>② 配置在路由下的过滤器只对当前路由的请求生效</strong></p>\n<p><strong>defaultFilters 的作用是什么？</strong></p>\n<p><strong>① 对所有路由都生效的过滤器</strong></p>\n<h2 id=\"3-5-全局过滤器\"><a href=\"#3-5-全局过滤器\" class=\"headerlink\" title=\"3.5.全局过滤器\"></a>3.5.全局过滤器</h2><p><strong>上一节学习的过滤器，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</strong></p>\n<h3 id=\"3-5-1-全局过滤器作用\"><a href=\"#3-5-1-全局过滤器作用\" class=\"headerlink\" title=\"3.5.1.全局过滤器作用\"></a>3.5.1.全局过滤器作用</h3><p><strong>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GatewayFilter 通过配置定义，处理逻辑是固定的；而 GlobalFilter 的逻辑需要自己写代码实现。</strong></p>\n<p><strong>定义方式是实现 GlobalFilter 接口。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface GlobalFilter &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param exchange 请求上下文，里面可以获取Request、Response等信息</span><br><span class=\"line\">     * @param chain 用来把请求委托给下一个过滤器</span><br><span class=\"line\">     * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 filter 中编写自定义逻辑，可以实现下列功能：</strong></p>\n<ul>\n<li><strong>登录状态判断</strong></li>\n<li><strong>权限校验</strong></li>\n<li><strong>请求限流等</strong></li>\n</ul>\n<h3 id=\"3-5-2-自定义全局过滤器\"><a href=\"#3-5-2-自定义全局过滤器\" class=\"headerlink\" title=\"3.5.2.自定义全局过滤器\"></a>3.5.2.自定义全局过滤器</h3><p><strong>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</strong></p>\n<ul>\n<li><strong>参数中是否有 authorization，</strong></li>\n<li><strong>authorization 参数值是否为 admin</strong></li>\n</ul>\n<p><strong>如果同时满足则放行，否则拦截</strong></p>\n<p><strong>实现：</strong></p>\n<p><strong>在 gateway 中定义一个过滤器：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.gateway.filters;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class=\"line\">import org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class=\"line\">import org.springframework.core.annotation.Order;</span><br><span class=\"line\">import org.springframework.http.HttpStatus;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\">import org.springframework.web.server.ServerWebExchange;</span><br><span class=\"line\">import reactor.core.publisher.Mono;</span><br><span class=\"line\"></span><br><span class=\"line\">@Order(-1)</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class AuthorizeFilter implements GlobalFilter &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class=\"line\">        // 1.获取请求参数</span><br><span class=\"line\">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class=\"line\">        // 2.获取authorization参数</span><br><span class=\"line\">        String auth = params.getFirst(&quot;authorization&quot;);</span><br><span class=\"line\">        // 3.校验</span><br><span class=\"line\">        if (&quot;admin&quot;.equals(auth)) &#123;</span><br><span class=\"line\">            // 放行</span><br><span class=\"line\">            return chain.filter(exchange);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 4.拦截</span><br><span class=\"line\">        // 4.1.禁止访问，设置状态码</span><br><span class=\"line\">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class=\"line\">        // 4.2.结束处理</span><br><span class=\"line\">        return exchange.getResponse().setComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-3-过滤器执行顺序\"><a href=\"#3-5-3-过滤器执行顺序\" class=\"headerlink\" title=\"3.5.3.过滤器执行顺序\"></a>3.5.3.过滤器执行顺序</h3><p><strong>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</strong></p>\n<p><strong>请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3427199058.png\" alt=\"请输入图片描述\"></p>\n<p><strong>排序的规则是什么呢？</strong></p>\n<ul>\n<li>**每一个过滤器都必须指定一个 int 类型的 order 值，****order 值越小，优先级越高，执行顺序越靠前**。</li>\n<li><strong>GlobalFilter 通过实现 Ordered 接口，或者添加@Order 注解来指定 order 值，由我们自己指定</strong></li>\n<li><strong>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。</strong></li>\n<li><strong>当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li>\n</ul>\n<p><strong>详细内容，可以查看源码：</strong></p>\n<p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载 defaultFilters，然后再加载某个 route 的 filters，然后合并。</p>\n<p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据 order 排序，组织过滤器链</p>\n<h2 id=\"3-6-跨域问题\"><a href=\"#3-6-跨域问题\" class=\"headerlink\" title=\"3.6.跨域问题\"></a>3.6.跨域问题</h2><h3 id=\"3-6-1-什么是跨域问题\"><a href=\"#3-6-1-什么是跨域问题\" class=\"headerlink\" title=\"3.6.1.什么是跨域问题\"></a>3.6.1.什么是跨域问题</h3><p><strong>跨域：域名不一致就是跨域，主要包括：</strong></p>\n<ul>\n<li>**域名不同： **<a href=\"www.taobao.com\">www.taobao.com</a> 和 <a href=\"www.taobao.org\">www.taobao.org</a> 和 <a href=\"www.jd.com\">www.jd.com</a> 和 miaosha.jd.com</li>\n<li><strong>域名相同，端口不同：localhost:8080 和 localhost8081</strong></li>\n</ul>\n<p><strong>跨域问题：浏览器禁止请求的发起者与服务端发生跨域 ajax 请求，请求被浏览器拦截的问题</strong></p>\n<p><strong>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看</strong><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>\n<h3 id=\"3-6-2-模拟跨域问题\"><a href=\"#3-6-2-模拟跨域问题\" class=\"headerlink\" title=\"3.6.2.模拟跨域问题\"></a>3.6.2.模拟跨域问题</h3><p><strong>找到课前资料的页面文件：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3096885720.png\" alt=\"请输入图片描述\"></p>\n<p><strong>放入 tomcat 或者 nginx 这样的 web 服务器中，启动并访问。</strong></p>\n<p><strong>可以在浏览器控制台看到下面的错误：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2085549457.png\" alt=\"请输入图片描述\"></p>\n<p><strong>从 localhost:8090 访问 localhost:10010，端口不同，显然是跨域的请求。</strong></p>\n<h3 id=\"3-6-3-解决跨域问题\"><a href=\"#3-6-3-解决跨域问题\" class=\"headerlink\" title=\"3.6.3.解决跨域问题\"></a>3.6.3.解决跨域问题</h3><p><strong>在 gateway 服务的 application.yml 文件中，添加下面的配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      # 。。。</span><br><span class=\"line\">      globalcors: # 全局的跨域处理</span><br><span class=\"line\">        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题</span><br><span class=\"line\">        corsConfigurations:</span><br><span class=\"line\">          &#x27;[/**]&#x27;:</span><br><span class=\"line\">            allowedOrigins: # 允许哪些网站的跨域请求</span><br><span class=\"line\">              - &quot;http://localhost:8090&quot;</span><br><span class=\"line\">            allowedMethods: # 允许的跨域ajax的请求方式</span><br><span class=\"line\">              - &quot;GET&quot;</span><br><span class=\"line\">              - &quot;POST&quot;</span><br><span class=\"line\">              - &quot;DELETE&quot;</span><br><span class=\"line\">              - &quot;PUT&quot;</span><br><span class=\"line\">              - &quot;OPTIONS&quot;</span><br><span class=\"line\">            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息</span><br><span class=\"line\">            allowCredentials: true # 是否允许携带cookie</span><br><span class=\"line\">            maxAge: 360000 # 这次跨域检测的有效期</span><br></pre></td></tr></table></figure>\n","feature":true,"text":"SpringCloud 实用篇 020.学习目标1.Nacos 配置管理Nacos 除了可以做注册中心，同样可以做配置管理来使用。 1.1.统一配置管理当微服务...","permalink":"/post/SpringCloud使用篇02","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":2,"path":"api/tags/SpringCloud.json"},{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":1,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SpringCloud-%E5%AE%9E%E7%94%A8%E7%AF%87-02\"><span class=\"toc-text\">SpringCloud 实用篇 02</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">0.学习目标</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Nacos-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.Nacos 配置管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.1.统一配置管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E5%9C%A8-nacos-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">1.1.1.在 nacos 中添加配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E4%BB%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1.1.2.从微服务拉取配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">1.2.配置热更新</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-%E6%96%B9%E5%BC%8F%E4%B8%80\"><span class=\"toc-text\">1.2.1.方式一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E6%96%B9%E5%BC%8F%E4%BA%8C\"><span class=\"toc-text\">1.2.2.方式二</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">1.3.配置共享</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1）添加一个环境共享配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E5%9C%A8-user-service-%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">2）在 user-service 中读取共享配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E8%BF%90%E8%A1%8C%E4%B8%A4%E4%B8%AA-UserApplication%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84-profile\"><span class=\"toc-text\">3）运行两个 UserApplication，使用不同的 profile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">4）配置共享的优先级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E6%90%AD%E5%BB%BA-Nacos-%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">1.4.搭建 Nacos 集群</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Feign-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.Feign 远程调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-Feign-%E6%9B%BF%E4%BB%A3-RestTemplate\"><span class=\"toc-text\">2.1.Feign 替代 RestTemplate</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">2）添加注解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E7%BC%96%E5%86%99-Feign-%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">3）编写 Feign 的客户端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">4）测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5）总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">2.2.自定义配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.2.1.配置文件方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-Java-%E4%BB%A3%E7%A0%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.2.2.Java 代码方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-Feign-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2.3.Feign 使用优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">2.4.最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-1-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.4.1.继承方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-2-%E6%8A%BD%E5%8F%96%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.4.2.抽取方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-3-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%8A%BD%E5%8F%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">2.4.3.实现基于抽取的最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E6%8A%BD%E5%8F%96\"><span class=\"toc-text\">1）抽取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E5%9C%A8-order-service-%E4%B8%AD%E4%BD%BF%E7%94%A8-feign-api\"><span class=\"toc-text\">2）在 order-service 中使用 feign-api</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E9%87%8D%E5%90%AF%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">3）重启测试</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E8%A7%A3%E5%86%B3%E6%89%AB%E6%8F%8F%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4）解决扫描包问题</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Gateway-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3\"><span class=\"toc-text\">3.Gateway 服务网关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E5%85%B3\"><span class=\"toc-text\">3.1.为什么需要网关</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-gateway-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">3.2.gateway 快速入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%88%9B%E5%BB%BA-gateway-%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">1）创建 gateway 服务，引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E7%BC%96%E5%86%99%E5%90%AF%E5%8A%A8%E7%B1%BB\"><span class=\"toc-text\">2）编写启动类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%92%8C%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99\"><span class=\"toc-text\">3）编写基础配置和路由规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E9%87%8D%E5%90%AF%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">4）重启测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE\"><span class=\"toc-text\">5）网关路由的流程图</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">3.3.断言工厂</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">3.4.过滤器工厂</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-1-%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">3.4.1.路由过滤器的种类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-2-%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.4.2.请求头过滤器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-3-%E9%BB%98%E8%AE%A4%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.4.3.默认过滤器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-4-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">3.4.4.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.5.全局过滤器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-1-%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">3.5.1.全局过滤器作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.5.2.自定义全局过滤器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-3-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">3.5.3.过滤器执行顺序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.跨域问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.1.什么是跨域问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-2-%E6%A8%A1%E6%8B%9F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.2.模拟跨域问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-3-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.3.解决跨域问题</span></a></li></ol></li></ol></li></ol>","author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"SpringCloud 实用篇 01","uid":"eaa06ed45453f389a4efa6b3c6981c30","slug":"SpringCloud使用篇01","date":"2023-08-15T10:49:36.000Z","updated":"2023-12-28T07:02:41.554Z","comments":true,"path":"api/articles/SpringCloud使用篇01.json","keywords":null,"cover":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","text":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差...","permalink":"/post/SpringCloud使用篇01","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":2,"path":"api/tags/SpringCloud.json"}],"author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"feature":true},"next_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2023-12-27T08:45:00.000Z","updated":"2023-12-28T08:57:49.337Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":448,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}}}
=======
{"title":"SpringCloud 实用篇 02","uid":"6984a25a0e4d84e9bb902e845682c284","slug":"SpringCloud使用篇02","date":"2023-08-14T10:49:36.000Z","updated":"2023-12-28T07:02:50.223Z","comments":true,"path":"api/articles/SpringCloud使用篇02.json","keywords":null,"cover":[],"content":"<h1 id=\"SpringCloud-实用篇-02\"><a href=\"#SpringCloud-实用篇-02\" class=\"headerlink\" title=\"SpringCloud 实用篇 02\"></a>SpringCloud 实用篇 02</h1><h1 id=\"0-学习目标\"><a href=\"#0-学习目标\" class=\"headerlink\" title=\"0.学习目标\"></a>0.学习目标</h1><h1 id=\"1-Nacos-配置管理\"><a href=\"#1-Nacos-配置管理\" class=\"headerlink\" title=\"1.Nacos 配置管理\"></a>1.Nacos 配置管理</h1><p><strong>Nacos 除了可以做注册中心，同样可以做配置管理来使用。</strong></p>\n<h2 id=\"1-1-统一配置管理\"><a href=\"#1-1-统一配置管理\" class=\"headerlink\" title=\"1.1.统一配置管理\"></a>1.1.统一配置管理</h2><p><strong>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1125086243.png\" alt=\"请输入图片描述\"></p>\n<p><strong>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</strong></p>\n<h3 id=\"1-1-1-在-nacos-中添加配置文件\"><a href=\"#1-1-1-在-nacos-中添加配置文件\" class=\"headerlink\" title=\"1.1.1.在 nacos 中添加配置文件\"></a>1.1.1.在 nacos 中添加配置文件</h3><p><strong>如何在 nacos 中管理配置呢？</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2955026738.png\" alt=\"请输入图片描述\"></p>\n<p><strong>然后在弹出的表单中，填写配置信息：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/430074037.png\" alt=\"请输入图片描述\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</strong></p></blockquote>\n<h3 id=\"1-1-2-从微服务拉取配置\"><a href=\"#1-1-2-从微服务拉取配置\" class=\"headerlink\" title=\"1.1.2.从微服务拉取配置\"></a>1.1.2.从微服务拉取配置</h3><p><strong>微服务要拉取 nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。</strong></p>\n<p><strong>但如果尚未读取 application.yml，又如何得知 nacos 地址呢？</strong></p>\n<p><strong>因此 spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/506346522.png\" alt=\"请输入图片描述\"></p>\n<p><strong>1）引入 nacos-config 依赖</strong></p>\n<p><strong>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--nacos配置管理依赖--&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）添加 bootstrap.yaml</strong></p>\n<p><strong>然后，在 user-service 中添加一个 bootstrap.yaml 文件，内容如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: userservice # 服务名称</span><br><span class=\"line\">  profiles:</span><br><span class=\"line\">    active: dev #开发环境，这里是dev</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848 # Nacos地址</span><br><span class=\"line\">      config:</span><br><span class=\"line\">        file-extension: yaml # 文件后缀名</span><br></pre></td></tr></table></figure>\n\n<p><strong>这里会根据 spring.cloud.nacos.server-addr 获取 nacos 地址，再根据</strong></p>\n<p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件 id，来读取配置。</p>\n<p><strong>本例中，就是去读取</strong><code>userservice-dev.yaml</code>：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3048058808.png\" alt=\"请输入图片描述\"></p>\n<p><strong>3）读取 nacos 配置</strong></p>\n<p><strong>在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4099625314.png\" alt=\"请输入图片描述\"></p>\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.user.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import cn.itcast.user.pojo.User;</span><br><span class=\"line\">import cn.itcast.user.service.UserService;</span><br><span class=\"line\">import lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Value;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDateTime;</span><br><span class=\"line\">import java.time.format.DateTimeFormatter;</span><br><span class=\"line\"></span><br><span class=\"line\">@Slf4j</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/user&quot;)</span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br><span class=\"line\">    private String dateformat;</span><br><span class=\"line\">    </span><br><span class=\"line\">    @GetMapping(&quot;now&quot;)</span><br><span class=\"line\">    public String now()&#123;</span><br><span class=\"line\">        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // ...略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在页面访问，可以看到效果：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3759614107.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"1-2-配置热更新\"><a href=\"#1-2-配置热更新\" class=\"headerlink\" title=\"1.2.配置热更新\"></a>1.2.配置热更新</h2><p>**我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是****配置热更新**。</p>\n<p><strong>要实现配置热更新，可以使用两种方式：</strong></p>\n<h3 id=\"1-2-1-方式一\"><a href=\"#1-2-1-方式一\" class=\"headerlink\" title=\"1.2.1.方式一\"></a>1.2.1.方式一</h3><p><strong>在@Value 注入的变量所在类上添加注解@RefreshScope：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2124578473.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"1-2-2-方式二\"><a href=\"#1-2-2-方式二\" class=\"headerlink\" title=\"1.2.2.方式二\"></a>1.2.2.方式二</h3><p><strong>使用@ConfigurationProperties 注解代替@Value 注解。</strong></p>\n<p><strong>在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.user.config;</span><br><span class=\"line\"></span><br><span class=\"line\">import lombok.Data;</span><br><span class=\"line\">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component</span><br><span class=\"line\">@Data</span><br><span class=\"line\">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class=\"line\">public class PatternProperties &#123;</span><br><span class=\"line\">    private String dateformat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 UserController 中使用这个类代替@Value：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1790634262.png\" alt=\"请输入图片描述\"></p>\n<p><strong>完整代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.user.web;</span><br><span class=\"line\"></span><br><span class=\"line\">import cn.itcast.user.config.PatternProperties;</span><br><span class=\"line\">import cn.itcast.user.pojo.User;</span><br><span class=\"line\">import cn.itcast.user.service.UserService;</span><br><span class=\"line\">import lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDateTime;</span><br><span class=\"line\">import java.time.format.DateTimeFormatter;</span><br><span class=\"line\"></span><br><span class=\"line\">@Slf4j</span><br><span class=\"line\">@RestController</span><br><span class=\"line\">@RequestMapping(&quot;/user&quot;)</span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PatternProperties patternProperties;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(&quot;now&quot;)</span><br><span class=\"line\">    public String now()&#123;</span><br><span class=\"line\">        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-配置共享\"><a href=\"#1-3-配置共享\" class=\"headerlink\" title=\"1.3.配置共享\"></a>1.3.配置共享</h2><p><strong>其实微服务启动时，会去 nacos 读取多个配置文件，例如：</strong></p>\n<ul>\n<li><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</li>\n<li><code>[spring.application.name].yaml</code>，例如：userservice.yaml</li>\n</ul>\n<p><strong>而</strong><code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p>\n<p><strong>下面我们通过案例来测试配置共享</strong></p>\n<h3 id=\"1）添加一个环境共享配置\"><a href=\"#1）添加一个环境共享配置\" class=\"headerlink\" title=\"1）添加一个环境共享配置\"></a>1）添加一个环境共享配置</h3><p><strong>我们在 nacos 中添加一个 userservice.yaml 文件：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4255474564.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"2）在-user-service-中读取共享配置\"><a href=\"#2）在-user-service-中读取共享配置\" class=\"headerlink\" title=\"2）在 user-service 中读取共享配置\"></a>2）在 user-service 中读取共享配置</h3><p><strong>在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1527405082.png\" alt=\"请输入图片描述\"></p>\n<p><strong>在 user-service 服务中，修改 UserController，添加一个方法：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2758212015.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3）运行两个-UserApplication，使用不同的-profile\"><a href=\"#3）运行两个-UserApplication，使用不同的-profile\" class=\"headerlink\" title=\"3）运行两个 UserApplication，使用不同的 profile\"></a>3）运行两个 UserApplication，使用不同的 profile</h3><p><strong>修改 UserApplication2 这个启动项，改变其 profile 值：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/399072175.png\" alt=\"请输入图片描述\"></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3251838110.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这样，UserApplication(8081)使用的 profile 是 dev，UserApplication2(8082)使用的 profile 是 test。</strong></p>\n<p><strong>启动 UserApplication 和 UserApplication2</strong></p>\n<p><strong>访问</strong><a href=\"http://localhost:8081/user/prop\">http://localhost:8081/user/prop</a>，结果：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1153437790.png\" alt=\"请输入图片描述\"></p>\n<p><strong>访问</strong><a href=\"http://localhost:8082/user/prop\">http://localhost:8082/user/prop</a>，结果：</p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1274812329.png\" alt=\"请输入图片描述\"></p>\n<p><strong>可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。</strong></p>\n<h3 id=\"4）配置共享的优先级\"><a href=\"#4）配置共享的优先级\" class=\"headerlink\" title=\"4）配置共享的优先级\"></a>4）配置共享的优先级</h3><p><strong>当 nacos、服务本地同时出现相同属性时，优先级有高低之分：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2896504755.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"1-4-搭建-Nacos-集群\"><a href=\"#1-4-搭建-Nacos-集群\" class=\"headerlink\" title=\"1.4.搭建 Nacos 集群\"></a>1.4.搭建 Nacos 集群</h2><p><strong>Nacos 生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3913142232.png\" alt=\"请输入图片描述\"></p>\n<h1 id=\"2-Feign-远程调用\"><a href=\"#2-Feign-远程调用\" class=\"headerlink\" title=\"2.Feign 远程调用\"></a>2.Feign 远程调用</h1><p><strong>先来看我们以前利用 RestTemplate 发起远程调用的代码：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4205281578.png\" alt=\"请输入图片描述\"></p>\n<p><strong>存在下面的问题：</strong></p>\n<p><strong>•代码可读性差，编程体验不统一</strong></p>\n<p><strong>•参数复杂 URL 难以维护</strong></p>\n<p><strong>Feign 是一个声明式的 http 客户端，官方地址：</strong><a href=\"https://github.com/OpenFeign/feign\">https://github.com/OpenFeign/feign</a></p>\n<p><strong>其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1629857719.png\" alt=\"请输入图片描述\"></p>\n<h2 id=\"2-1-Feign-替代-RestTemplate\"><a href=\"#2-1-Feign-替代-RestTemplate\" class=\"headerlink\" title=\"2.1.Feign 替代 RestTemplate\"></a>2.1.Feign 替代 RestTemplate</h2><p><strong>Fegin 的使用步骤如下：</strong></p>\n<h3 id=\"1）引入依赖\"><a href=\"#1）引入依赖\" class=\"headerlink\" title=\"1）引入依赖\"></a>1）引入依赖</h3><p><strong>我们在 order-service 服务的 pom 文件中引入 feign 的依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）添加注解\"><a href=\"#2）添加注解\" class=\"headerlink\" title=\"2）添加注解\"></a>2）添加注解</h3><p><strong>在 order-service 的启动类添加注解开启 Feign 的功能：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1193055115.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3）编写-Feign-的客户端\"><a href=\"#3）编写-Feign-的客户端\" class=\"headerlink\" title=\"3）编写 Feign 的客户端\"></a>3）编写 Feign 的客户端</h3><p><strong>在 order-service 中新建一个接口，内容如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.order.client;</span><br><span class=\"line\"></span><br><span class=\"line\">import cn.itcast.order.pojo.User;</span><br><span class=\"line\">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class=\"line\"></span><br><span class=\"line\">@FeignClient(&quot;userservice&quot;)</span><br><span class=\"line\">public interface UserClient &#123;</span><br><span class=\"line\">    @GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class=\"line\">    User findById(@PathVariable(&quot;id&quot;) Long id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：</strong></p>\n<ul>\n<li><strong>服务名称：userservice</strong></li>\n<li><strong>请求方式：GET</strong></li>\n<li><strong>请求路径：&#x2F;user&#x2F;{id}</strong></li>\n<li><strong>请求参数：Long id</strong></li>\n<li><strong>返回值类型：User</strong></li>\n</ul>\n<p><strong>这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</strong></p>\n<h3 id=\"4）测试\"><a href=\"#4）测试\" class=\"headerlink\" title=\"4）测试\"></a>4）测试</h3><p><strong>修改 order-service 中的 OrderService 类中的 queryOrderById 方法，使用 Feign 客户端代替 RestTemplate：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1980193915.png\" alt=\"请输入图片描述\"></p>\n<p><strong>是不是看起来优雅多了。</strong></p>\n<h3 id=\"5）总结\"><a href=\"#5）总结\" class=\"headerlink\" title=\"5）总结\"></a>5）总结</h3><p><strong>使用 Feign 的步骤：</strong></p>\n<p><strong>① 引入依赖</strong></p>\n<p><strong>② 添加@EnableFeignClients 注解</strong></p>\n<p><strong>③ 编写 FeignClient 接口</strong></p>\n<p><strong>④ 使用 FeignClient 中定义的方法代替 RestTemplate</strong></p>\n<h2 id=\"2-2-自定义配置\"><a href=\"#2-2-自定义配置\" class=\"headerlink\" title=\"2.2.自定义配置\"></a>2.2.自定义配置</h2><p><strong>Feign 可以支持很多的自定义配置，如下表所示：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>类型</strong></th>\n<th><strong>作用</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>feign.Logger.Level</strong></td>\n<td><strong>修改日志级别</strong></td>\n<td><strong>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</strong></td>\n</tr>\n<tr>\n<td><strong>feign.codec.Decoder</strong></td>\n<td><strong>响应结果的解析器</strong></td>\n<td><strong>http 远程调用的结果做解析，例如解析 json 字符串为 java 对象</strong></td>\n</tr>\n<tr>\n<td><strong>feign.codec.Encoder</strong></td>\n<td><strong>请求参数编码</strong></td>\n<td><strong>将请求参数编码，便于通过 http 请求发送</strong></td>\n</tr>\n<tr>\n<td><strong>feign. Contract</strong></td>\n<td><strong>支持的注解格式</strong></td>\n<td><strong>默认是 SpringMVC 的注解</strong></td>\n</tr>\n<tr>\n<td><strong>feign. Retryer</strong></td>\n<td><strong>失败重试机制</strong></td>\n<td><strong>请求失败的重试机制，默认是没有，不过会使用 Ribbon 的重试</strong></td>\n</tr>\n</tbody></table>\n<p><strong>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean 覆盖默认 Bean 即可。</strong></p>\n<p><strong>下面以日志为例来演示如何自定义配置。</strong></p>\n<h3 id=\"2-2-1-配置文件方式\"><a href=\"#2-2-1-配置文件方式\" class=\"headerlink\" title=\"2.2.1.配置文件方式\"></a>2.2.1.配置文件方式</h3><p><strong>基于配置文件修改 feign 的日志级别可以针对单个服务：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign:  </span><br><span class=\"line\">  client:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      userservice: # 针对某个微服务的配置</span><br><span class=\"line\">        loggerLevel: FULL #  日志级别</span><br></pre></td></tr></table></figure>\n\n<p><strong>也可以针对所有服务：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign:  </span><br><span class=\"line\">  client:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span><br><span class=\"line\">        loggerLevel: FULL #  日志级别</span><br></pre></td></tr></table></figure>\n\n<p><strong>而日志的级别分为四种：</strong></p>\n<ul>\n<li><strong>NONE：不记录任何日志信息，这是默认值。</strong></li>\n<li><strong>BASIC：仅记录请求的方法，URL 以及响应状态码和执行时间</strong></li>\n<li><strong>HEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息</strong></li>\n<li><strong>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</strong></li>\n</ul>\n<h3 id=\"2-2-2-Java-代码方式\"><a href=\"#2-2-2-Java-代码方式\" class=\"headerlink\" title=\"2.2.2.Java 代码方式\"></a>2.2.2.Java 代码方式</h3><p><strong>也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DefaultFeignConfiguration  &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    public Logger.Level feignLogLevel()&#123;</span><br><span class=\"line\">        return Logger.Level.BASIC; // 日志级别为BASIC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>**如果要****全局生效**，将其放到启动类的@EnableFeignClients 这个注解中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span><br></pre></td></tr></table></figure>\n\n<p>**如果是****局部生效**，则把它放到对应的@FeignClient 这个注解中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Feign-使用优化\"><a href=\"#2-3-Feign-使用优化\" class=\"headerlink\" title=\"2.3.Feign 使用优化\"></a>2.3.Feign 使用优化</h2><p><strong>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：</strong></p>\n<p><strong>•URLConnection：默认实现，不支持连接池</strong></p>\n<p><strong>•Apache HttpClient ：支持连接池</strong></p>\n<p><strong>•OKHttp：支持连接池</strong></p>\n<p>**因此提高 Feign 的性能主要手段就是使用****连接池**代替默认的 URLConnection。</p>\n<p><strong>这里我们用 Apache 的 HttpClient 来演示。</strong></p>\n<p><strong>1）引入依赖</strong></p>\n<p><strong>在 order-service 的 pom 文件中引入 Apache 的 HttpClient 依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--httpClient的依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）配置连接池</strong></p>\n<p><strong>在 order-service 的 application.yml 中添加配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign:</span><br><span class=\"line\">  client:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      default: # default全局的配置</span><br><span class=\"line\">        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息</span><br><span class=\"line\">  httpclient:</span><br><span class=\"line\">    enabled: true # 开启feign对HttpClient的支持</span><br><span class=\"line\">    max-connections: 200 # 最大的连接数</span><br><span class=\"line\">    max-connections-per-route: 50 # 每个路径的最大连接数</span><br></pre></td></tr></table></figure>\n\n<p><strong>接下来，在 FeignClientFactoryBean 中的 loadBalance 方法中打断点：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3416768888.png\" alt=\"请输入图片描述\"></p>\n<p><strong>Debug 方式启动 order-service 服务，可以看到这里的 client，底层就是 Apache HttpClient：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3071575752.png\" alt=\"请输入图片描述\"></p>\n<p><strong>总结，Feign 的优化：</strong></p>\n<p><strong>1.日志级别尽量用 basic</strong></p>\n<p><strong>2.使用 HttpClient 或 OKHttp 代替 URLConnection</strong></p>\n<p><strong>① 引入 feign-httpClient 依赖</strong></p>\n<p><strong>② 配置文件开启 httpClient 功能，设置连接池参数</strong></p>\n<h2 id=\"2-4-最佳实践\"><a href=\"#2-4-最佳实践\" class=\"headerlink\" title=\"2.4.最佳实践\"></a>2.4.最佳实践</h2><p><strong>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</strong></p>\n<p><strong>自习观察可以发现，Feign 的客户端与服务提供者的 controller 代码非常相似：</strong></p>\n<p><strong>feign 客户端：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3052501456.png\" alt=\"请输入图片描述\"></p>\n<p><strong>UserController：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4011192970.png\" alt=\"请输入图片描述\"></p>\n<p><strong>有没有一种办法简化这种重复的代码编写呢？</strong></p>\n<h3 id=\"2-4-1-继承方式\"><a href=\"#2-4-1-继承方式\" class=\"headerlink\" title=\"2.4.1.继承方式\"></a>2.4.1.继承方式</h3><p><strong>一样的代码可以通过继承来共享：</strong></p>\n<p><strong>1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明。</strong></p>\n<p><strong>2）Feign 客户端和 Controller 都集成改接口</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3750477059.png\" alt=\"请输入图片描述\"></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>简单</strong></li>\n<li><strong>实现了代码共享</strong></li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>服务提供方、服务消费方紧耦合</strong></li>\n<li><strong>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</strong></li>\n</ul>\n<h3 id=\"2-4-2-抽取方式\"><a href=\"#2-4-2-抽取方式\" class=\"headerlink\" title=\"2.4.2.抽取方式\"></a>2.4.2.抽取方式</h3><p><strong>将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</strong></p>\n<p><strong>例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4056594834.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"2-4-3-实现基于抽取的最佳实践\"><a href=\"#2-4-3-实现基于抽取的最佳实践\" class=\"headerlink\" title=\"2.4.3.实现基于抽取的最佳实践\"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id=\"1）抽取\"><a href=\"#1）抽取\" class=\"headerlink\" title=\"1）抽取\"></a>1）抽取</h4><p><strong>首先创建一个 module，命名为 feign-api：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/1640147792.png\" alt=\"请输入图片描述\"></p>\n<p><strong>项目结构：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/4187903423.png\" alt=\"请输入图片描述\"></p>\n<p><strong>在 feign-api 中然后引入 feign 的 starter 依赖</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>然后，order-service 中编写的 UserClient、User、DefaultFeignConfiguration 都复制到 feign-api 项目中</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/962664599.png\" alt=\"请输入图片描述\"></p>\n<h4 id=\"2）在-order-service-中使用-feign-api\"><a href=\"#2）在-order-service-中使用-feign-api\" class=\"headerlink\" title=\"2）在 order-service 中使用 feign-api\"></a>2）在 order-service 中使用 feign-api</h4><p><strong>首先，删除 order-service 中的 UserClient、User、DefaultFeignConfiguration 等类或接口。</strong></p>\n<p><strong>在 order-service 的 pom 文件中中引入 feign-api 的依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;feign-api&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>修改 order-service 中的所有与上述三个组件有关的导包部分，改成导入 feign-api 中的包</strong></p>\n<h4 id=\"3）重启测试\"><a href=\"#3）重启测试\" class=\"headerlink\" title=\"3）重启测试\"></a>3）重启测试</h4><p><strong>重启后，发现服务报错了：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/316459633.png\" alt=\"请输入图片描述\"></p>\n<p><strong>这是因为 UserClient 现在在 cn.itcast.feign.clients 包下，</strong></p>\n<p><strong>而 order-service 的@EnableFeignClients 注解是在 cn.itcast.order 包下，不在同一个包，无法扫描到 UserClient。</strong></p>\n<h4 id=\"4）解决扫描包问题\"><a href=\"#4）解决扫描包问题\" class=\"headerlink\" title=\"4）解决扫描包问题\"></a>4）解决扫描包问题</h4><p><strong>方式一：</strong></p>\n<p><strong>指定 Feign 应该扫描的包：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>方式二：</strong></p>\n<p><strong>指定需要加载的 Client 接口：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-Gateway-服务网关\"><a href=\"#3-Gateway-服务网关\" class=\"headerlink\" title=\"3.Gateway 服务网关\"></a>3.Gateway 服务网关</h1><p><strong>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</strong></p>\n<h2 id=\"3-1-为什么需要网关\"><a href=\"#3-1-为什么需要网关\" class=\"headerlink\" title=\"3.1.为什么需要网关\"></a>3.1.为什么需要网关</h2><p><strong>Gateway 网关是我们服务的守门神，所有微服务的统一入口。</strong></p>\n<p>**网关的****核心功能特性**：</p>\n<ul>\n<li><strong>请求路由</strong></li>\n<li><strong>权限控制</strong></li>\n<li><strong>限流</strong></li>\n</ul>\n<p><strong>架构图：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2908797109.png\" alt=\"请输入图片描述\"></p>\n<p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>\n<p><strong>路由和负载均衡</strong>：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>\n<p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>\n<p><strong>在 SpringCloud 中网关的实现包括两种：</strong></p>\n<ul>\n<li><strong>gateway</strong></li>\n<li><strong>zuul</strong></li>\n</ul>\n<p><strong>Zuul 是基于 Servlet 的实现，属于阻塞式编程。而 SpringCloudGateway 则是基于 Spring5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。</strong></p>\n<h2 id=\"3-2-gateway-快速入门\"><a href=\"#3-2-gateway-快速入门\" class=\"headerlink\" title=\"3.2.gateway 快速入门\"></a>3.2.gateway 快速入门</h2><p><strong>下面，我们就演示下网关的基本路由功能。基本步骤如下：</strong></p>\n<ol>\n<li><strong>创建 SpringBoot 工程 gateway，引入网关依赖</strong></li>\n<li><strong>编写启动类</strong></li>\n<li><strong>编写基础配置和路由规则</strong></li>\n<li><strong>启动网关服务进行测试</strong></li>\n</ol>\n<h3 id=\"1）创建-gateway-服务，引入依赖\"><a href=\"#1）创建-gateway-服务，引入依赖\" class=\"headerlink\" title=\"1）创建 gateway 服务，引入依赖\"></a>1）创建 gateway 服务，引入依赖</h3><p><strong>创建服务：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3715852231.png\" alt=\"请输入图片描述\"></p>\n<p><strong>引入依赖：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--网关--&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;!--nacos服务发现依赖--&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）编写启动类\"><a href=\"#2）编写启动类\" class=\"headerlink\" title=\"2）编写启动类\"></a>2）编写启动类</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.gateway;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.boot.SpringApplication;</span><br><span class=\"line\">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"></span><br><span class=\"line\">@SpringBootApplication</span><br><span class=\"line\">public class GatewayApplication &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">SpringApplication.run(GatewayApplication.class, args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3）编写基础配置和路由规则\"><a href=\"#3）编写基础配置和路由规则\" class=\"headerlink\" title=\"3）编写基础配置和路由规则\"></a>3）编写基础配置和路由规则</h3><p><strong>创建 application.yml 文件，内容如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: 10010 # 网关端口</span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: gateway # 服务名称</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    nacos:</span><br><span class=\"line\">      server-addr: localhost:8848 # nacos地址</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      routes: # 网关路由配置</span><br><span class=\"line\">        - id: user-service # 路由id，自定义，只要唯一即可</span><br><span class=\"line\">          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span><br><span class=\"line\">          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span><br><span class=\"line\">          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件</span><br><span class=\"line\">            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求</span><br></pre></td></tr></table></figure>\n\n<p><strong>我们将符合</strong><code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p>\n<p>**本例中，我们将 **<code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb 是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p>\n<h3 id=\"4）重启测试\"><a href=\"#4）重启测试\" class=\"headerlink\" title=\"4）重启测试\"></a>4）重启测试</h3><p><strong>重启网关，访问</strong><a href=\"http://localhost:10010/user/1\">http://localhost:10010/user/1</a>时，符合<code>/user/**</code>规则，请求转发到 uri：<a href=\"http://userservice/user/1\">http://userservice/user/1</a>，得到了结果：</p>\n<p><img src=\"file://D:\\study\\java\\Spring%20Cloud%20%E9%BB%91%E9%A9%AC\\day02-SpringCloud02%E8%AE%B2%E4%B9%89\\assets\\image-20210714211908341.png?lastModify=1692268019\" alt=\"image-20210714211908341\"></p>\n<h3 id=\"5）网关路由的流程图\"><a href=\"#5）网关路由的流程图\" class=\"headerlink\" title=\"5）网关路由的流程图\"></a>5）网关路由的流程图</h3><p><strong>整个访问的流程如下：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2448446115.png\" alt=\"请输入图片描述\"></p>\n<p><strong>总结：</strong></p>\n<p><strong>网关搭建步骤：</strong></p>\n<ol>\n<li><strong>创建项目，引入 nacos 服务发现和 gateway 依赖</strong></li>\n<li><strong>配置 application.yml，包括服务基本信息、nacos 地址、路由</strong></li>\n</ol>\n<p><strong>路由配置包括：</strong></p>\n<ol>\n<li><strong>路由 id：路由的唯一标示</strong></li>\n<li><strong>路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡</strong></li>\n<li><strong>路由断言（predicates）：判断路由的规则，</strong></li>\n<li><strong>路由过滤器（filters）：对请求或响应做处理</strong></li>\n</ol>\n<p><strong>接下来，就重点来学习路由断言和路由过滤器的详细知识</strong></p>\n<h2 id=\"3-3-断言工厂\"><a href=\"#3-3-断言工厂\" class=\"headerlink\" title=\"3.3.断言工厂\"></a>3.3.断言工厂</h2><p><strong>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件</strong></p>\n<p>**例如 Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由**</p>\n<p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p>\n<p><strong>处理的，像这样的断言工厂在 SpringCloudGateway 还有十几个:</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>说明</strong></th>\n<th><strong>示例</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>After</strong></td>\n<td><strong>是某个时间点后的请求</strong></td>\n<td><strong>- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</strong></td>\n</tr>\n<tr>\n<td><strong>Before</strong></td>\n<td><strong>是某个时间点之前的请求</strong></td>\n<td><strong>- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</strong></td>\n</tr>\n<tr>\n<td><strong>Between</strong></td>\n<td><strong>是某两个时间点之前的请求</strong></td>\n<td><strong>- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</strong></td>\n</tr>\n<tr>\n<td><strong>Cookie</strong></td>\n<td><strong>请求必须包含某些 cookie</strong></td>\n<td><strong>- Cookie&#x3D;chocolate, ch.p</strong></td>\n</tr>\n<tr>\n<td><strong>Header</strong></td>\n<td><strong>请求必须包含某些 header</strong></td>\n<td><strong>- Header&#x3D;X-Request-Id, \\d+</strong></td>\n</tr>\n<tr>\n<td><strong>Host</strong></td>\n<td><strong>请求必须是访问某个 host（域名）</strong></td>\n<td><strong>- Host&#x3D;**</strong>.somehost.org,**.anotherhost.org</td>\n</tr>\n<tr>\n<td><strong>Method</strong></td>\n<td><strong>请求方式必须是指定方式</strong></td>\n<td><strong>- Method&#x3D;GET,POST</strong></td>\n</tr>\n<tr>\n<td><strong>Path</strong></td>\n<td><strong>请求路径必须符合指定规则</strong></td>\n<td><strong>- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</strong></td>\n</tr>\n<tr>\n<td><strong>Query</strong></td>\n<td><strong>请求参数必须包含指定参数</strong></td>\n<td><strong>- Query&#x3D;name, Jack 或者- Query&#x3D;name</strong></td>\n</tr>\n<tr>\n<td><strong>RemoteAddr</strong></td>\n<td><strong>请求者的 ip 必须是指定范围</strong></td>\n<td><strong>- RemoteAddr&#x3D;192.168.1.1&#x2F;24</strong></td>\n</tr>\n<tr>\n<td><strong>Weight</strong></td>\n<td><strong>权重处理</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>我们只需要掌握 Path 这种路由工程就可以了。</strong></p>\n<h2 id=\"3-4-过滤器工厂\"><a href=\"#3-4-过滤器工厂\" class=\"headerlink\" title=\"3.4.过滤器工厂\"></a>3.4.过滤器工厂</h2><p><strong>GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/739164028.png\" alt=\"请输入图片描述\"></p>\n<h3 id=\"3-4-1-路由过滤器的种类\"><a href=\"#3-4-1-路由过滤器的种类\" class=\"headerlink\" title=\"3.4.1.路由过滤器的种类\"></a>3.4.1.路由过滤器的种类</h3><p><strong>Spring 提供了 31 种不同的路由过滤器工厂。例如：</strong></p>\n<table>\n<thead>\n<tr>\n<th><strong>名称</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>AddRequestHeader</strong></td>\n<td><strong>给当前请求添加一个请求头</strong></td>\n</tr>\n<tr>\n<td><strong>RemoveRequestHeader</strong></td>\n<td><strong>移除请求中的一个请求头</strong></td>\n</tr>\n<tr>\n<td><strong>AddResponseHeader</strong></td>\n<td><strong>给响应结果中添加一个响应头</strong></td>\n</tr>\n<tr>\n<td><strong>RemoveResponseHeader</strong></td>\n<td><strong>从响应结果中移除有一个响应头</strong></td>\n</tr>\n<tr>\n<td><strong>RequestRateLimiter</strong></td>\n<td><strong>限制请求的流量</strong></td>\n</tr>\n</tbody></table>\n<h3 id=\"3-4-2-请求头过滤器\"><a href=\"#3-4-2-请求头过滤器\" class=\"headerlink\" title=\"3.4.2.请求头过滤器\"></a>3.4.2.请求头过滤器</h3><p><strong>下面我们以 AddRequestHeader 为例来讲解。</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>需求</strong>：给所有进入 userservice 的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!</p></blockquote>\n<p><strong>只需要修改 gateway 服务的 application.yml 文件，添加路由过滤即可：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      routes:</span><br><span class=\"line\">      - id: user-service</span><br><span class=\"line\">        uri: lb://userservice</span><br><span class=\"line\">        predicates:</span><br><span class=\"line\">        - Path=/user/**</span><br><span class=\"line\">        filters: # 过滤器</span><br><span class=\"line\">        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头</span><br></pre></td></tr></table></figure>\n\n<p><strong>当前过滤器写在 userservice 路由下，因此仅仅对访问 userservice 的请求有效。</strong></p>\n<h3 id=\"3-4-3-默认过滤器\"><a href=\"#3-4-3-默认过滤器\" class=\"headerlink\" title=\"3.4.3.默认过滤器\"></a>3.4.3.默认过滤器</h3><p><strong>如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      routes:</span><br><span class=\"line\">      - id: user-service</span><br><span class=\"line\">        uri: lb://userservice</span><br><span class=\"line\">        predicates:</span><br><span class=\"line\">        - Path=/user/**</span><br><span class=\"line\">      default-filters: # 默认过滤项</span><br><span class=\"line\">      - AddRequestHeader=Truth, Itcast is freaking awesome!</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-4-总结\"><a href=\"#3-4-4-总结\" class=\"headerlink\" title=\"3.4.4.总结\"></a>3.4.4.总结</h3><p><strong>过滤器的作用是什么？</strong></p>\n<p><strong>① 对路由的请求或响应做加工处理，比如添加请求头</strong></p>\n<p><strong>② 配置在路由下的过滤器只对当前路由的请求生效</strong></p>\n<p><strong>defaultFilters 的作用是什么？</strong></p>\n<p><strong>① 对所有路由都生效的过滤器</strong></p>\n<h2 id=\"3-5-全局过滤器\"><a href=\"#3-5-全局过滤器\" class=\"headerlink\" title=\"3.5.全局过滤器\"></a>3.5.全局过滤器</h2><p><strong>上一节学习的过滤器，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</strong></p>\n<h3 id=\"3-5-1-全局过滤器作用\"><a href=\"#3-5-1-全局过滤器作用\" class=\"headerlink\" title=\"3.5.1.全局过滤器作用\"></a>3.5.1.全局过滤器作用</h3><p><strong>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GatewayFilter 通过配置定义，处理逻辑是固定的；而 GlobalFilter 的逻辑需要自己写代码实现。</strong></p>\n<p><strong>定义方式是实现 GlobalFilter 接口。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface GlobalFilter &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param exchange 请求上下文，里面可以获取Request、Response等信息</span><br><span class=\"line\">     * @param chain 用来把请求委托给下一个过滤器</span><br><span class=\"line\">     * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span><br><span class=\"line\">     */</span><br><span class=\"line\">    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 filter 中编写自定义逻辑，可以实现下列功能：</strong></p>\n<ul>\n<li><strong>登录状态判断</strong></li>\n<li><strong>权限校验</strong></li>\n<li><strong>请求限流等</strong></li>\n</ul>\n<h3 id=\"3-5-2-自定义全局过滤器\"><a href=\"#3-5-2-自定义全局过滤器\" class=\"headerlink\" title=\"3.5.2.自定义全局过滤器\"></a>3.5.2.自定义全局过滤器</h3><p><strong>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</strong></p>\n<ul>\n<li><strong>参数中是否有 authorization，</strong></li>\n<li><strong>authorization 参数值是否为 admin</strong></li>\n</ul>\n<p><strong>如果同时满足则放行，否则拦截</strong></p>\n<p><strong>实现：</strong></p>\n<p><strong>在 gateway 中定义一个过滤器：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package cn.itcast.gateway.filters;</span><br><span class=\"line\"></span><br><span class=\"line\">import org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class=\"line\">import org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class=\"line\">import org.springframework.core.annotation.Order;</span><br><span class=\"line\">import org.springframework.http.HttpStatus;</span><br><span class=\"line\">import org.springframework.stereotype.Component;</span><br><span class=\"line\">import org.springframework.web.server.ServerWebExchange;</span><br><span class=\"line\">import reactor.core.publisher.Mono;</span><br><span class=\"line\"></span><br><span class=\"line\">@Order(-1)</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class AuthorizeFilter implements GlobalFilter &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class=\"line\">        // 1.获取请求参数</span><br><span class=\"line\">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class=\"line\">        // 2.获取authorization参数</span><br><span class=\"line\">        String auth = params.getFirst(&quot;authorization&quot;);</span><br><span class=\"line\">        // 3.校验</span><br><span class=\"line\">        if (&quot;admin&quot;.equals(auth)) &#123;</span><br><span class=\"line\">            // 放行</span><br><span class=\"line\">            return chain.filter(exchange);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 4.拦截</span><br><span class=\"line\">        // 4.1.禁止访问，设置状态码</span><br><span class=\"line\">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class=\"line\">        // 4.2.结束处理</span><br><span class=\"line\">        return exchange.getResponse().setComplete();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-3-过滤器执行顺序\"><a href=\"#3-5-3-过滤器执行顺序\" class=\"headerlink\" title=\"3.5.3.过滤器执行顺序\"></a>3.5.3.过滤器执行顺序</h3><p><strong>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</strong></p>\n<p><strong>请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3427199058.png\" alt=\"请输入图片描述\"></p>\n<p><strong>排序的规则是什么呢？</strong></p>\n<ul>\n<li>**每一个过滤器都必须指定一个 int 类型的 order 值，****order 值越小，优先级越高，执行顺序越靠前**。</li>\n<li><strong>GlobalFilter 通过实现 Ordered 接口，或者添加@Order 注解来指定 order 值，由我们自己指定</strong></li>\n<li><strong>路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。</strong></li>\n<li><strong>当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。</strong></li>\n</ul>\n<p><strong>详细内容，可以查看源码：</strong></p>\n<p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载 defaultFilters，然后再加载某个 route 的 filters，然后合并。</p>\n<p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据 order 排序，组织过滤器链</p>\n<h2 id=\"3-6-跨域问题\"><a href=\"#3-6-跨域问题\" class=\"headerlink\" title=\"3.6.跨域问题\"></a>3.6.跨域问题</h2><h3 id=\"3-6-1-什么是跨域问题\"><a href=\"#3-6-1-什么是跨域问题\" class=\"headerlink\" title=\"3.6.1.什么是跨域问题\"></a>3.6.1.什么是跨域问题</h3><p><strong>跨域：域名不一致就是跨域，主要包括：</strong></p>\n<ul>\n<li>**域名不同： **<a href=\"www.taobao.com\">www.taobao.com</a> 和 <a href=\"www.taobao.org\">www.taobao.org</a> 和 <a href=\"www.jd.com\">www.jd.com</a> 和 miaosha.jd.com</li>\n<li><strong>域名相同，端口不同：localhost:8080 和 localhost8081</strong></li>\n</ul>\n<p><strong>跨域问题：浏览器禁止请求的发起者与服务端发生跨域 ajax 请求，请求被浏览器拦截的问题</strong></p>\n<p><strong>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看</strong><a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>\n<h3 id=\"3-6-2-模拟跨域问题\"><a href=\"#3-6-2-模拟跨域问题\" class=\"headerlink\" title=\"3.6.2.模拟跨域问题\"></a>3.6.2.模拟跨域问题</h3><p><strong>找到课前资料的页面文件：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/3096885720.png\" alt=\"请输入图片描述\"></p>\n<p><strong>放入 tomcat 或者 nginx 这样的 web 服务器中，启动并访问。</strong></p>\n<p><strong>可以在浏览器控制台看到下面的错误：</strong></p>\n<p><img src=\"http://www.52uni.cn/usr/uploads/2023/08/2085549457.png\" alt=\"请输入图片描述\"></p>\n<p><strong>从 localhost:8090 访问 localhost:10010，端口不同，显然是跨域的请求。</strong></p>\n<h3 id=\"3-6-3-解决跨域问题\"><a href=\"#3-6-3-解决跨域问题\" class=\"headerlink\" title=\"3.6.3.解决跨域问题\"></a>3.6.3.解决跨域问题</h3><p><strong>在 gateway 服务的 application.yml 文件中，添加下面的配置：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  cloud:</span><br><span class=\"line\">    gateway:</span><br><span class=\"line\">      # 。。。</span><br><span class=\"line\">      globalcors: # 全局的跨域处理</span><br><span class=\"line\">        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题</span><br><span class=\"line\">        corsConfigurations:</span><br><span class=\"line\">          &#x27;[/**]&#x27;:</span><br><span class=\"line\">            allowedOrigins: # 允许哪些网站的跨域请求</span><br><span class=\"line\">              - &quot;http://localhost:8090&quot;</span><br><span class=\"line\">            allowedMethods: # 允许的跨域ajax的请求方式</span><br><span class=\"line\">              - &quot;GET&quot;</span><br><span class=\"line\">              - &quot;POST&quot;</span><br><span class=\"line\">              - &quot;DELETE&quot;</span><br><span class=\"line\">              - &quot;PUT&quot;</span><br><span class=\"line\">              - &quot;OPTIONS&quot;</span><br><span class=\"line\">            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息</span><br><span class=\"line\">            allowCredentials: true # 是否允许携带cookie</span><br><span class=\"line\">            maxAge: 360000 # 这次跨域检测的有效期</span><br></pre></td></tr></table></figure>\n","feature":true,"text":"SpringCloud 实用篇 020.学习目标1.Nacos 配置管理Nacos 除了可以做注册中心，同样可以做配置管理来使用。 1.1.统一配置管理当微服务...","permalink":"/post/SpringCloud使用篇02","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[{"name":"Java","slug":"Java","count":3,"path":"api/categories/Java.json"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","count":2,"path":"api/tags/SpringCloud.json"},{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"},{"name":"Spring","slug":"Spring","count":1,"path":"api/tags/Spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SpringCloud-%E5%AE%9E%E7%94%A8%E7%AF%87-02\"><span class=\"toc-text\">SpringCloud 实用篇 02</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#0-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87\"><span class=\"toc-text\">0.学习目标</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-Nacos-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.Nacos 配置管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.1.统一配置管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E5%9C%A8-nacos-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">1.1.1.在 nacos 中添加配置文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E4%BB%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1.1.2.从微服务拉取配置</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">1.2.配置热更新</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-%E6%96%B9%E5%BC%8F%E4%B8%80\"><span class=\"toc-text\">1.2.1.方式一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E6%96%B9%E5%BC%8F%E4%BA%8C\"><span class=\"toc-text\">1.2.2.方式二</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB\"><span class=\"toc-text\">1.3.配置共享</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%8E%AF%E5%A2%83%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">1）添加一个环境共享配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E5%9C%A8-user-service-%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%85%B1%E4%BA%AB%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">2）在 user-service 中读取共享配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E8%BF%90%E8%A1%8C%E4%B8%A4%E4%B8%AA-UserApplication%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84-profile\"><span class=\"toc-text\">3）运行两个 UserApplication，使用不同的 profile</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E9%85%8D%E7%BD%AE%E5%85%B1%E4%BA%AB%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7\"><span class=\"toc-text\">4）配置共享的优先级</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-%E6%90%AD%E5%BB%BA-Nacos-%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">1.4.搭建 Nacos 集群</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Feign-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">2.Feign 远程调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-1-Feign-%E6%9B%BF%E4%BB%A3-RestTemplate\"><span class=\"toc-text\">2.1.Feign 替代 RestTemplate</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">1）引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">2）添加注解</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E7%BC%96%E5%86%99-Feign-%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">3）编写 Feign 的客户端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">4）测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">5）总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">2.2.自定义配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.2.1.配置文件方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-2-Java-%E4%BB%A3%E7%A0%81%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.2.2.Java 代码方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-3-Feign-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2.3.Feign 使用优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-4-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">2.4.最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-1-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.4.1.继承方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-2-%E6%8A%BD%E5%8F%96%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">2.4.2.抽取方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-3-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%8A%BD%E5%8F%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">2.4.3.实现基于抽取的最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E6%8A%BD%E5%8F%96\"><span class=\"toc-text\">1）抽取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E5%9C%A8-order-service-%E4%B8%AD%E4%BD%BF%E7%94%A8-feign-api\"><span class=\"toc-text\">2）在 order-service 中使用 feign-api</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E9%87%8D%E5%90%AF%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">3）重启测试</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E8%A7%A3%E5%86%B3%E6%89%AB%E6%8F%8F%E5%8C%85%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4）解决扫描包问题</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-Gateway-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3\"><span class=\"toc-text\">3.Gateway 服务网关</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BD%91%E5%85%B3\"><span class=\"toc-text\">3.1.为什么需要网关</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-2-gateway-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">3.2.gateway 快速入门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%EF%BC%89%E5%88%9B%E5%BB%BA-gateway-%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96\"><span class=\"toc-text\">1）创建 gateway 服务，引入依赖</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%EF%BC%89%E7%BC%96%E5%86%99%E5%90%AF%E5%8A%A8%E7%B1%BB\"><span class=\"toc-text\">2）编写启动类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%EF%BC%89%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%92%8C%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99\"><span class=\"toc-text\">3）编写基础配置和路由规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%EF%BC%89%E9%87%8D%E5%90%AF%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">4）重启测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%EF%BC%89%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE\"><span class=\"toc-text\">5）网关路由的流程图</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-3-%E6%96%AD%E8%A8%80%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">3.3.断言工厂</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-4-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82\"><span class=\"toc-text\">3.4.过滤器工厂</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-1-%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB\"><span class=\"toc-text\">3.4.1.路由过滤器的种类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-2-%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.4.2.请求头过滤器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-3-%E9%BB%98%E8%AE%A4%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.4.3.默认过滤器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-4-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">3.4.4.总结</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-5-%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.5.全局过滤器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-1-%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">3.5.1.全局过滤器作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8\"><span class=\"toc-text\">3.5.2.自定义全局过滤器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-3-%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">3.5.3.过滤器执行顺序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-6-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.跨域问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.1.什么是跨域问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-2-%E6%A8%A1%E6%8B%9F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.2.模拟跨域问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-6-3-%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.6.3.解决跨域问题</span></a></li></ol></li></ol></li></ol>","author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2023-12-27T08:45:00.000Z","updated":"2023-12-28T08:57:49.337Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":448,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"正茂","slug":"blog-author","avatar":"https://q2.qlogo.cn/g?b=qq&nk=749054429&s=100","link":"/","description":"Do Nothing By Halves","socials":{"github":"https://github.com/52uni","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{}}}},"next_post":{}}
>>>>>>> 9eb1465 (second)
