<<<<<<< HEAD
[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nhello erveryoneCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-12-27T08:45:00.000Z","categories_index":"","tags_index":"","author_index":"正茂"},{"id":"df2bd4a3cae38597aabb2824e73aaab3","title":"每日新闻60s","content":"\n","slug":"60s","date":"2023-08-25T10:49:36.000Z","categories_index":"实用","tags_index":"新闻","author_index":"正茂"},{"id":"eaa06ed45453f389a4efa6b3c6981c30","title":"SpringCloud 实用篇 01","content":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？\n1.0.学习目标了解微服务架构的优缺点\n1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。\n\n单体架构的优缺点如下：\n优点：\n\n架构简单\n部署成本低\n\n缺点：\n\n耦合度高（维护困难、升级困难）\n\n1.2.分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。\n\n分布式架构的优缺点：\n优点：\n\n降低服务耦合\n有利于服务升级和拓展\n\n缺点：\n\n服务调用关系错综复杂\n\n分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：\n\n服务拆分的粒度如何界定？\n服务之间如何调用？\n服务的调用关系如何管理？\n\n人们需要制定一套行之有效的标准来约束分布式架构。\n1.3.微服务微服务的架构特征：\n\n单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责\n自治：团队独立、技术独立、数据独立，独立部署和交付\n面向服务：服务提供统一标准的接口，与语言和技术无关\n隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n\n微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。\n因此，可以认为****微服务是一种经过良好架构设计的分布式架构方案 。\n但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。\n其中在Java领域最引人注目的就是SpringCloud提供的方案了。\n1.4.SpringCloudSpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。\nSpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。\n其中常见的组件包括：\n\n另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：\n\n我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。\n1.5.总结\n单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统\n分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝\n微服务：一种良好的分布式架构方案①优点：拆分粒度更小、服务更独立、耦合度更低②缺点：架构非常复杂，运维、监控、部署难度提高\nSpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件\n\n2.服务拆分和远程调用任何分布式架构都离不开服务的拆分，微服务也是一样。\n2.1.服务拆分原则这里我总结了微服务拆分时的几个原则：\n\n不同微服务，不要重复开发相同业务\n微服务数据独立，不要访问其它微服务的数据库\n微服务可以将自己的业务暴露为接口，供其它微服务调用\n\n\n2.2.服务拆分示例以课前资料中的微服务cloud-demo为例，其结构如下：\n\ncloud-demo：父工程，管理依赖\n\norder-service：订单微服务，负责订单相关业务\nuser-service：用户微服务，负责用户相关业务\n\n要求：\n\n订单微服务和用户微服务都必须有各自的数据库，相互独立\n订单服务和用户服务都对外暴露Restful的接口\n订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库\n\n2.2.1.导入Sql语句首先，将课前资料提供的cloud-order.sql和cloud-user.sql导入到mysql中：\n\ncloud-user表中初始数据如下：\n\ncloud-order表中初始数据如下：\n\ncloud-order表中持有cloud-user表中的id字段。\n2.2.2.导入demo工程用IDEA导入课前资料提供的Demo：\n\n项目结构如下：\n\n导入后，会在IDEA右下角出现弹窗：\n\n点击弹窗，然后按下图选择：\n\n会出现这样的菜单：\n\n配置下项目使用的JDK：\n\n2.3.实现远程调用案例在order-service服务中，有一个根据id查询订单的接口：\n\n根据id查询订单，返回值是Order对象，如图：\n\n其中的user为null\n在user-service中有一个根据id查询用户的接口：\n\n查询的结果如图：\n\n2.3.1.案例需求：修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。\n因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。\n大概的步骤是这样的：\n\n注册一个RestTemplate的实例到Spring容器\n修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User\n将查询的User填充到Order对象，一起返回\n\n2.3.2.注册RestTemplate首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：\n123456789101112131415161718192021package cn.itcast.order;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderApplication.class, args);    &#125;    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;\n\n2.3.3.实现远程调用修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：\n\n2.4.提供者与消费者在服务调用关系中，会有两个不同的角色：\n服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）\n服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）\n\n但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。\n如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？\n\n对于A调用B的业务而言：A是服务消费者，B是服务提供者\n对于B调用C的业务而言：B是服务消费者，C是服务提供者\n\n因此，服务B既可以是服务提供者，也可以是服务消费者。\n3.Eureka注册中心假如我们的服务提供者user-service部署了多个实例，如图：\n\n大家思考几个问题：\n\norder-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？\n有多个user-service实例地址，order-service调用时该如何选择？\norder-service如何得知某个user-service实例是否依然健康，是不是已经宕机？\n\n3.1.Eureka的结构和作用这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：\n\n回答之前的各个问题。\n问题1：order-service如何得知user-service实例地址？\n获取地址信息的流程如下：\n\nuser-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册\neureka-server保存服务名称到服务实例地址列表的映射关系\norder-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取\n\n问题2：order-service如何从多个user-service实例中选择具体的实例？\n\norder-service从实例列表中利用负载均衡算法选中一个实例地址\n向该实例地址发起远程调用\n\n问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？\n\nuser-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳\n当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除\norder-service拉取服务时，就能将故障实例排除了\n\n\n\n\n\n\n\n\n\n\n注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端\n因此，接下来我们动手实践的步骤包括：\n\n3.2.搭建eureka-server首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务\n3.2.1.创建eureka-server服务在cloud-demo父工程下，创建一个子模块：\n\n填写模块信息：\n\n然后填写服务信息：\n\n3.2.2.引入eureka依赖引入SpringCloud为eureka提供的starter依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;\n\n3.2.3.编写启动类给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：\n12345678910111213package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaApplication.class, args);    &#125;&#125;\n\n3.2.4.编写配置文件编写一个application.yml文件，内容如下：\n123456789server:  port: 10086spring:  application:    name: eureka-servereureka:  client:    service-url:       defaultZone: http://127.0.0.1:10086/eureka\n\n3.2.5.启动服务启动微服务，然后在浏览器访问：http://127.0.0.1:10086\n看到下面结果应该是成功了：\n\n3.3.服务注册下面，我们将user-service注册到eureka-server中去。\n1）引入依赖在user-service的pom文件中，引入下面的eureka-client依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）配置文件在user-service中，修改application.yml文件，添加服务名称、eureka地址：\n1234567spring:  application:    name: userserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka\n\n3）启动多个user-service实例为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。\n首先，复制原来的user-service启动配置：\n\n然后，在弹出的窗口中，填写信息：\n\n现在，SpringBoot窗口会出现两个user-service启动配置：\n\n不过，第一个是8081端口，第二个是8082端口。\n启动两个user-service实例：\n\n查看eureka-server管理页面：\n\n3.4.服务发现下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。\n1）引入依赖之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。\n在order-service的pom文件中，引入下面的eureka-client依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）配置文件服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：\n在order-service中，修改application.yml文件，添加服务名称、eureka地址：\n1234567spring:  application:    name: orderserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka\n\n3）服务拉取和负载均衡最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。\n不过这些动作不用我们去做，只需要添加一些注解即可。\n在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：\n\n修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：\n\nspring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。\n4.Ribbon负载均衡上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？\n4.1.负载均衡原理SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。\n\n那么我们发出的请求明明是http://userservice/user/1，怎么变成了http://localhost:8081的呢？\n4.2.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。\n显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。\n我们进行源码跟踪：\n1）LoadBalancerIntercepor\n可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：\n\nrequest.getURI()：获取请求uri，本例中就是 http://user-service/user/8\noriginalUri.getHost()：获取uri路径的主机名，其实就是服务id，user-service\nthis.loadBalancer.execute()：处理服务id，和用户请求。\n\n这里的this.loadBalancer是LoadBalancerClient类型，我们继续跟入。\n2）LoadBalancerClient继续跟入execute方法：\n\n代码是这样的：\n\ngetLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。\ngetServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务\n\n放行后，再次访问并跟踪，发现获取的是8081：\n\n果然实现了负载均衡。\n3）负载均衡策略IRule在刚才的代码中，可以看到获取服务使通过一个getServer方法来做负载均衡:\n!\n我们继续跟入：\n\n继续跟踪源码chooseServer方法，发现这么一段代码：\n\n我们看看这个rule是谁：\n\n这里的rule默认值是一个RoundRobinRule，看类的介绍：\n\n这不就是轮询的意思嘛。\n到这里，整个负载均衡的流程我们就清楚了。\n4）总结SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：\n\n基本流程如下：\n\n拦截我们的RestTemplate请求http://userservice/user/1\nRibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service\nDynamicServerListLoadBalancer根据user-service到eureka拉取服务列表\neureka返回列表，localhost:8081、localhost:8082\nIRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081\nRibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求\n\n4.3.负载均衡策略4.3.1.负载均衡策略负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：\n\n不同规则的含义如下：\n\n\n\n内置负载均衡规则类\n规则描述\n\n\n\nRoundRobinRule\n简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。\n\n\nAvailabilityFilteringRule\n对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。\n\n\nWeightedResponseTimeRule\n为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。\n\n\nZoneAvoidanceRule\n以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。\n\n\nBestAvailableRule\n忽略那些短路的服务器，并选择并发数较低的服务器。\n\n\nRandomRule\n随机选择一个可用的服务器。\n\n\nRetryRule\n重试机制的选择逻辑\n\n\n默认的实现就是ZoneAvoidanceRule，是一种轮询方案\n4.3.2.自定义负载均衡策略通过定义IRule实现可以修改负载均衡规则，有两种方式：\n\n代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：\n\n1234@Beanpublic IRule randomRule()&#123;    return new RandomRule();&#125;\n\n\n配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：\n\n123userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 \n\n\n\n\n\n\n\n\n\n\n注意，一般用默认的负载均衡规则，不做修改。\n4.4.饥饿加载Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。\n而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：\n1234ribbon:  eager-load:    enabled: true    clients: userservice\n\n5.Nacos注册中心国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。\n5.1.认识和安装NacosNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。\n\n安装方式可以参考课前资料《Nacos安装指南.md》\n5.2.服务注册到nacosNacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。\n主要差异在于：\n\n依赖不同\n服务地址不同\n\n1）引入依赖在cloud-demo父工程的pom文件中的&lt;dependencyManagement&gt;中引入SpringCloudAlibaba的依赖：\n1234567&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;\n\n然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n\n\n\n\n\n\n\n注意：不要忘了注释掉eureka的依赖。\n2）配置nacos地址在user-service和order-service的application.yml中添加nacos地址：\n1234spring:  cloud:    nacos:      server-addr: localhost:8848\n\n\n\n\n\n\n\n\n\n\n注意：不要忘了注释掉eureka的地址\n3）重启重启微服务后，登录nacos管理页面，可以看到微服务信息：\n\n5.3.服务分级存储模型一个****服务可以有多个实例，例如我们的user-service，可以有:\n\n127.0.0.1:8081\n127.0.0.1:8082\n127.0.0.1:8083\n\n假如这些实例分布于全国各地的不同机房，例如：\n\n127.0.0.1:8081，在上海机房\n127.0.0.1:8082，在上海机房\n127.0.0.1:8083，在杭州机房\n\nNacos就将同一机房内的实例 划分为一个****集群。\n也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：\n\n微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：\n\n杭州机房内的order-service应该优先访问同机房的user-service。\n5.3.1.给user-service配置集群修改user-service的application.yml文件，添加集群配置：\n123456spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称\n\n重启两个user-service实例后，我们可以在nacos控制台看到下面结果：\n\n我们再次复制一个user-service启动配置，添加属性：\n1-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH\n\n配置如图所示：\n\n启动UserApplication3后再次查看nacos控制台：\n\n5.3.2.同集群优先的负载均衡默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡。\n因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例。\n1）给order-service配置集群信息\n修改order-service的application.yml文件，添加集群配置：\n123456spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称\n\n2）修改负载均衡规则\n修改order-service的application.yml文件，修改负载均衡规则：\n123userservice:  ribbon:    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 \n\n5.4.权重配置实际部署中会出现这样的场景：\n服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。\n但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。\n因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。\n在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：\n\n在弹出的编辑窗口，修改权重：\n\n\n\n\n\n\n\n\n\n\n注意：如果权重修改为0，则该实例永远不会被访问\n5.5.环境隔离Nacos提供了namespace来实现环境隔离功能。\n\nnacos中可以有多个namespace\nnamespace下可以有group、service等\n不同namespace之间相互隔离，例如不同namespace的服务互相不可见\n\n\n5.5.1.创建namespace默认情况下，所有service、data、group都在同一个namespace，名为public：\n\n我们可以点击页面新增按钮，添加一个namespace：\n\n然后，填写表单：\n\n就能在页面看到一个新的namespace：\n\n5.5.2.给微服务配置namespace给微服务配置namespace只能通过修改配置来实现。\n例如，修改order-service的application.yml文件：\n1234567spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID\n\n重启order-service后，访问控制台，可以看到下面的结果：\n\n\n此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：\n\n5.6.Nacos与Eureka的区别Nacos的服务实例分为两种l类型：\n\n临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。\n非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。\n\n配置一个服务实例为永久实例：\n12345spring:  cloud:    nacos:      discovery:        ephemeral: false # 设置为非临时实例\n\nNacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：\n\n\nNacos与eureka的共同点\n都支持服务注册和服务拉取\n都支持服务提供者心跳方式做健康检测\n\n\nNacos与Eureka的区别\nNacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式\n临时实例心跳不正常会被剔除，非临时实例则不会被剔除\nNacos支持服务列表变更的消息推送模式，服务列表更新更及时\nNacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式\n\n\n\n","slug":"SpringCloud使用篇01","date":"2023-08-15T10:49:36.000Z","categories_index":"Java","tags_index":"SpringCloud","author_index":"正茂"},{"id":"6984a25a0e4d84e9bb902e845682c284","title":"SpringCloud 实用篇 02","content":"SpringCloud 实用篇 020.学习目标1.Nacos 配置管理Nacos 除了可以做注册中心，同样可以做配置管理来使用。\n1.1.统一配置管理当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。\n\nNacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。\n1.1.1.在 nacos 中添加配置文件如何在 nacos 中管理配置呢？\n\n然后在弹出的表单中，填写配置信息：\n\n\n\n\n\n\n\n\n\n\n注意：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。\n1.1.2.从微服务拉取配置微服务要拉取 nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。\n但如果尚未读取 application.yml，又如何得知 nacos 地址呢？\n因此 spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：\n\n1）引入 nacos-config 依赖\n首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：\n12345&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）添加 bootstrap.yaml\n然后，在 user-service 中添加一个 bootstrap.yaml 文件，内容如下：\n12345678910spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev  cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yaml # 文件后缀名\n\n这里会根据 spring.cloud.nacos.server-addr 获取 nacos 地址，再根据\n$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;作为文件 id，来读取配置。\n本例中，就是去读取userservice-dev.yaml：\n\n3）读取 nacos 配置\n在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置：\n\n完整代码：\n1234567891011121314151617181920212223242526272829package cn.itcast.user.web;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @Autowired    private UserService userService;    @Value(&quot;$&#123;pattern.dateformat&#125;&quot;)    private String dateformat;        @GetMapping(&quot;now&quot;)    public String now()&#123;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));    &#125;    // ...略&#125;\n\n在页面访问，可以看到效果：\n\n1.2.配置热更新**我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是****配置热更新**。\n要实现配置热更新，可以使用两种方式：\n1.2.1.方式一在@Value 注入的变量所在类上添加注解@RefreshScope：\n\n1.2.2.方式二使用@ConfigurationProperties 注解代替@Value 注解。\n在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：\n123456789101112package cn.itcast.user.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix = &quot;pattern&quot;)public class PatternProperties &#123;    private String dateformat;&#125;\n\n在 UserController 中使用这个类代替@Value：\n\n完整代码：\n123456789101112131415161718192021222324252627282930313233package cn.itcast.user.web;import cn.itcast.user.config.PatternProperties;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @Autowired    private UserService userService;    @Autowired    private PatternProperties patternProperties;    @GetMapping(&quot;now&quot;)    public String now()&#123;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));    &#125;    // 略&#125;\n\n1.3.配置共享其实微服务启动时，会去 nacos 读取多个配置文件，例如：\n\n[spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml\n[spring.application.name].yaml，例如：userservice.yaml\n\n而[spring.application.name].yaml不包含环境，因此可以被多个环境共享。\n下面我们通过案例来测试配置共享\n1）添加一个环境共享配置我们在 nacos 中添加一个 userservice.yaml 文件：\n\n2）在 user-service 中读取共享配置在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：\n\n在 user-service 服务中，修改 UserController，添加一个方法：\n\n3）运行两个 UserApplication，使用不同的 profile修改 UserApplication2 这个启动项，改变其 profile 值：\n\n\n这样，UserApplication(8081)使用的 profile 是 dev，UserApplication2(8082)使用的 profile 是 test。\n启动 UserApplication 和 UserApplication2\n访问http://localhost:8081/user/prop，结果：\n\n访问http://localhost:8082/user/prop，结果：\n\n可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。\n4）配置共享的优先级当 nacos、服务本地同时出现相同属性时，优先级有高低之分：\n\n1.4.搭建 Nacos 集群Nacos 生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：\n\n2.Feign 远程调用先来看我们以前利用 RestTemplate 发起远程调用的代码：\n\n存在下面的问题：\n•代码可读性差，编程体验不统一\n•参数复杂 URL 难以维护\nFeign 是一个声明式的 http 客户端，官方地址：https://github.com/OpenFeign/feign\n其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。\n\n2.1.Feign 替代 RestTemplateFegin 的使用步骤如下：\n1）引入依赖我们在 order-service 服务的 pom 文件中引入 feign 的依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）添加注解在 order-service 的启动类添加注解开启 Feign 的功能：\n\n3）编写 Feign 的客户端在 order-service 中新建一个接口，内容如下：\n123456789101112package cn.itcast.order.client;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(&quot;userservice&quot;)public interface UserClient &#123;    @GetMapping(&quot;/user/&#123;id&#125;&quot;)    User findById(@PathVariable(&quot;id&quot;) Long id);&#125;\n\n这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：\n\n服务名称：userservice\n请求方式：GET\n请求路径：&#x2F;user&#x2F;{id}\n请求参数：Long id\n返回值类型：User\n\n这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。\n4）测试修改 order-service 中的 OrderService 类中的 queryOrderById 方法，使用 Feign 客户端代替 RestTemplate：\n\n是不是看起来优雅多了。\n5）总结使用 Feign 的步骤：\n① 引入依赖\n② 添加@EnableFeignClients 注解\n③ 编写 FeignClient 接口\n④ 使用 FeignClient 中定义的方法代替 RestTemplate\n2.2.自定义配置Feign 可以支持很多的自定义配置，如下表所示：\n\n\n\n类型\n作用\n说明\n\n\n\nfeign.Logger.Level\n修改日志级别\n包含四种不同的级别：NONE、BASIC、HEADERS、FULL\n\n\nfeign.codec.Decoder\n响应结果的解析器\nhttp 远程调用的结果做解析，例如解析 json 字符串为 java 对象\n\n\nfeign.codec.Encoder\n请求参数编码\n将请求参数编码，便于通过 http 请求发送\n\n\nfeign. Contract\n支持的注解格式\n默认是 SpringMVC 的注解\n\n\nfeign. Retryer\n失败重试机制\n请求失败的重试机制，默认是没有，不过会使用 Ribbon 的重试\n\n\n一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean 覆盖默认 Bean 即可。\n下面以日志为例来演示如何自定义配置。\n2.2.1.配置文件方式基于配置文件修改 feign 的日志级别可以针对单个服务：\n12345feign:    client:    config:      userservice: # 针对某个微服务的配置        loggerLevel: FULL #  日志级别\n\n也可以针对所有服务：\n12345feign:    client:    config:      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置        loggerLevel: FULL #  日志级别\n\n而日志的级别分为四种：\n\nNONE：不记录任何日志信息，这是默认值。\nBASIC：仅记录请求的方法，URL 以及响应状态码和执行时间\nHEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息\nFULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。\n\n2.2.2.Java 代码方式也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象：\n123456public class DefaultFeignConfiguration  &#123;    @Bean    public Logger.Level feignLogLevel()&#123;        return Logger.Level.BASIC; // 日志级别为BASIC    &#125;&#125;\n\n**如果要****全局生效**，将其放到启动类的@EnableFeignClients 这个注解中：\n1@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)\n\n**如果是****局部生效**，则把它放到对应的@FeignClient 这个注解中：\n1@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)\n\n2.3.Feign 使用优化Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：\n•URLConnection：默认实现，不支持连接池\n•Apache HttpClient ：支持连接池\n•OKHttp：支持连接池\n**因此提高 Feign 的性能主要手段就是使用****连接池**代替默认的 URLConnection。\n这里我们用 Apache 的 HttpClient 来演示。\n1）引入依赖\n在 order-service 的 pom 文件中引入 Apache 的 HttpClient 依赖：\n12345&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）配置连接池\n在 order-service 的 application.yml 中添加配置：\n123456789feign:  client:    config:      default: # default全局的配置        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息  httpclient:    enabled: true # 开启feign对HttpClient的支持    max-connections: 200 # 最大的连接数    max-connections-per-route: 50 # 每个路径的最大连接数\n\n接下来，在 FeignClientFactoryBean 中的 loadBalance 方法中打断点：\n\nDebug 方式启动 order-service 服务，可以看到这里的 client，底层就是 Apache HttpClient：\n\n总结，Feign 的优化：\n1.日志级别尽量用 basic\n2.使用 HttpClient 或 OKHttp 代替 URLConnection\n① 引入 feign-httpClient 依赖\n② 配置文件开启 httpClient 功能，设置连接池参数\n2.4.最佳实践所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。\n自习观察可以发现，Feign 的客户端与服务提供者的 controller 代码非常相似：\nfeign 客户端：\n\nUserController：\n\n有没有一种办法简化这种重复的代码编写呢？\n2.4.1.继承方式一样的代码可以通过继承来共享：\n1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明。\n2）Feign 客户端和 Controller 都集成改接口\n\n优点：\n\n简单\n实现了代码共享\n\n缺点：\n\n服务提供方、服务消费方紧耦合\n参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解\n\n2.4.2.抽取方式将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。\n例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。\n\n2.4.3.实现基于抽取的最佳实践1）抽取首先创建一个 module，命名为 feign-api：\n\n项目结构：\n\n在 feign-api 中然后引入 feign 的 starter 依赖\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n\n然后，order-service 中编写的 UserClient、User、DefaultFeignConfiguration 都复制到 feign-api 项目中\n\n2）在 order-service 中使用 feign-api首先，删除 order-service 中的 UserClient、User、DefaultFeignConfiguration 等类或接口。\n在 order-service 的 pom 文件中中引入 feign-api 的依赖：\n12345&lt;dependency&gt;    &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt;    &lt;artifactId&gt;feign-api&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;\n\n修改 order-service 中的所有与上述三个组件有关的导包部分，改成导入 feign-api 中的包\n3）重启测试重启后，发现服务报错了：\n\n这是因为 UserClient 现在在 cn.itcast.feign.clients 包下，\n而 order-service 的@EnableFeignClients 注解是在 cn.itcast.order 包下，不在同一个包，无法扫描到 UserClient。\n4）解决扫描包问题方式一：\n指定 Feign 应该扫描的包：\n1@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)\n\n方式二：\n指定需要加载的 Client 接口：\n1@EnableFeignClients(clients = &#123;UserClient.class&#125;)\n\n3.Gateway 服务网关Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。\n3.1.为什么需要网关Gateway 网关是我们服务的守门神，所有微服务的统一入口。\n**网关的****核心功能特性**：\n\n请求路由\n权限控制\n限流\n\n架构图：\n\n权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。\n路由和负载均衡：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。\n限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。\n在 SpringCloud 中网关的实现包括两种：\n\ngateway\nzuul\n\nZuul 是基于 Servlet 的实现，属于阻塞式编程。而 SpringCloudGateway 则是基于 Spring5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。\n3.2.gateway 快速入门下面，我们就演示下网关的基本路由功能。基本步骤如下：\n\n创建 SpringBoot 工程 gateway，引入网关依赖\n编写启动类\n编写基础配置和路由规则\n启动网关服务进行测试\n\n1）创建 gateway 服务，引入依赖创建服务：\n\n引入依赖：\n12345678910&lt;!--网关--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）编写启动类123456789101112package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(GatewayApplication.class, args);&#125;&#125;\n\n3）编写基础配置和路由规则创建 application.yml 文件，内容如下：\n123456789101112131415server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求\n\n我们将符合Path 规则的一切请求，都代理到 uri参数指定的地址。\n**本例中，我们将 **/user/**开头的请求，代理到lb://userservice，lb 是负载均衡，根据服务名拉取服务列表，实现负载均衡。\n4）重启测试重启网关，访问http://localhost:10010/user/1时，符合/user/**规则，请求转发到 uri：http://userservice/user/1，得到了结果：\n\n5）网关路由的流程图整个访问的流程如下：\n\n总结：\n网关搭建步骤：\n\n创建项目，引入 nacos 服务发现和 gateway 依赖\n配置 application.yml，包括服务基本信息、nacos 地址、路由\n\n路由配置包括：\n\n路由 id：路由的唯一标示\n路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡\n路由断言（predicates）：判断路由的规则，\n路由过滤器（filters）：对请求或响应做处理\n\n接下来，就重点来学习路由断言和路由过滤器的详细知识\n3.3.断言工厂我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件\n**例如 Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由**\norg.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来\n处理的，像这样的断言工厂在 SpringCloudGateway 还有十几个:\n\n\n\n名称\n说明\n示例\n\n\n\nAfter\n是某个时间点后的请求\n- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nBefore\n是某个时间点之前的请求\n- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]\n\n\nBetween\n是某两个时间点之前的请求\n- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nCookie\n请求必须包含某些 cookie\n- Cookie&#x3D;chocolate, ch.p\n\n\nHeader\n请求必须包含某些 header\n- Header&#x3D;X-Request-Id, \\d+\n\n\nHost\n请求必须是访问某个 host（域名）\n- Host&#x3D;**.somehost.org,**.anotherhost.org\n\n\nMethod\n请求方式必须是指定方式\n- Method&#x3D;GET,POST\n\n\nPath\n请求路径必须符合指定规则\n- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**\n\n\nQuery\n请求参数必须包含指定参数\n- Query&#x3D;name, Jack 或者- Query&#x3D;name\n\n\nRemoteAddr\n请求者的 ip 必须是指定范围\n- RemoteAddr&#x3D;192.168.1.1&#x2F;24\n\n\nWeight\n权重处理\n\n\n\n我们只需要掌握 Path 这种路由工程就可以了。\n3.4.过滤器工厂GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：\n\n3.4.1.路由过滤器的种类Spring 提供了 31 种不同的路由过滤器工厂。例如：\n\n\n\n名称\n说明\n\n\n\nAddRequestHeader\n给当前请求添加一个请求头\n\n\nRemoveRequestHeader\n移除请求中的一个请求头\n\n\nAddResponseHeader\n给响应结果中添加一个响应头\n\n\nRemoveResponseHeader\n从响应结果中移除有一个响应头\n\n\nRequestRateLimiter\n限制请求的流量\n\n\n3.4.2.请求头过滤器下面我们以 AddRequestHeader 为例来讲解。\n\n\n\n\n\n\n\n\n\n需求：给所有进入 userservice 的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!\n只需要修改 gateway 服务的 application.yml 文件，添加路由过滤即可：\n12345678910spring:  cloud:    gateway:      routes:      - id: user-service        uri: lb://userservice        predicates:        - Path=/user/**        filters: # 过滤器        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头\n\n当前过滤器写在 userservice 路由下，因此仅仅对访问 userservice 的请求有效。\n3.4.3.默认过滤器如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：\n12345678910spring:  cloud:    gateway:      routes:      - id: user-service        uri: lb://userservice        predicates:        - Path=/user/**      default-filters: # 默认过滤项      - AddRequestHeader=Truth, Itcast is freaking awesome!\n\n3.4.4.总结过滤器的作用是什么？\n① 对路由的请求或响应做加工处理，比如添加请求头\n② 配置在路由下的过滤器只对当前路由的请求生效\ndefaultFilters 的作用是什么？\n① 对所有路由都生效的过滤器\n3.5.全局过滤器上一节学习的过滤器，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。\n3.5.1.全局过滤器作用全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GatewayFilter 通过配置定义，处理逻辑是固定的；而 GlobalFilter 的逻辑需要自己写代码实现。\n定义方式是实现 GlobalFilter 接口。\n12345678910public interface GlobalFilter &#123;    /**     *  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器     * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束     */    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125;\n\n在 filter 中编写自定义逻辑，可以实现下列功能：\n\n登录状态判断\n权限校验\n请求限流等\n\n3.5.2.自定义全局过滤器需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\n\n参数中是否有 authorization，\nauthorization 参数值是否为 admin\n\n如果同时满足则放行，否则拦截\n实现：\n在 gateway 中定义一个过滤器：\n12345678910111213141516171819202122232425262728293031package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        // 1.获取请求参数        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();        // 2.获取authorization参数        String auth = params.getFirst(&quot;authorization&quot;);        // 3.校验        if (&quot;admin&quot;.equals(auth)) &#123;            // 放行            return chain.filter(exchange);        &#125;        // 4.拦截        // 4.1.禁止访问，设置状态码        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        // 4.2.结束处理        return exchange.getResponse().setComplete();    &#125;&#125;\n\n3.5.3.过滤器执行顺序请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter\n请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：\n\n排序的规则是什么呢？\n\n**每一个过滤器都必须指定一个 int 类型的 order 值，****order 值越小，优先级越高，执行顺序越靠前**。\nGlobalFilter 通过实现 Ordered 接口，或者添加@Order 注解来指定 order 值，由我们自己指定\n路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。\n当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。\n\n详细内容，可以查看源码：\norg.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()方法是先加载 defaultFilters，然后再加载某个 route 的 filters，然后合并。\norg.springframework.cloud.gateway.handler.FilteringWebHandler#handle()方法会加载全局过滤器，与前面的过滤器合并后根据 order 排序，组织过滤器链\n3.6.跨域问题3.6.1.什么是跨域问题跨域：域名不一致就是跨域，主要包括：\n\n**域名不同： **www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com\n域名相同，端口不同：localhost:8080 和 localhost8081\n\n跨域问题：浏览器禁止请求的发起者与服务端发生跨域 ajax 请求，请求被浏览器拦截的问题\n解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看https://www.ruanyifeng.com/blog/2016/04/cors.html\n3.6.2.模拟跨域问题找到课前资料的页面文件：\n\n放入 tomcat 或者 nginx 这样的 web 服务器中，启动并访问。\n可以在浏览器控制台看到下面的错误：\n\n从 localhost:8090 访问 localhost:10010，端口不同，显然是跨域的请求。\n3.6.3.解决跨域问题在 gateway 服务的 application.yml 文件中，添加下面的配置：\n12345678910111213141516171819spring:  cloud:    gateway:      # 。。。      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          &#x27;[/**]&#x27;:            allowedOrigins: # 允许哪些网站的跨域请求              - &quot;http://localhost:8090&quot;            allowedMethods: # 允许的跨域ajax的请求方式              - &quot;GET&quot;              - &quot;POST&quot;              - &quot;DELETE&quot;              - &quot;PUT&quot;              - &quot;OPTIONS&quot;            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期\n","slug":"SpringCloud使用篇02","date":"2023-08-14T10:49:36.000Z","categories_index":"Java","tags_index":"SpringCloud,Java,Spring","author_index":"正茂"}]
=======
[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nhello erveryoneCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-12-27T08:45:00.000Z","categories_index":"","tags_index":"","author_index":"正茂"},{"id":"1637b2da4673dd7cb2a0b4e4e3c13443","title":"AIO-NIO-BIO","content":"第一章 BIO、NIO、AIO课程介绍1.1 课程说明在Java的软件设计开发中，通信架构是不可避免的，我们在进行不同系统或者不同进程之间的数据交互，或者在高并发下的通信场景下都需要用到网络通信相关的技术，对于一些经验丰富的程序员来说，Java早期的网络通信架构存在一些缺陷，其中最令人恼火的是基于性能低下的同步阻塞式的I&#x2F;O通信（BIO），随着互联网开发下通信性能的高要求，Java在2002年开始支持了非阻塞式的I&#x2F;O通信技术(NIO)。大多数读者在学习网络通信相关技术的时候，都只是接触到零碎的通信技术点，没有完整的技术体系架构，以至于对于Java的通信场景总是没有清晰的解决方案。本次课程将通过大量清晰直接的案例从最基础的BIO式通信开始介绍到NIO , AIO，读者可以清晰的了解到阻塞、同步、异步的现象、概念和特征以及优缺点。本课程结合了大量的案例让读者可以快速了解每种通信架构的使用。\n1.2 本课程学习要求\n本课程不太适合完全0基础学员。\n至少需要掌握: Java SE基础编程，如Java多线程，Java IO流编程，Java网络基础知识（如：IP , 端口，协议），常用的Java设计模式要有一定的了解。\n能熟练掌握Java OOP编程，有一定的编程思维。\n\n1.3 通信技术整体解决的问题\n局域网内的通信要求。\n多系统间的底层消息传递机制。\n高并发下，大数据量的通信场景需要。\n游戏行业。无论是手游服务端，还是大型的网络游戏，Java语言都得到越来越广泛的应用。\n\n第二章 Java的I&#x2F;O演进之路2.1 I&#x2F;O 模型基本说明I&#x2F;O 模型：就是用什么样的通道或者说是通信模式和架构进行数据的传输和接收，很大程度上决定了程序通信的性能，Java 共支持 3 种网络编程的&#x2F;IO 模型：BIO、NIO、AIO实际通信需求下，要根据不同的业务场景和性能需求决定选择不同的I&#x2F;O模型\n2.2 I&#x2F;O模型Java BIO同步并阻塞(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 【简单示意图\n\nJava NIOJava NIO ： 同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I&#x2F;O 请求就进行处理 【简单示意图】\n\nJava AIOJava AIO(NIO.2) ： 异步 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，一般适用于连接数较多且连接时间较长的应用\n2.3 BIO、NIO、AIO适用场景分析1、BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。2、NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4 开始支持。3、AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。\n第三章 JAVA BIO深入剖析3.1 Java BIO 基本介绍\nJava BIO 就是传统的 java io  编程，其相关的类和接口在 java.io\nBIO(blocking I&#x2F;O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器).\n\n3.2 Java BIO 工作机制\n对 BIO  编程流程的梳理\n\n**服务器端启动一个 ** ServerSocket，注册端口，调用accpet方法监听客户端的Socket连接。\n**客户端启动 ** Socket 对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯\n\n3.3  传统的BIO编程实例回顾网络编程的基本模型是Client&#x2F;Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信（绑定IP地址和端口），客户端通过连接操作向服务端监听的端口地址发起连接请求，基于TCP协议下进行三次握手连接，连接成功后，双方通过网络套接字（Socket）进行通信。\n\n传统的同步阻塞模型开发中，服务端ServerSocket负责绑定IP地址，启动监听端口；客户端Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。\n基于BIO模式下的通信，客户端 - 服务端是完全同步，完全耦合的。\n\n客户端案例如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.itheima._02bio01;import java.io.OutputStream;import java.io.PrintStream;import java.net.Socket;/**    目标: Socket网络编程。    Java提供了一个包：java.net下的类都是用于网络通信。    Java提供了基于套接字（端口）Socket的网络通信模式，我们基于这种模式就可以直接实现TCP通信。    只要用Socket通信，那么就是基于TCP可靠传输通信。    功能1：客户端发送一个消息，服务端接口一个消息，通信结束！！    创建客户端对象：        （1）创建一个Socket的通信管道，请求与服务端的端口连接。        （2）从Socket管道中得到一个字节输出流。        （3）把字节流改装成自己需要的流进行数据的发送    创建服务端对象：        （1）注册端口        （2）开始等待接收客户端的连接,得到一个端到端的Socket管道        （3）从Socket管道中得到一个字节输入流。        （4）把字节输入流包装成自己需要的流进行数据的读取。    Socket的使用：        构造器：public Socket(String host, int port)        方法：  public OutputStream getOutputStream()：获取字节输出流               public InputStream getInputStream() :获取字节输入流    ServerSocket的使用：        构造器：public ServerSocket(int port)    小结：        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！ */public class ClientDemo &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;==客户端的启动==&quot;);        // （1）创建一个Socket的通信管道，请求与服务端的端口连接。        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);        // （2）从Socket通信管道中得到一个字节输出流。        OutputStream os = socket.getOutputStream();        // （3）把字节流改装成自己需要的流进行数据的发送        PrintStream ps = new PrintStream(os);        // （4）开始发送消息        ps.println(&quot;我是客户端，我想约你吃小龙虾！！！&quot;);        ps.flush();    &#125;&#125;\n\n服务端案例如下1234567891011121314151617181920212223242526272829package com.itheima._02bio01;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;/** * 服务端 */public class ServerDemo &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;==服务器的启动==&quot;);        // （1）注册端口        ServerSocket serverSocket = new ServerSocket(8888);        //（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道        Socket socket = serverSocket.accept();        //（3）从Socket管道中得到一个字节输入流。        InputStream is = socket.getInputStream();        //（4）把字节输入流包装成自己需要的流进行数据的读取。        BufferedReader br = new BufferedReader(new InputStreamReader(is));        //（5）读取数据        String line ;        while((line = br.readLine())!=null)&#123;            System.out.println(&quot;服务端收到：&quot;+line);        &#125;    &#125;&#125;\n\n小结\n在以上通信中，服务端会一致等待客户端的消息，如果客户端没有进行消息的发送，服务端将一直进入阻塞状态。\n同时服务端是按照行获取消息的，这意味着客户端也必须按照行进行消息的发送，否则服务端将进入等待消息的阻塞状态！\n\n3.4 BIO模式下多发和多收消息在1.3的案例中，只能实现客户端发送消息，服务端接收消息，并不能实现反复的收消息和反复的发消息，我们只需要在客户端案例中，加上反复按照行发送消息的逻辑即可！案例代码如下：\n客户端代码如下1234567891011121314151617181920212223242526272829303132333435package com.itheima._03bio02;import java.io.OutputStream;import java.io.PrintStream;import java.net.Socket;import java.util.Scanner;/**    目标: Socket网络编程。    功能1：客户端可以反复发消息，服务端可以反复收消息    小结：        通信是很严格的，对方怎么发你就怎么收，对方发多少你就只能收多少！！ */public class ClientDemo &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;==客户端的启动==&quot;);        // （1）创建一个Socket的通信管道，请求与服务端的端口连接。        Socket socket = new Socket(&quot;127.0.0.1&quot;,8888);        // （2）从Socket通信管道中得到一个字节输出流。        OutputStream os = socket.getOutputStream();        // （3）把字节流改装成自己需要的流进行数据的发送        PrintStream ps = new PrintStream(os);        // （4）开始发送消息        Scanner sc = new Scanner(System.in);        while(true)&#123;            System.out.print(&quot;请说:&quot;);            String msg = sc.nextLine();            ps.println(msg);            ps.flush();        &#125;    &#125;&#125;\n\n服务端代码如下12345678910111213141516171819202122232425262728293031package com.itheima._03bio02;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;/** * 服务端 */public class ServerDemo &#123;    public static void main(String[] args) throws Exception &#123;        String s = &quot;886&quot;;        System.out.println(&quot;886&quot;.equals(s));        System.out.println(&quot;==服务器的启动==&quot;);        //（1）注册端口        ServerSocket serverSocket = new ServerSocket(8888);        //（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道        Socket socket = serverSocket.accept();        //（3）从Socket管道中得到一个字节输入流。        InputStream is = socket.getInputStream();        //（4）把字节输入流包装成  自己需要的流进行数据的读取。        BufferedReader br = new BufferedReader(new InputStreamReader(is));        //（5）读取数据        String line ;        while((line = br.readLine())!=null)&#123;            System.out.println(&quot;服务端收到：&quot;+line);        &#125;    &#125;&#125;\n\n小结\n本案例中确实可以实现客户端多发多收\n但是服务端只能处理一个客户端的请求，因为服务端是单线程的。一次只能与一个客户端进行消息通信。\n\n3.5 BIO模式下接收多个客户端概述\n在上述的案例中，一个服务端只能接收一个客户端的通信请求，那么如果服务端需要处理很多个客户端的消息通信请求应该如何处理呢**，此时我们就需要在服务端引入线程了，也就是说客户端每发起一个请求，服务端就创建一个新的线程来处理这个客户端的请求，这样就实现了一个客户端一个线程的模型，图解模式如下：\n\n\n客户端案例代码如下12345678910111213141516171819202122232425262728/**    目标: Socket网络编程。    功能1：客户端可以反复发，一个服务端可以接收无数个客户端的消息！！    小结：         服务器如果想要接收多个客户端，那么必须引入线程，一个客户端一个线程处理！！ */public class ClientDemo &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;==客户端的启动==&quot;);        // （1）创建一个Socket的通信管道，请求与服务端的端口连接。        Socket socket = new Socket(&quot;127.0.0.1&quot;,7777);        // （2）从Socket通信管道中得到一个字节输出流。        OutputStream os = socket.getOutputStream();        // （3）把字节流改装成自己需要的流进行数据的发送        PrintStream ps = new PrintStream(os);        // （4）开始发送消息        Scanner sc = new Scanner(System.in);        while(true)&#123;            System.out.print(&quot;请说:&quot;);            String msg = sc.nextLine();            ps.println(msg);            ps.flush();        &#125;    &#125;&#125;\n\n服务端案例代码如下1234567891011121314151617181920212223242526272829303132333435363738394041/**    服务端 */public class ServerDemo &#123;    public static void main(String[] args) throws Exception &#123;        System.out.println(&quot;==服务器的启动==&quot;);        // （1）注册端口        ServerSocket serverSocket = new ServerSocket(7777);        while(true)&#123;            //（2）开始在这里暂停等待接收客户端的连接,得到一个端到端的Socket管道            Socket socket = serverSocket.accept();            new ServerReadThread(socket).start();            System.out.println(socket.getRemoteSocketAddress()+&quot;上线了！&quot;);        &#125;    &#125;&#125;class ServerReadThread extends Thread&#123;    private Socket socket;    public ServerReadThread(Socket socket)&#123;        this.socket = socket;    &#125;    @Override    public void run() &#123;        try&#123;            //（3）从Socket管道中得到一个字节输入流。            InputStream is = socket.getInputStream();            //（4）把字节输入流包装成自己需要的流进行数据的读取。            BufferedReader br = new BufferedReader(new InputStreamReader(is));            //（5）读取数据            String line ;            while((line = br.readLine())!=null)&#123;                System.out.println(&quot;服务端收到：&quot;+socket.getRemoteSocketAddress()+&quot;:&quot;+line);            &#125;        &#125;catch (Exception e)&#123;            System.out.println(socket.getRemoteSocketAddress()+&quot;下线了！&quot;);        &#125;    &#125;&#125;\n\n小结\n1.每个Socket接收到，都会创建一个线程，线程的竞争、切换上下文影响性能；\n2.每个线程都会占用栈空间和CPU资源；\n**3.并不是每个socket都进行IO操作，无意义的线程处理；  **\n4.客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。\n\n3.6 伪异步I&#x2F;O编程概述\n在上述案例中：客户端的并发访问增加时。服务端将呈现1:1的线程开销，访问量越大，系统将发生线程栈溢出，线程创建失败，最终导致进程宕机或者僵死，从而不能对外提供服务。\n\n接下来我们采用一个伪异步I&#x2F;O的通信框架，采用线程池和任务队列实现，当客户端接入时，将客户端的Socket封装成一个Task(该任务实现java.lang.Runnable线程任务接口)交给后端的线程池中进行处理。JDK的线程池维护一个消息队列和N个活跃的线程，对消息队列中Socket任务进行处理，由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。\n\n图示如下:\n\n\n\n客户端源码分析123456789101112131415161718192021public class Client &#123;   public static void main(String[] args) &#123;      try &#123;         // 1.简历一个与服务端的Socket对象：套接字         Socket socket = new Socket(&quot;127.0.0.1&quot;, 9999);         // 2.从socket管道中获取一个输出流，写数据给服务端          OutputStream os = socket.getOutputStream() ;         // 3.把输出流包装成一个打印流          PrintWriter pw = new PrintWriter(os);         // 4.反复接收用户的输入          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         String line = null ;         while((line = br.readLine()) != null)&#123;            pw.println(line);            pw.flush();         &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();      &#125;   &#125;&#125;\n\n线程池处理类1234567891011121314151617181920// 线程池处理类public class HandlerSocketThreadPool &#123;      // 线程池    private ExecutorService executor;      public HandlerSocketThreadPool(int maxPoolSize, int queueSize)&#123;            this.executor = new ThreadPoolExecutor(            3, // 8            maxPoolSize,              120L,             TimeUnit.SECONDS,            new ArrayBlockingQueue&lt;Runnable&gt;(queueSize) );   &#125;      public void execute(Runnable task)&#123;      this.executor.execute(task);   &#125;&#125;\n\n服务端源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Server &#123;   public static void main(String[] args) &#123;      try &#123;         System.out.println(&quot;----------服务端启动成功------------&quot;);         ServerSocket ss = new ServerSocket(9999);         // 一个服务端只需要对应一个线程池         HandlerSocketThreadPool handlerSocketThreadPool =               new HandlerSocketThreadPool(3, 1000);         // 客户端可能有很多个         while(true)&#123;            Socket socket = ss.accept() ; // 阻塞式的！            System.out.println(&quot;有人上线了！！&quot;);            // 每次收到一个客户端的socket请求，都需要为这个客户端分配一个            // 独立的线程 专门负责对这个客户端的通信！！            handlerSocketThreadPool.execute(new ReaderClientRunnable(socket));         &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();      &#125;   &#125;&#125;class ReaderClientRunnable implements Runnable&#123;   private Socket socket ;   public ReaderClientRunnable(Socket socket) &#123;      this.socket = socket;   &#125;   @Override   public void run() &#123;      try &#123;         // 读取一行数据         InputStream is = socket.getInputStream() ;         // 转成一个缓冲字符流         Reader fr = new InputStreamReader(is);         BufferedReader br = new BufferedReader(fr);         // 一行一行的读取数据         String line = null ;         while((line = br.readLine())!=null)&#123; // 阻塞式的！！            System.out.println(&quot;服务端收到了数据：&quot;+line);         &#125;      &#125; catch (Exception e) &#123;         System.out.println(&quot;有人下线了&quot;);      &#125;   &#125;&#125;\n\n小结\n伪异步io采用了线程池实现，因此避免了为每个请求创建一个独立线程造成线程资源耗尽的问题，但由于底层依然是采用的同步阻塞模型，因此无法从根本上解决问题。\n如果单个消息处理的缓慢，或者服务器线程池中的全部线程都被阻塞，那么后续socket的i&#x2F;o消息都将在队列中排队。新的Socket请求将被拒绝，客户端会发生大量连接超时。\n\n3.7 基于BIO形式下的文件上传目标支持任意类型文件形式的上传。\n客户端开发1234567891011121314151617181920212223242526272829303132333435package com.itheima.file;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.InputStream;import java.net.Socket;/**    目标：实现客户端上传任意类型的文件数据给服务端保存起来。 */public class Client &#123;    public static void main(String[] args) &#123;        try(                InputStream is = new FileInputStream(&quot;C:\\\\Users\\\\dlei\\\\Desktop\\\\BIO,NIO,AIO\\\\文件\\\\java.png&quot;);        )&#123;            //  1、请求与服务端的Socket链接            Socket socket = new Socket(&quot;127.0.0.1&quot; , 8888);            //  2、把字节输出流包装成一个数据输出流            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());            //  3、先发送上传文件的后缀给服务端            dos.writeUTF(&quot;.png&quot;);            //  4、把文件数据发送给服务端进行接收            byte[] buffer = new byte[1024];            int len;            while((len = is.read(buffer)) &gt; 0 )&#123;                dos.write(buffer , 0 , len);            &#125;            dos.flush();            Thread.sleep(10000);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n服务端开发12345678910111213141516171819202122package com.itheima.file;import java.net.ServerSocket;import java.net.Socket;/**    目标：服务端开发，可以实现接收客户端的任意类型文件，并保存到服务端磁盘。 */public class Server &#123;    public static void main(String[] args) &#123;        try&#123;            ServerSocket ss = new ServerSocket(8888);            while (true)&#123;                Socket socket = ss.accept();                // 交给一个独立的线程来处理与这个客户端的文件通信需求。                new ServerReaderThread(socket).start();            &#125;        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.file;import java.io.DataInputStream;import java.io.FileOutputStream;import java.io.OutputStream;import java.net.Socket;import java.util.UUID;public class ServerReaderThread extends Thread &#123;    private Socket socket;    public ServerReaderThread(Socket socket)&#123;        this.socket = socket;    &#125;    @Override    public void run() &#123;        try&#123;            // 1、得到一个数据输入流读取客户端发送过来的数据            DataInputStream dis = new DataInputStream(socket.getInputStream());            // 2、读取客户端发送过来的文件类型            String suffix = dis.readUTF();            System.out.println(&quot;服务端已经成功接收到了文件类型：&quot; + suffix);            // 3、定义一个字节输出管道负责把客户端发来的文件数据写出去            OutputStream os = new FileOutputStream(&quot;C:\\\\Users\\\\dlei\\\\Desktop\\\\BIO,NIO,AIO\\\\文件\\\\server\\\\&quot;+                    UUID.randomUUID().toString()+suffix);            // 4、从数据输入流中读取文件数据，写出到字节输出流中去            byte[] buffer = new byte[1024];            int len;            while((len = dis.read(buffer)) &gt; 0)&#123;                os.write(buffer,0, len);            &#125;            os.close();            System.out.println(&quot;服务端接收文件保存成功！&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n小结客户端怎么发，服务端就怎么接收\n3.9 Java BIO模式下的端口转发思想需求：需要实现一个客户端的消息可以发送给所有的客户端去接收。（群聊实现）\n\n客户端开发1234567891011121314151617181920212223242526272829303132333435package com.itheima.file;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.InputStream;import java.net.Socket;/**    目标：实现客户端上传任意类型的文件数据给服务端保存起来。 */public class Client &#123;    public static void main(String[] args) &#123;        try(                InputStream is = new FileInputStream(&quot;C:\\\\Users\\\\dlei\\\\Desktop\\\\BIO,NIO,AIO\\\\文件\\\\java.png&quot;);        )&#123;            //  1、请求与服务端的Socket链接            Socket socket = new Socket(&quot;127.0.0.1&quot; , 8888);            //  2、把字节输出流包装成一个数据输出流            DataOutputStream dos = new DataOutputStream(socket.getOutputStream());            //  3、先发送上传文件的后缀给服务端            dos.writeUTF(&quot;.png&quot;);            //  4、把文件数据发送给服务端进行接收            byte[] buffer = new byte[1024];            int len;            while((len = is.read(buffer)) &gt; 0 )&#123;                dos.write(buffer , 0 , len);            &#125;            dos.flush();            Thread.sleep(10000);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n服务端实现小结3.10 基于BIO模式下即时通信基于BIO模式下的即时通信，我们需要解决客户端到客户端的通信，也就是需要实现客户端与客户端的端口消息转发逻辑。\n项目功能演示项目案例说明本项目案例为即时通信的软件项目，适合基础加强的大案例，具备综合性。学习本项目案例至少需要具备如下Java SE技术点:\n\n\nJava 面向对象设计，语法设计。\n\n\n\n多线程技术。\n\n\n\nIO流技术。\n\n\n\n网络通信相关技术。\n\n\n\n集合框架。\n\n\n\n项目开发思维。\n\n\n\nJava 常用 api 使用。\n\n\n……\n\n\n功能清单简单说明：1.客户端登陆功能\n\n可以启动客户端进行登录，客户端登陆只需要输入用户名和服务端ip地址即可。\n\n2.在线人数实时更新。\n\n客户端用户户登陆以后，需要同步更新所有客户端的联系人信息栏。\n\n3.离线人数更新\n\n检测到有客户端下线后，需要同步更新所有客户端的联系人信息栏。\n\n4.群聊\n\n任意一个客户端的消息，可以推送给当前所有客户端接收。\n\n5.私聊\n\n可以选择某个员工，点击私聊按钮，然后发出的消息可以被该客户端单独接收。\n\n6.@消息\n\n可以选择某个员工，然后发出的消息可以@该用户，但是其他所有人都能\n\n7.消息用户和消息时间点\n\n服务端可以实时记录该用户的消息时间点，然后进行消息的多路转发或者选择。\n\n项目启动与演示项目代码结构演示。\n\n项目启动步骤：\n\n1.首先需要启动服务端，点击ServerChat类直接右键启动，显示服务端启动成功！\n\n2.其次，点击客户端类ClientChat类，在弹出的方框中输入服务端的ip和当前客户端的昵称\n\n3.登陆进入后的聊天界面如下，即可进行相关操作。\n\n如果直接点击发送，默认发送群聊消息\n\n\n如果选中右侧在线列表某个用户，默认发送@消息\n\n如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。\n\n\n\n\n技术选型分析本项目案例涉及到Java基础加强的案例，具体涉及到的技术点如下：\n\n\nJava 面向对象设计，语法设计。\n\n\n\n多线程技术。\n\n\n\nIO流技术。\n\n\n\n网络通信相关技术。\n\n\n\n集合框架。\n\n\n\n项目开发思维。\n\n\n\nJava 常用 api 使用。\n\n……\n\n\n服务端设计服务端接收多个客户端逻辑目标服务端需要接收多个客户端的接入。\n实现步骤\n1.服务端需要接收多个客户端，目前我们采取的策略是一个客户端对应一个服务端线程。\n2.服务端除了要注册端口以外，还需要为每个客户端分配一个独立线程处理与之通信。\n\n代码实现\n服务端主体代码，主要进行端口注册，和接收客户端，分配线程处理该客户端请求\n\n123456789101112131415161718192021public class ServerChat &#123;        /** 定义一个集合存放所有在线的socket  */public static Map&lt;Socket, String&gt; onLineSockets = new HashMap&lt;&gt;();   public static void main(String[] args) &#123;      try &#123;         /** 1.注册端口   */         ServerSocket serverSocket = new ServerSocket(Constants.PORT);         /** 2.循环一直等待所有可能的客户端连接 */         while(true)&#123;            Socket socket = serverSocket.accept();            /**3. 把客户端的socket管道单独配置一个线程来处理 */            new ServerReader(socket).start();         &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();      &#125;   &#125;&#125;\n\n\n服务端分配的独立线程类负责处理该客户端Socket的管道请求。\n\n1234567891011121314class ServerReader extends Thread &#123;   private Socket socket;   public ServerReader(Socket socket) &#123;      this.socket = socket;   &#125;   @Override   public void run() &#123;      try &#123;             &#125; catch (Exception e) &#123;            e.printStackTrace();      &#125;   &#125;&#125;\n\n常量包负责做端口配置\n12345public class Constants &#123;   /** 常量 */   public static final int PORT = 7778 ;&#125;\n\n小结\n本节实现了服务端可以接收多个客户端请求。\n\n服务端接收登陆消息以及监测离线目标在上节我们实现了服务端可以接收多个客户端，然后服务端可以接收多个客户端连接，接下来我们要接收客户端的登陆消息。\n实现步骤\n需要在服务端处理客户端的线程的登陆消息。\n需要注意的是，服务端需要接收客户端的消息可能有很多种。\n分别是登陆消息，群聊消息，私聊消息 和@消息。\n这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。\n1代表接收的是登陆消息\n2代表群发| @消息\n3代表了私聊消息\n\n\n\n\n服务端的线程中有异常校验机制，一旦发现客户端下线会在异常机制中处理，然后移除当前客户端用户，把最新的用户列表发回给全部客户端进行在线人数更新。\n\n代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class ServerReader extends Thread &#123;private Socket socket;public ServerReader(Socket socket) &#123;this.socket = socket;&#125;@Overridepublic void run() &#123;DataInputStream dis = null;try &#123;dis = new DataInputStream(socket.getInputStream());/** 1.循环一直等待客户端的消息 */while(true)&#123;/** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */int flag = dis.readInt();if(flag == 1)&#123;/** 先将当前登录的客户端socket存到在线人数的socket集合中   */String name = dis.readUTF() ;System.out.println(name+&quot;----&gt;&quot;+socket.getRemoteSocketAddress());ServerChat.onLineSockets.put(socket, name);&#125;writeMsg(flag,dis);&#125;&#125; catch (Exception e) &#123;System.out.println(&quot;--有人下线了--&quot;);// 从在线人数中将当前socket移出去  ServerChat.onLineSockets.remove(socket);try &#123;// 从新更新在线人数并发给所有客户端 writeMsg(1,dis);&#125; catch (Exception e1) &#123;e1.printStackTrace();&#125;&#125;&#125;private void writeMsg(int flag, DataInputStream dis) throws Exception &#123;        // DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); // 定义一个变量存放最终的消息形式 String msg = null ;if(flag == 1)&#123;/** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 *//** onlineNames = [波仔,zhangsan,波妞]*/StringBuilder rs = new StringBuilder();Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();// 判断是否存在在线人数 if(onlineNames != null &amp;&amp; onlineNames.size() &gt; 0)&#123;for(String name : onlineNames)&#123;rs.append(name+ Constants.SPILIT);&#125;// 去掉最后的一个分隔符 msg = rs.substring(0, rs.lastIndexOf(Constants.SPILIT));/** 将消息发送给所有的客户端 */sendMsgToAll(flag,msg);&#125;&#125;else if(flag == 2 || flag == 3)&#123;&#125;&#125;&#125;private void sendMsgToAll(int flag, String msg) throws Exception &#123;// 拿到所有的在线socket管道 给这些管道写出消息Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();for(Socket sk :  allOnLineSockets)&#123;DataOutputStream dos = new DataOutputStream(sk.getOutputStream());dos.writeInt(flag); // 消息类型dos.writeUTF(msg);dos.flush();&#125;&#125;&#125;\n\n小结\n此处实现了接收客户端的登陆消息，然后提取当前在线的全部的用户名称和当前登陆的用户名称发送给全部在线用户更新自己的在线人数列表。\n\n服务端接收群聊消息目标在上节实现了接收客户端的登陆消息，然后提取当前在线的全部的用户名称和当前登陆的用户名称发送给全部在线用户更新自己的在线人数列表。接下来要接收客户端发来的群聊消息推送给当前在线的所有客户端\n实现步骤\n接下来要接收客户端发来的群聊消息。\n需要注意的是，服务端需要接收客户端的消息可能有很多种。\n分别是登陆消息，群聊消息，私聊消息 和@消息。\n这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。\n1代表接收的是登陆消息\n2代表群发| @消息\n3代表了私聊消息\n\n\n\n\n\n代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class ServerReader extends Thread &#123;private Socket socket;public ServerReader(Socket socket) &#123;this.socket = socket;&#125;@Overridepublic void run() &#123;DataInputStream dis = null;try &#123;dis = new DataInputStream(socket.getInputStream());/** 1.循环一直等待客户端的消息 */while(true)&#123;/** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */int flag = dis.readInt();if(flag == 1)&#123;/** 先将当前登录的客户端socket存到在线人数的socket集合中   */String name = dis.readUTF() ;System.out.println(name+&quot;----&gt;&quot;+socket.getRemoteSocketAddress());ServerChat.onLineSockets.put(socket, name);&#125;writeMsg(flag,dis);&#125;&#125; catch (Exception e) &#123;System.out.println(&quot;--有人下线了--&quot;);// 从在线人数中将当前socket移出去  ServerChat.onLineSockets.remove(socket);try &#123;// 从新更新在线人数并发给所有客户端 writeMsg(1,dis);&#125; catch (Exception e1) &#123;e1.printStackTrace();&#125;&#125;&#125;private void writeMsg(int flag, DataInputStream dis) throws Exception &#123;        // DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); // 定义一个变量存放最终的消息形式 String msg = null ;if(flag == 1)&#123;/** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 *//** onlineNames = [波仔,zhangsan,波妞]*/StringBuilder rs = new StringBuilder();Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();// 判断是否存在在线人数 if(onlineNames != null &amp;&amp; onlineNames.size() &gt; 0)&#123;for(String name : onlineNames)&#123;rs.append(name+ Constants.SPILIT);&#125;// 去掉最后的一个分隔符 msg = rs.substring(0, rs.lastIndexOf(Constants.SPILIT));/** 将消息发送给所有的客户端 */sendMsgToAll(flag,msg);&#125;&#125;else if(flag == 2 || flag == 3)&#123;// 读到消息  群发的 或者 @消息String newMsg = dis.readUTF() ; // 消息// 得到发件人 String sendName = ServerChat.onLineSockets.get(socket);// 内容StringBuilder msgFinal = new StringBuilder();// 时间  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss EEE&quot;);if(flag == 2)&#123;msgFinal.append(sendName).append(&quot;  &quot;).append(sdf.format(System.currentTimeMillis())).append(&quot;\\r\\n&quot;);msgFinal.append(&quot;    &quot;).append(newMsg).append(&quot;\\r\\n&quot;);sendMsgToAll(flag,msgFinal.toString());&#125;else if(flag == 3)&#123;&#125;&#125;&#125;private void sendMsgToAll(int flag, String msg) throws Exception &#123;// 拿到所有的在线socket管道 给这些管道写出消息Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();for(Socket sk :  allOnLineSockets)&#123;DataOutputStream dos = new DataOutputStream(sk.getOutputStream());dos.writeInt(flag); // 消息类型dos.writeUTF(msg);dos.flush();&#125;&#125;&#125;\n\n小结\n此处根据消息的类型判断为群聊消息，然后把群聊消息推送给当前在线的所有客户端。\n\n服务端接收私聊消息目标在上节我们接收了客户端发来的群聊消息推送给当前在线的所有客户端，接下来要解决私聊消息的推送逻辑\n实现步骤\n解决私聊消息的推送逻辑，私聊消息需要知道推送给某个具体的客户端\n我们可以接收到客户端发来的私聊用户名称，根据用户名称定位该用户的Socket管道，然后单独推送消息给该Socket管道。\n需要注意的是，服务端需要接收客户端的消息可能有很多种。\n分别是登陆消息，群聊消息，私聊消息 和@消息。\n这里需要约定如果客户端发送消息之前需要先发送消息的类型，类型我们使用信号值标志（1，2，3）。\n1代表接收的是登陆消息\n2代表群发| @消息\n3代表了私聊消息\n\n\n\n\n\n代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class ServerReader extends Thread &#123;private Socket socket;public ServerReader(Socket socket) &#123;this.socket = socket;&#125;@Overridepublic void run() &#123;DataInputStream dis = null;try &#123;dis = new DataInputStream(socket.getInputStream());/** 1.循环一直等待客户端的消息 */while(true)&#123;/** 2.读取当前的消息类型 ：登录,群发,私聊 , @消息 */int flag = dis.readInt();if(flag == 1)&#123;/** 先将当前登录的客户端socket存到在线人数的socket集合中   */String name = dis.readUTF() ;System.out.println(name+&quot;----&gt;&quot;+socket.getRemoteSocketAddress());ServerChat.onLineSockets.put(socket, name);&#125;writeMsg(flag,dis);&#125;&#125; catch (Exception e) &#123;System.out.println(&quot;--有人下线了--&quot;);// 从在线人数中将当前socket移出去  ServerChat.onLineSockets.remove(socket);try &#123;// 从新更新在线人数并发给所有客户端 writeMsg(1,dis);&#125; catch (Exception e1) &#123;e1.printStackTrace();&#125;&#125;&#125;private void writeMsg(int flag, DataInputStream dis) throws Exception &#123;        // DataOutputStream dos = new DataOutputStream(socket.getOutputStream()); // 定义一个变量存放最终的消息形式 String msg = null ;if(flag == 1)&#123;/** 读取所有在线人数发给所有客户端去更新自己的在线人数列表 *//** onlineNames = [波仔,zhangsan,波妞]*/StringBuilder rs = new StringBuilder();Collection&lt;String&gt; onlineNames = ServerChat.onLineSockets.values();// 判断是否存在在线人数 if(onlineNames != null &amp;&amp; onlineNames.size() &gt; 0)&#123;for(String name : onlineNames)&#123;rs.append(name+ Constants.SPILIT);&#125;// 去掉最后的一个分隔符 msg = rs.substring(0, rs.lastIndexOf(Constants.SPILIT));/** 将消息发送给所有的客户端 */sendMsgToAll(flag,msg);&#125;&#125;else if(flag == 2 || flag == 3)&#123;// 读到消息  群发的 或者 @消息String newMsg = dis.readUTF() ; // 消息// 得到发件人 String sendName = ServerChat.onLineSockets.get(socket);// 内容StringBuilder msgFinal = new StringBuilder();// 时间  SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss EEE&quot;);if(flag == 2)&#123;msgFinal.append(sendName).append(&quot;  &quot;).append(sdf.format(System.currentTimeMillis())).append(&quot;\\r\\n&quot;);msgFinal.append(&quot;    &quot;).append(newMsg).append(&quot;\\r\\n&quot;);sendMsgToAll(flag,msgFinal.toString());&#125;else if(flag == 3)&#123;msgFinal.append(sendName).append(&quot;  &quot;).append(sdf.format(System.currentTimeMillis())).append(&quot;对您私发\\r\\n&quot;);msgFinal.append(&quot;    &quot;).append(newMsg).append(&quot;\\r\\n&quot;);// 私发 // 得到给谁私发 String destName = dis.readUTF();sendMsgToOne(destName,msgFinal.toString());&#125;&#125;&#125;/** * @param destName 对谁私发  * @param msg 发的消息内容  * @throws Exception */private void sendMsgToOne(String destName, String msg) throws Exception &#123;// 拿到所有的在线socket管道 给这些管道写出消息Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();for(Socket sk :  allOnLineSockets)&#123;// 得到当前需要私发的socket // 只对这个名字对应的socket私发消息if(ServerChat.onLineSockets.get(sk).trim().equals(destName))&#123;DataOutputStream dos = new DataOutputStream(sk.getOutputStream());dos.writeInt(2); // 消息类型dos.writeUTF(msg);dos.flush();&#125;&#125;&#125;private void sendMsgToAll(int flag, String msg) throws Exception &#123;// 拿到所有的在线socket管道 给这些管道写出消息Set&lt;Socket&gt; allOnLineSockets = ServerChat.onLineSockets.keySet();for(Socket sk :  allOnLineSockets)&#123;DataOutputStream dos = new DataOutputStream(sk.getOutputStream());dos.writeInt(flag); // 消息类型dos.writeUTF(msg);dos.flush();&#125;&#125;&#125;\n\n小结\n本节我们解决了私聊消息的推送逻辑，私聊消息需要知道推送给某个具体的客户端Socket管道\n我们可以接收到客户端发来的私聊用户名称，根据用户名称定位该用户的Socket管道，然后单独推送消息给该Socket管道。\n\n客户端设计启动客户端界面 ,登陆，刷新在线目标启动客户端界面，登陆，刷新在线人数列表\n实现步骤\n客户端界面主要是GUI设计，主体页面分为登陆界面和聊天窗口，以及在线用户列表。\nGUI界面读者可以自行复制使用。\n登陆输入服务端ip和用户名后，要请求与服务端的登陆，然后立即为当前客户端分配一个读线程处理客户端的读数据消息。因为客户端可能随时会接收到服务端那边转发过来的各种即时消息信息。\n客户端登陆完成，服务端收到登陆的用户名后，会立即发来最新的用户列表给客户端更新。\n\n代码实现客户端主体代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public class ClientChat implements ActionListener &#123;   /** 1.设计界面  */   private JFrame win = new JFrame();   /** 2.消息内容框架 */   public JTextArea smsContent =new JTextArea(23 , 50);   /** 3.发送消息的框  */   private JTextArea smsSend = new JTextArea(4,40);   /** 4.在线人数的区域  */   /** 存放人的数据 */   /** 展示在线人数的窗口 */   public JList&lt;String&gt; onLineUsers = new JList&lt;&gt;();   // 是否私聊按钮   private JCheckBox isPrivateBn = new JCheckBox(&quot;私聊&quot;);   // 消息按钮   private JButton sendBn  = new JButton(&quot;发送&quot;);   // 登录界面   private JFrame loginView;   private JTextField ipEt , nameEt , idEt;   private Socket socket ;   public static void main(String[] args) &#123;      new ClientChat().initView();   &#125;   private void initView() &#123;      /** 初始化聊天窗口的界面 */      win.setSize(650, 600);      /** 展示登录界面  */      displayLoginView();      /** 展示聊天界面 */      //displayChatView();   &#125;   private void displayChatView() &#123;      JPanel bottomPanel = new JPanel(new BorderLayout());      //-----------------------------------------------      // 将消息框和按钮 添加到窗口的底端      win.add(bottomPanel, BorderLayout.SOUTH);      bottomPanel.add(smsSend);      JPanel btns = new JPanel(new FlowLayout(FlowLayout.LEFT));      btns.add(sendBn);      btns.add(isPrivateBn);      bottomPanel.add(btns, BorderLayout.EAST);      //-----------------------------------------------      // 给发送消息按钮绑定点击事件监听器      // 将展示消息区centerPanel添加到窗口的中间      smsContent.setBackground(new Color(0xdd,0xdd,0xdd));      // 让展示消息区可以滚动。      win.add(new JScrollPane(smsContent), BorderLayout.CENTER);      smsContent.setEditable(false);      //-----------------------------------------------      // 用户列表和是否私聊放到窗口的最右边      Box rightBox = new Box(BoxLayout.Y_AXIS);      onLineUsers.setFixedCellWidth(120);      onLineUsers.setVisibleRowCount(13);      rightBox.add(new JScrollPane(onLineUsers));      win.add(rightBox, BorderLayout.EAST);      //-----------------------------------------------      // 关闭窗口退出当前程序      win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);      win.pack();  // swing 加上这句 就可以拥有关闭窗口的功能      /** 设置窗口居中,显示出来  */      setWindowCenter(win,650,600,true);      // 发送按钮绑定点击事件      sendBn.addActionListener(this);   &#125;   private void displayLoginView()&#123;      /** 先让用户进行登录       *  服务端ip       *  用户名       *  id       *  */      /** 显示一个qq的登录框     */      loginView = new JFrame(&quot;登录&quot;);      loginView.setLayout(new GridLayout(3, 1));      loginView.setSize(400, 230);      JPanel ip = new JPanel();      JLabel label = new JLabel(&quot;   IP:&quot;);      ip.add(label);      ipEt = new JTextField(20);      ip.add(ipEt);      loginView.add(ip);      JPanel name = new JPanel();      JLabel label1 = new JLabel(&quot;姓名:&quot;);      name.add(label1);      nameEt = new JTextField(20);      name.add(nameEt);      loginView.add(name);      JPanel btnView = new JPanel();      JButton login = new JButton(&quot;登陆&quot;);      btnView.add(login);      JButton cancle = new JButton(&quot;取消&quot;);      btnView.add(cancle);      loginView.add(btnView);      // 关闭窗口退出当前程序      loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);      setWindowCenter(loginView,400,260,true);      /** 给登录和取消绑定点击事件 */      login.addActionListener(this);      cancle.addActionListener(this);   &#125;   private static void setWindowCenter(JFrame frame, int width , int height, boolean flag) &#123;      /** 得到所在系统所在屏幕的宽高 */      Dimension ds = frame.getToolkit().getScreenSize();      /** 拿到电脑的宽 */      int width1 = ds.width;      /** 高 */      int height1 = ds.height ;      System.out.println(width1 +&quot;*&quot; + height1);      /** 设置窗口的左上角坐标 */      frame.setLocation(width1/2 - width/2, height1/2 -height/2);      frame.setVisible(flag);   &#125;   @Override   public void actionPerformed(ActionEvent e) &#123;      /** 得到点击的事件源 */      JButton btn = (JButton) e.getSource();      switch(btn.getText())&#123;         case &quot;登陆&quot;:            String ip = ipEt.getText().toString();            String name = nameEt.getText().toString();            // 校验参数是否为空            // 错误提示            String msg = &quot;&quot; ;            // 12.1.2.0            // \\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\            if(ip==null || !ip.matches(&quot;\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;&quot;))&#123;               msg = &quot;请输入合法的服务端ip地址&quot;;            &#125;else if(name==null || !name.matches(&quot;\\\\S&#123;1,&#125;&quot;))&#123;               msg = &quot;姓名必须1个字符以上&quot;;            &#125;            if(!msg.equals(&quot;&quot;))&#123;               /** msg有内容说明参数有为空 */               // 参数一：弹出放到哪个窗口里面               JOptionPane.showMessageDialog(loginView, msg);            &#125;else&#123;               try &#123;                  // 参数都合法了                  // 当前登录的用户,去服务端登陆                  /** 先把当前用户的名称展示到界面 */                  win.setTitle(name);                  // 去服务端登陆连接一个socket管道                  socket = new Socket(ip, Constants.PORT);                  //为客户端的socket分配一个线程 专门负责收消息                  new ClientReader(this,socket).start();                  // 带上用户信息过去                  DataOutputStream dos = new DataOutputStream(socket.getOutputStream());                  dos.writeInt(1); // 登录消息                  dos.writeUTF(name.trim());                  dos.flush();                  // 关系当前窗口 弹出聊天界面                  loginView.dispose(); // 登录窗口销毁                  displayChatView(); // 展示了聊天窗口了               &#125; catch (Exception e1) &#123;                  e1.printStackTrace();               &#125;            &#125;            break;         case &quot;取消&quot;:            /** 退出系统 */            System.exit(0);            break;         case &quot;发送&quot;:                        break;      &#125;   &#125;&#125;\n\n客户端socket处理线程：\n1234567891011121314151617181920212223242526272829303132333435public class ClientReader extends Thread &#123;   private Socket socket;    // 接收客户端界面，方便收到消息后，更新界面数据。   private ClientChat clientChat ;   public ClientReader(ClientChat clientChat, Socket socket) &#123;      this.clientChat = clientChat;      this.socket = socket;   &#125;   @Override   public void run() &#123;      try &#123;         DataInputStream dis = new DataInputStream(socket.getInputStream());         /** 循环一直等待客户端的消息 */         while(true)&#123;            /** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */            int flag = dis.readInt();            if(flag == 1)&#123;               // 在线人数消息回来了               String nameDatas = dis.readUTF();               // 展示到在线人数的界面               String[] names = nameDatas.split(Constants.SPILIT);               clientChat.onLineUsers.setListData(names);            &#125;else if(flag == 2)&#123;                          &#125;         &#125;      &#125; catch (Exception e) &#123;         e.printStackTrace();      &#125;   &#125;&#125;\n\n小结\n此处说明了如果启动客户端界面，以及登陆功能后，服务端收到新的登陆消息后，会响应一个在线列表用户回来给客户端更新在线人数！\n\n客户端发送消息逻辑目标客户端发送群聊消息，@消息，以及私聊消息。\n实现步骤\n客户端启动后，在聊天界面需要通过发送按钮推送群聊消息，@消息，以及私聊消息。\n\n如果直接点击发送，默认发送群聊消息\n如果选中右侧在线列表某个用户，默认发送@消息\n如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。\n\n代码实现客户端主体代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227public class ClientChat implements ActionListener &#123;/** 1.设计界面  */private JFrame win = new JFrame();/** 2.消息内容框架 */public JTextArea smsContent =new JTextArea(23 , 50);/** 3.发送消息的框  */private JTextArea smsSend = new JTextArea(4,40);/** 4.在线人数的区域  *//** 存放人的数据 *//** 展示在线人数的窗口 */public JList&lt;String&gt; onLineUsers = new JList&lt;&gt;();// 是否私聊按钮private JCheckBox isPrivateBn = new JCheckBox(&quot;私聊&quot;);// 消息按钮private JButton sendBn  = new JButton(&quot;发送&quot;);// 登录界面private JFrame loginView;private JTextField ipEt , nameEt , idEt;private Socket socket ;public static void main(String[] args) &#123;new ClientChat().initView();&#125;private void initView() &#123;/** 初始化聊天窗口的界面 */win.setSize(650, 600);/** 展示登录界面  */displayLoginView();/** 展示聊天界面 *///displayChatView();&#125;private void displayChatView() &#123;JPanel bottomPanel = new JPanel(new BorderLayout());//-----------------------------------------------// 将消息框和按钮 添加到窗口的底端win.add(bottomPanel, BorderLayout.SOUTH);bottomPanel.add(smsSend);JPanel btns = new JPanel(new FlowLayout(FlowLayout.LEFT));btns.add(sendBn);btns.add(isPrivateBn);bottomPanel.add(btns, BorderLayout.EAST);//-----------------------------------------------// 给发送消息按钮绑定点击事件监听器// 将展示消息区centerPanel添加到窗口的中间smsContent.setBackground(new Color(0xdd,0xdd,0xdd));// 让展示消息区可以滚动。win.add(new JScrollPane(smsContent), BorderLayout.CENTER);smsContent.setEditable(false);//-----------------------------------------------// 用户列表和是否私聊放到窗口的最右边Box rightBox = new Box(BoxLayout.Y_AXIS);onLineUsers.setFixedCellWidth(120);onLineUsers.setVisibleRowCount(13);rightBox.add(new JScrollPane(onLineUsers));win.add(rightBox, BorderLayout.EAST);//-----------------------------------------------// 关闭窗口退出当前程序win.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);win.pack();  // swing 加上这句 就可以拥有关闭窗口的功能/** 设置窗口居中,显示出来  */setWindowCenter(win,650,600,true);// 发送按钮绑定点击事件sendBn.addActionListener(this);&#125;private void displayLoginView()&#123;/** 先让用户进行登录 *  服务端ip *  用户名 *  id *  *//** 显示一个qq的登录框     */loginView = new JFrame(&quot;登录&quot;);loginView.setLayout(new GridLayout(3, 1));loginView.setSize(400, 230);JPanel ip = new JPanel();JLabel label = new JLabel(&quot;   IP:&quot;);ip.add(label);ipEt = new JTextField(20);ip.add(ipEt);loginView.add(ip);JPanel name = new JPanel();JLabel label1 = new JLabel(&quot;姓名:&quot;);name.add(label1);nameEt = new JTextField(20);name.add(nameEt);loginView.add(name);JPanel btnView = new JPanel();JButton login = new JButton(&quot;登陆&quot;);btnView.add(login);JButton cancle = new JButton(&quot;取消&quot;);btnView.add(cancle);loginView.add(btnView);// 关闭窗口退出当前程序loginView.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);setWindowCenter(loginView,400,260,true);/** 给登录和取消绑定点击事件 */login.addActionListener(this);cancle.addActionListener(this);&#125;private static void setWindowCenter(JFrame frame, int width , int height, boolean flag) &#123;/** 得到所在系统所在屏幕的宽高 */Dimension ds = frame.getToolkit().getScreenSize();/** 拿到电脑的宽 */int width1 = ds.width;/** 高 */int height1 = ds.height ;System.out.println(width1 +&quot;*&quot; + height1);/** 设置窗口的左上角坐标 */frame.setLocation(width1/2 - width/2, height1/2 -height/2);frame.setVisible(flag);&#125;@Overridepublic void actionPerformed(ActionEvent e) &#123;/** 得到点击的事件源 */JButton btn = (JButton) e.getSource();switch(btn.getText())&#123;case &quot;登陆&quot;:String ip = ipEt.getText().toString();String name = nameEt.getText().toString();// 校验参数是否为空// 错误提示String msg = &quot;&quot; ;// 12.1.2.0// \\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\if(ip==null || !ip.matches(&quot;\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;&quot;))&#123;msg = &quot;请输入合法的服务端ip地址&quot;;&#125;else if(name==null || !name.matches(&quot;\\\\S&#123;1,&#125;&quot;))&#123;msg = &quot;姓名必须1个字符以上&quot;;&#125;if(!msg.equals(&quot;&quot;))&#123;/** msg有内容说明参数有为空 */// 参数一：弹出放到哪个窗口里面JOptionPane.showMessageDialog(loginView, msg);&#125;else&#123;try &#123;// 参数都合法了// 当前登录的用户,去服务端登陆/** 先把当前用户的名称展示到界面 */win.setTitle(name);// 去服务端登陆连接一个socket管道socket = new Socket(ip, Constants.PORT);//为客户端的socket分配一个线程 专门负责收消息new ClientReader(this,socket).start();// 带上用户信息过去DataOutputStream dos = new DataOutputStream(socket.getOutputStream());dos.writeInt(1); // 登录消息dos.writeUTF(name.trim());dos.flush();// 关系当前窗口 弹出聊天界面loginView.dispose(); // 登录窗口销毁displayChatView(); // 展示了聊天窗口了&#125; catch (Exception e1) &#123;e1.printStackTrace();&#125;&#125;break;case &quot;取消&quot;:/** 退出系统 */System.exit(0);break;case &quot;发送&quot;:// 得到发送消息的内容String msgSend = smsSend.getText().toString();if(!msgSend.trim().equals(&quot;&quot;))&#123;/** 发消息给服务端 */try &#123;// 判断是否对谁发消息String selectName = onLineUsers.getSelectedValue();int flag = 2 ;// 群发 @消息if(selectName!=null&amp;&amp;!selectName.equals(&quot;&quot;))&#123;msgSend =(&quot;@&quot;+selectName+&quot;,&quot;+msgSend);/** 判断是否选中了私法 */if(isPrivateBn.isSelected())&#123;/** 私法 */flag = 3 ;//私发消息&#125;&#125;DataOutputStream dos = new DataOutputStream(socket.getOutputStream());dos.writeInt(flag); // 群发消息  发送给所有人dos.writeUTF(msgSend);if(flag == 3)&#123;// 告诉服务端我对谁私发dos.writeUTF(selectName.trim());&#125;dos.flush();&#125; catch (Exception e1) &#123;e1.printStackTrace();&#125;&#125;smsSend.setText(null);break;&#125;&#125;&#125;\n\n客户端socket处理线程：\n1234567891011121314151617181920212223242526272829303132333435363738class ClientReader extends Thread &#123;private Socket socket;private ClientChat clientChat ;public ClientReader(ClientChat clientChat, Socket socket) &#123;this.clientChat = clientChat;this.socket = socket;&#125;@Overridepublic void run() &#123;try &#123;DataInputStream dis = new DataInputStream(socket.getInputStream());/** 循环一直等待客户端的消息 */while(true)&#123;/** 读取当前的消息类型 ：登录,群发,私聊 , @消息 */int flag = dis.readInt();if(flag == 1)&#123;// 在线人数消息回来了String nameDatas = dis.readUTF();// 展示到在线人数的界面String[] names = nameDatas.split(Constants.SPILIT);clientChat.onLineUsers.setListData(names);&#125;else if(flag == 2)&#123;//群发,私聊 , @消息 都是直接显示的。String msg = dis.readUTF() ;clientChat.smsContent.append(msg);// 让消息界面滾動到底端clientChat.smsContent.setCaretPosition(clientChat.smsContent.getText().length());&#125;&#125;&#125; catch (Exception e) &#123;e.printStackTrace();&#125;&#125;&#125;\n\n小结\n此处实现了客户端发送群聊消息，@消息，以及私聊消息。\n如果直接点击发送，默认发送群聊消息\n如果选中右侧在线列表某个用户，默认发送@消息\n如果选中右侧在线列表某个用户，然后选择右下侧私聊按钮默，认发送私聊消息。\n\n第四章 JAVA NIO深入剖析在讲解利用NIO实现通信架构之前，我们需要先来了解一下NIO的基本特点和使用。\n4.1 Java NIO 基本介绍\nJava NIO（New IO）也有人称之为 java non-blocking IO是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面 向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。NIO可以理解为非阻塞IO,传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，而NIO中可以配置socket为非阻塞模式。\nNIO 相关类都被放在 java.nio 包及子包下，并且对原 java.io 包中的很多类进行改写。\nNIO 有三大核心部分： Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)\nJava NIO 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。\n通俗理解：NIO 是可以做到用一个线程来处理多个操作的。假设有 1000 个请求过来,根据实际情况，可以分配20 或者 80个线程来处理。不像之前的阻塞 IO 那样，非得分配 1000 个。\n\n4.2 NIO 和 BIO 的比较\nBIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I&#x2F;O 的效率比流 I&#x2F;O 高很多\nBIO 是阻塞的，NIO 则是非阻塞的\nBIO 基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道\n\n\n\n\nNIO\nBIO\n\n\n\n面向缓冲区（Buffer）\n面向流（Stream）\n\n\n非阻塞（Non Blocking IO）\n阻塞IO(Blocking IO)\n\n\n选择器（Selectors）\n\n\n\n4.3 NIO 三大核心原理示意图NIO 有三大核心部分：Channel( 通道) ，Buffer( 缓冲区), Selector( 选择器)\nBuffer缓冲区缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer API更加容易操作和管理。\nChannel（通道）Java NIO的通道类似流，但又有些不同：既可以从通道中读取数据，又可以写数据到通道。但流的（input或output)读写通常是单向的。 通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。\nSelector选择器Selector是 一个Java NIO组件，可以能够检查一个或多个 NIO 通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率\n\n\n每个 channel 都会对应一个 Buffer\n一个线程对应Selector ， 一个Selector对应多个 channel(连接)\n程序切换到哪个 channel 是由事件决定的\nSelector 会根据不同的事件，在各个通道上切换\nBuffer 就是一个内存块 ， 底层是一个数组\n数据的读取写入是通过 Buffer完成的 , BIO 中要么是输入流，或者是输出流, 不能双向，但是 NIO 的 Buffer 是可以读也可以写。\nJava NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取 用于连接 IO 设备的通道以及用于容纳数据的缓冲 区。然后操作缓冲区，对数据进行处理。简而言之，Channel 负责传输， Buffer 负责存取数据\n\n4.4 NIO核心一：缓冲区(Buffer)缓冲区（Buffer）一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写入通道中的\n\nBuffer 类及其子类Buffer 就像一个数组，可以保存多个相同类型的数据。根 据数据类型不同 ，有以下 Buffer 常用子类：\n\nByteBuffer\nCharBuffer\nShortBuffer\nIntBuffer\nLongBuffer\nFloatBuffer\nDoubleBuffer\n\n上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象：\n1static XxxBuffer allocate(int capacity) : 创建一个容量为capacity 的 XxxBuffer 对象\n\n缓冲区的基本属性**Buffer 中的重要概念： **\n\n容量 (capacity) ：作为一个内存块，Buffer具有一定的固定大小，也称为”容量”，缓冲区容量不能为负，并且创建后不能更改。\n**限制 (limit)**：表示缓冲区中可以操作数据的大小（limit 后数据不能进行读写）。缓冲区的限制不能为负，并且不能大于其容量。 写入模式，限制等于buffer的容量。读取模式下，limit等于写入的数据量。\n**位置 (position)**：下一个要读取或写入的数据的索引。缓冲区的位置不能为 负，并且不能大于其限制\n标记 (mark)与重置 (reset)：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position.\n标记、位置、限制、容量遵守以下不变式： 0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity \n图示:\n\n\nBuffer常见方法123456789101112Buffer clear() 清空缓冲区并返回对缓冲区的引用Buffer flip() 为 将缓冲区的界限设置为当前位置，并将当前位置充值为 0int capacity() 返回 Buffer 的 capacity 大小boolean hasRemaining() 判断缓冲区中是否还有元素int limit() 返回 Buffer 的界限(limit) 的位置Buffer limit(int n) 将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象Buffer mark() 对缓冲区设置标记int position() 返回缓冲区的当前位置 positionBuffer position(int n) 将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象int remaining() 返回 position 和 limit 之间的元素个数Buffer reset() 将位置 position 转到以前设置的 mark 所在的位置Buffer rewind() 将位置设为为 0， 取消设置的 mark\n\n缓冲区的数据操作12345678910Buffer 所有子类提供了两个用于数据操作的方法：get()put() 方法取获取 Buffer中的数据get() ：读取单个字节get(byte[] dst)：批量读取多个字节到 dst 中get(int index)：读取指定索引位置的字节(不会移动 position)    放到 入数据到 Buffer 中 中put(byte b)：将给定单个字节写入缓冲区的当前位置put(byte[] src)：将 src 中的字节写入缓冲区的当前位置put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)\n\n使用Buffer读写数据一般遵循以下四个步骤：\n\n1.写入数据到Buffer\n2.调用flip()方法，转换为读取模式\n3.从Buffer中读取数据\n4.调用buffer.clear()方法或者buffer.compact()方法清除缓冲区\n\n案例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class TestBuffer &#123;   @Test   public void test3()&#123;      //分配直接缓冲区      ByteBuffer buf = ByteBuffer.allocateDirect(1024);      System.out.println(buf.isDirect());   &#125;      @Test   public void test2()&#123;      String str = &quot;itheima&quot;;            ByteBuffer buf = ByteBuffer.allocate(1024);            buf.put(str.getBytes());            buf.flip();            byte[] dst = new byte[buf.limit()];      buf.get(dst, 0, 2);      System.out.println(new String(dst, 0, 2));      System.out.println(buf.position());            //mark() : 标记      buf.mark();            buf.get(dst, 2, 2);      System.out.println(new String(dst, 2, 2));      System.out.println(buf.position());            //reset() : 恢复到 mark 的位置      buf.reset();      System.out.println(buf.position());            //判断缓冲区中是否还有剩余数据      if(buf.hasRemaining())&#123;         //获取缓冲区中可以操作的数量         System.out.println(buf.remaining());      &#125;   &#125;       @Test   public void test1()&#123;      String str = &quot;itheima&quot;;      //1. 分配一个指定大小的缓冲区      ByteBuffer buf = ByteBuffer.allocate(1024);      System.out.println(&quot;-----------------allocate()----------------&quot;);      System.out.println(buf.position());      System.out.println(buf.limit());      System.out.println(buf.capacity());            //2. 利用 put() 存入数据到缓冲区中      buf.put(str.getBytes());      System.out.println(&quot;-----------------put()----------------&quot;);      System.out.println(buf.position());      System.out.println(buf.limit());      System.out.println(buf.capacity());            //3. 切换读取数据模式      buf.flip();      System.out.println(&quot;-----------------flip()----------------&quot;);      System.out.println(buf.position());      System.out.println(buf.limit());      System.out.println(buf.capacity());            //4. 利用 get() 读取缓冲区中的数据      byte[] dst = new byte[buf.limit()];      buf.get(dst);      System.out.println(new String(dst, 0, dst.length));      System.out.println(&quot;-----------------get()----------------&quot;);      System.out.println(buf.position());      System.out.println(buf.limit());      System.out.println(buf.capacity());      //5. rewind() : 可重复读      buf.rewind();      System.out.println(&quot;-----------------rewind()----------------&quot;);      System.out.println(buf.position());      System.out.println(buf.limit());      System.out.println(buf.capacity());            //6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态      buf.clear();      System.out.println(&quot;-----------------clear()----------------&quot;);      System.out.println(buf.position());      System.out.println(buf.limit());      System.out.println(buf.capacity());      System.out.println((char)buf.get());         &#125;&#125;\n\n直接与非直接缓冲区什么是直接内存与非直接内存\n根据官方文档的描述：\nbyte byffer可以是两种类型，一种是基于直接内存（也就是非堆内存）；另一种是非直接内存（也就是堆内存）。对于直接内存来说，JVM将会在IO操作上具有更高的性能，因为它直接作用于本地系统的IO操作。而非直接内存，也就是堆内存中的数据，如果要作IO操作，会先从本进程内存复制到直接内存，再利用本地IO处理。\n从数据流的角度，非直接内存是下面这样的作用链：\n1本地IO--&gt;直接内存--&gt;非直接内存--&gt;直接内存--&gt;本地IO\n\n而直接内存是：\n1本地IO--&gt;直接内存--&gt;本地IO\n\n很明显，在做IO处理时，比如网络发送大量数据时，直接内存会具有更高的效率。直接内存使用allocateDirect创建，但是它比申请普通的堆内存需要耗费更高的性能。不过，这部分的数据是在JVM之外的，因此它不会占用应用的内存。所以呢，当你有很大的数据要缓存，并且它的生命周期又很长，那么就比较适合使用直接内存。只是一般来说，如果不是能带来很明显的性能提升，还是推荐直接使用堆内存。字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect()  方法来确定。\n使用场景\n\n1 有很大的数据需要存储，它的生命周期又很长\n2 适合频繁的IO操作，比如网络并发场景\n\n4.5 NIO核心二：通道(Channel)通道Channe概述通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互。\n1、 NIO 的通道类似于流，但有些区别如下：\n\n通道可以同时进行读写，而流只能读或者只能写\n通道可以实现异步读写数据\n通道可以从缓冲读数据，也可以写数据到缓冲:\n\n2、BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel) 是双向的，可以读操作，也可以写操作。\n3、Channel 在 NIO 中是一个接口\n1public interface Channel extends Closeable&#123;&#125;\n\n常用的Channel实现类\nFileChannel：用于读取、写入、映射和操作文件的通道。\nDatagramChannel：通过 UDP 读写网络中的数据通道。\nSocketChannel：通过 TCP 读写网络中的数据。\nServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】\n\nFileChannel 类获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：\n\nFileInputStream\nFileOutputStream\nRandomAccessFile\nDatagramSocket\nSocket\nServerSocket获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道\n\nFileChannel的常用方法123456789int read(ByteBuffer dst) 从 从  Channel 到 中读取数据到  ByteBufferlong  read(ByteBuffer[] dsts) 将 将  Channel 到 中的数据“分散”到  ByteBuffer[]int  write(ByteBuffer src) 将 将  ByteBuffer 到 中的数据写入到  Channellong write(ByteBuffer[] srcs) 将 将  ByteBuffer[] 到 中的数据“聚集”到  Channellong position() 返回此通道的文件位置FileChannel position(long p) 设置此通道的文件位置long size() 返回此通道的文件的当前大小FileChannel truncate(long s) 将此通道的文件截取为给定大小void force(boolean metaData) 强制将所有对此通道的文件更新写入到存储设备中\n\n案例1-本地文件写数据需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 “hello,黑马Java程序员！” 写入到 data.txt 中.\n1234567891011121314151617181920212223242526272829303132package com.itheima;import org.junit.Test;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.OutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class ChannelTest &#123;    @Test    public void write()&#123;        try &#123;            // 1、字节输出流通向目标文件            FileOutputStream fos = new FileOutputStream(&quot;data01.txt&quot;);            // 2、得到字节输出流对应的通道Channel            FileChannel channel = fos.getChannel();            // 3、分配缓冲区            ByteBuffer buffer = ByteBuffer.allocate(1024);            buffer.put(&quot;hello,黑马Java程序员！&quot;.getBytes());            // 4、把缓冲区切换成写出模式            buffer.flip();            channel.write(buffer);            channel.close();            System.out.println(&quot;写数据到文件中！&quot;);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n案例2-本地文件读数据需求：使用前面学习后的 ByteBuffer(缓冲) 和 FileChannel(通道)， 将 data01.txt 中的数据读入到程序，并显示在控制台屏幕\n123456789101112131415161718public class ChannelTest &#123;    @Test    public void read() throws Exception &#123;        // 1、定义一个文件字节输入流与源文件接通        FileInputStream is = new FileInputStream(&quot;data01.txt&quot;);        // 2、需要得到文件字节输入流的文件通道        FileChannel channel = is.getChannel();        // 3、定义一个缓冲区        ByteBuffer buffer = ByteBuffer.allocate(1024);        // 4、读取数据到缓冲区        channel.read(buffer);        buffer.flip();        // 5、读取出缓冲区中的数据并输出即可        String rs = new String(buffer.array(),0,buffer.remaining());        System.out.println(rs);    &#125;\n\n案例3-使用Buffer完成文件复制使用 FileChannel(通道) ，完成文件的拷贝。\n12345678910111213141516171819202122232425262728293031@Testpublic void copy() throws Exception &#123;    // 源文件    File srcFile = new File(&quot;C:\\\\Users\\\\dlei\\\\Desktop\\\\BIO,NIO,AIO\\\\文件\\\\壁纸.jpg&quot;);    File destFile = new File(&quot;C:\\\\Users\\\\dlei\\\\Desktop\\\\BIO,NIO,AIO\\\\文件\\\\壁纸new.jpg&quot;);    // 得到一个字节字节输入流    FileInputStream fis = new FileInputStream(srcFile);    // 得到一个字节输出流    FileOutputStream fos = new FileOutputStream(destFile);    // 得到的是文件通道    FileChannel isChannel = fis.getChannel();    FileChannel osChannel = fos.getChannel();    // 分配缓冲区    ByteBuffer buffer = ByteBuffer.allocate(1024);    while(true)&#123;        // 必须先清空缓冲然后再写入数据到缓冲区        buffer.clear();        // 开始读取一次数据        int flag = isChannel.read(buffer);        if(flag == -1)&#123;            break;        &#125;        // 已经读取了数据 ，把缓冲区的模式切换成可读模式        buffer.flip();        // 把数据写出到        osChannel.write(buffer);    &#125;    isChannel.close();    osChannel.close();    System.out.println(&quot;复制完成！&quot;);&#125;\n\n案例4-分散 (Scatter) 和聚集 (Gather)分散读取（Scatter ）:是指把Channel通道的数据读入到多个缓冲区中去\n聚集写入（Gathering ）是指将多个 Buffer 中的数据“聚集”到 Channel。\n1234567891011121314151617181920212223242526272829//分散和聚集@Testpublic void test() throws IOException&#123;RandomAccessFile raf1 = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);//1. 获取通道FileChannel channel1 = raf1.getChannel();//2. 分配指定大小的缓冲区ByteBuffer buf1 = ByteBuffer.allocate(100);ByteBuffer buf2 = ByteBuffer.allocate(1024);//3. 分散读取ByteBuffer[] bufs = &#123;buf1, buf2&#125;;channel1.read(bufs);for (ByteBuffer byteBuffer : bufs) &#123;byteBuffer.flip();&#125;System.out.println(new String(bufs[0].array(), 0, bufs[0].limit()));System.out.println(&quot;-----------------&quot;);System.out.println(new String(bufs[1].array(), 0, bufs[1].limit()));//4. 聚集写入RandomAccessFile raf2 = new RandomAccessFile(&quot;2.txt&quot;, &quot;rw&quot;);FileChannel channel2 = raf2.getChannel();channel2.write(bufs);&#125;\n\n案例5-transferFrom()从目标通道中去复制原通道数据\n12345678910111213@Testpublic void test02() throws Exception &#123;    // 1、字节输入管道    FileInputStream is = new FileInputStream(&quot;data01.txt&quot;);    FileChannel isChannel = is.getChannel();    // 2、字节输出流管道    FileOutputStream fos = new FileOutputStream(&quot;data03.txt&quot;);    FileChannel osChannel = fos.getChannel();    // 3、复制    osChannel.transferFrom(isChannel,isChannel.position(),isChannel.size());    isChannel.close();    osChannel.close();&#125;\n\n案例6-transferTo()把原通道数据复制到目标通道\n12345678910111213@Testpublic void test02() throws Exception &#123;    // 1、字节输入管道    FileInputStream is = new FileInputStream(&quot;data01.txt&quot;);    FileChannel isChannel = is.getChannel();    // 2、字节输出流管道    FileOutputStream fos = new FileOutputStream(&quot;data04.txt&quot;);    FileChannel osChannel = fos.getChannel();    // 3、复制    isChannel.transferTo(isChannel.position() , isChannel.size() , osChannel);    isChannel.close();    osChannel.close();&#125;\n\n4.6 NIO核心三：选择器(Selector)选择器(Selector)概述选择器（Selector） 是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心\n\n\nJava 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)\nSelector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。\n只有在 连接&#x2F;通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程\n避免了多线程之间的上下文切换导致的开销\n\n选择 器（Selector）的应用创建 Selector ：通过调用 Selector.open() 方法创建一个 Selector。\n1Selector selector = Selector.open();\n\n向选择器注册通道：SelectableChannel.register(Selector sel, int ops)\n12345678910//1. 获取通道ServerSocketChannel ssChannel = ServerSocketChannel.open();//2. 切换非阻塞模式ssChannel.configureBlocking(false);//3. 绑定连接ssChannel.bind(new InetSocketAddress(9898));//4. 获取选择器Selector selector = Selector.open();//5. 将通道注册到选择器上, 并且指定“监听接收事件”ssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey  的四个常量 表示）：\n\n读 : SelectionKey.OP_READ （1）\n写 : SelectionKey.OP_WRITE （4）\n连接 : SelectionKey.OP_CONNECT （8）\n接收 : SelectionKey.OP_ACCEPT （16）\n若注册时不止监听一个事件，则可以使用“位或”操作符连接。\n\n1int interestSet = SelectionKey.OP_READ|SelectionKey.OP_WRITE \n\n4.7 NIO非阻塞式网络通信原理分析Selector 示意图和特点说明Selector可以实现： 一个 I&#x2F;O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I&#x2F;O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。\n\n服务端流程\n1、当客户端连接服务端时，服务端会通过 ServerSocketChannel 得到 SocketChannel：1. 获取通道\n1ServerSocketChannel ssChannel = ServerSocketChannel.open();\n\n2、切换非阻塞模式\n1ssChannel.configureBlocking(false);\n\n3、绑定连接\n1ssChannel.bind(new InetSocketAddress(9999));\n\n4、 获取选择器\n1Selector selector = Selector.open();\n\n5、 将通道注册到选择器上, 并且指定“监听接收事件”\n1ssChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n6、轮询式的获取选择器上已经“准备就绪”的事件\n\n\n\n123456789101112131415161718192021222324252627282930313233//轮询式的获取选择器上已经“准备就绪”的事件 while (selector.select() &gt; 0) &#123;        System.out.println(&quot;轮一轮&quot;);        //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();        while (it.hasNext()) &#123;            //8. 获取准备“就绪”的是事件            SelectionKey sk = it.next();            //9. 判断具体是什么事件准备就绪            if (sk.isAcceptable()) &#123;                //10. 若“接收就绪”，获取客户端连接                SocketChannel sChannel = ssChannel.accept();                //11. 切换非阻塞模式                sChannel.configureBlocking(false);                //12. 将该通道注册到选择器上                sChannel.register(selector, SelectionKey.OP_READ);            &#125; else if (sk.isReadable()) &#123;                //13. 获取当前选择器上“读就绪”状态的通道                SocketChannel sChannel = (SocketChannel) sk.channel();                //14. 读取数据                ByteBuffer buf = ByteBuffer.allocate(1024);                int len = 0;                while ((len = sChannel.read(buf)) &gt; 0) &#123;                    buf.flip();                    System.out.println(new String(buf.array(), 0, len));                    buf.clear();                &#125;            &#125;            //15. 取消选择键 SelectionKey            it.remove();        &#125;    &#125;&#125;\n\n\n客户端流程\n\n获取通道\n1SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));\n\n\n\n切换非阻塞模式\n1sChannel.configureBlocking(false);\n\n\n\n分配指定大小的缓冲区\n\n  1ByteBuffer buf = ByteBuffer.allocate(1024);\n\n\n发送数据给服务端\n\n1234567891011Scanner scan = new Scanner(System.in);while(scan.hasNext())&#123;String str = scan.nextLine();buf.put((new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(System.currentTimeMillis())+ &quot;\\n&quot; + str).getBytes());buf.flip();sChannel.write(buf);buf.clear();&#125;//关闭通道sChannel.close();\n\n4.8 NIO非阻塞式网络通信入门案例需求：服务端接收客户端的连接请求，并接收多个客户端发送过来的事件。\n代码案例\n\n123456789101112131415161718192021222324252627/** 客户端*/public class Client &#123;public static void main(String[] args) throws Exception &#123;//1. 获取通道SocketChannel sChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));//2. 切换非阻塞模式sChannel.configureBlocking(false);//3. 分配指定大小的缓冲区ByteBuffer buf = ByteBuffer.allocate(1024);//4. 发送数据给服务端Scanner scan = new Scanner(System.in);while(scan.hasNext())&#123;String str = scan.nextLine();buf.put((new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;).format(System.currentTimeMillis())+ &quot;\\n&quot; + str).getBytes());  buf.flip();  sChannel.write(buf);  buf.clear();  &#125;  //5. 关闭通道  sChannel.close();  &#125;  &#125;\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**服务端*/public class Server &#123;   public static void main(String[] args) throws IOException &#123;       //1. 获取通道       ServerSocketChannel ssChannel = ServerSocketChannel.open();       //2. 切换非阻塞模式       ssChannel.configureBlocking(false);       //3. 绑定连接       ssChannel.bind(new InetSocketAddress(9999));       //4. 获取选择器       Selector selector = Selector.open();       //5. 将通道注册到选择器上, 并且指定“监听接收事件”       ssChannel.register(selector, SelectionKey.OP_ACCEPT);       //6. 轮询式的获取选择器上已经“准备就绪”的事件       while (selector.select() &gt; 0) &#123;           System.out.println(&quot;轮一轮&quot;);           //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”           Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();           while (it.hasNext()) &#123;               //8. 获取准备“就绪”的是事件               SelectionKey sk = it.next();               //9. 判断具体是什么事件准备就绪               if (sk.isAcceptable()) &#123;                   //10. 若“接收就绪”，获取客户端连接                   SocketChannel sChannel = ssChannel.accept();                   //11. 切换非阻塞模式                   sChannel.configureBlocking(false);                   //12. 将该通道注册到选择器上                   sChannel.register(selector, SelectionKey.OP_READ);               &#125; else if (sk.isReadable()) &#123;                   //13. 获取当前选择器上“读就绪”状态的通道                   SocketChannel sChannel = (SocketChannel) sk.channel();                   //14. 读取数据                   ByteBuffer buf = ByteBuffer.allocate(1024);                   int len = 0;                   while ((len = sChannel.read(buf)) &gt; 0) &#123;                       buf.flip();                       System.out.println(new String(buf.array(), 0, len));                       buf.clear();                   &#125;               &#125;               //15. 取消选择键 SelectionKey               it.remove();           &#125;       &#125;   &#125;&#125;\n\n4.9  NIO 网络编程应用实例-群聊系统目标  需求:进一步理解 NIO 非阻塞网络编程机制，实现多人群聊\n\n编写一个 NIO 群聊系统，实现客户端与客户端的通信需求（非阻塞）\n服务器端：可以监测用户上线，离线，并实现消息转发功能\n客户端：通过 channel 可以无阻塞发送消息给其它所有客户端用户，同时可以接受其它客户端用户通过服务端转发来的消息\n\n服务端代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class Server &#123;    //定义属性    private Selector selector;    private ServerSocketChannel ssChannel;    private static final int PORT = 9999;    //构造器    //初始化工作    public Server() &#123;        try &#123;            // 1、获取通道            ssChannel = ServerSocketChannel.open();            // 2、切换为非阻塞模式            ssChannel.configureBlocking(false);            // 3、绑定连接的端口            ssChannel.bind(new InetSocketAddress(PORT));            // 4、获取选择器Selector            selector = Selector.open();            // 5、将通道都注册到选择器上去，并且开始指定监听接收事件            ssChannel.register(selector , SelectionKey.OP_ACCEPT);        &#125;catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //监听    public void listen() &#123;        System.out.println(&quot;监听线程: &quot; + Thread.currentThread().getName());        try &#123;            while (selector.select() &gt; 0)&#123;                System.out.println(&quot;开始一轮事件处理~~~&quot;);                // 7、获取选择器中的所有注册的通道中已经就绪好的事件                Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();                // 8、开始遍历这些准备好的事件                while (it.hasNext())&#123;                    // 提取当前这个事件                    SelectionKey sk = it.next();                    // 9、判断这个事件具体是什么                    if(sk.isAcceptable())&#123;                        // 10、直接获取当前接入的客户端通道                        SocketChannel schannel = ssChannel.accept();                        // 11 、切换成非阻塞模式                        schannel.configureBlocking(false);                        // 12、将本客户端通道注册到选择器                        System.out.println(schannel.getRemoteAddress() + &quot; 上线 &quot;);                        schannel.register(selector , SelectionKey.OP_READ);                        //提示                    &#125;else if(sk.isReadable())&#123;                        //处理读 (专门写方法..)                        readData(sk);                    &#125;                    it.remove(); // 处理完毕之后需要移除当前事件                &#125;            &#125;        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;finally &#123;            //发生异常处理....        &#125;    &#125;    //读取客户端消息    private void readData(SelectionKey key) &#123;        //取到关联的channle        SocketChannel channel = null;        try &#123;           //得到channel            channel = (SocketChannel) key.channel();            //创建buffer            ByteBuffer buffer = ByteBuffer.allocate(1024);            int count = channel.read(buffer);            //根据count的值做处理            if(count &gt; 0) &#123;                //把缓存区的数据转成字符串                String msg = new String(buffer.array());                //输出该消息                System.out.println(&quot;form 客户端: &quot; + msg);                //向其它的客户端转发消息(去掉自己), 专门写一个方法来处理                sendInfoToOtherClients(msg, channel);            &#125;        &#125;catch (IOException e) &#123;            try &#123;                System.out.println(channel.getRemoteAddress() + &quot; 离线了..&quot;);                e.printStackTrace();                //取消注册                key.cancel();                //关闭通道                channel.close();            &#125;catch (IOException e2) &#123;                e2.printStackTrace();;            &#125;        &#125;    &#125;    //转发消息给其它客户(通道)    private void sendInfoToOtherClients(String msg, SocketChannel self ) throws  IOException&#123;        System.out.println(&quot;服务器转发消息中...&quot;);        System.out.println(&quot;服务器转发数据给客户端线程: &quot; + Thread.currentThread().getName());        //遍历 所有注册到selector 上的 SocketChannel,并排除 self        for(SelectionKey key: selector.keys()) &#123;            //通过 key  取出对应的 SocketChannel            Channel targetChannel = key.channel();            //排除自己            if(targetChannel instanceof  SocketChannel &amp;&amp; targetChannel != self) &#123;                //转型                SocketChannel dest = (SocketChannel)targetChannel;                //将msg 存储到buffer                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());                //将buffer 的数据写入 通道                dest.write(buffer);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        //创建服务器对象        Server groupChatServer = new Server();        groupChatServer.listen();    &#125;&#125;\n\n客户端代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.itheima.chat;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;public class Client &#123;    //定义相关的属性    private final String HOST = &quot;127.0.0.1&quot;; // 服务器的ip    private final int PORT = 9999; //服务器端口    private Selector selector;    private SocketChannel socketChannel;    private String username;    //构造器, 完成初始化工作    public Client() throws IOException &#123;        selector = Selector.open();        //连接服务器        socketChannel = socketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, PORT));        //设置非阻塞        socketChannel.configureBlocking(false);        //将channel 注册到selector        socketChannel.register(selector, SelectionKey.OP_READ);        //得到username        username = socketChannel.getLocalAddress().toString().substring(1);        System.out.println(username + &quot; is ok...&quot;);    &#125;    //向服务器发送消息    public void sendInfo(String info) &#123;        info = username + &quot; 说：&quot; + info;        try &#123;            socketChannel.write(ByteBuffer.wrap(info.getBytes()));        &#125;catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //读取从服务器端回复的消息    public void readInfo() &#123;        try &#123;            int readChannels = selector.select();            if(readChannels &gt; 0) &#123;//有可以用的通道                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    if(key.isReadable()) &#123;                        //得到相关的通道                       SocketChannel sc = (SocketChannel) key.channel();                       //得到一个Buffer                        ByteBuffer buffer = ByteBuffer.allocate(1024);                        //读取                        sc.read(buffer);                        //把读到的缓冲区的数据转成字符串                        String msg = new String(buffer.array());                        System.out.println(msg.trim());                    &#125;                &#125;                iterator.remove(); //删除当前的selectionKey, 防止重复操作            &#125; else &#123;                //System.out.println(&quot;没有可以用的通道...&quot;);            &#125;        &#125;catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        //启动我们客户端        Client chatClient = new Client();        //启动一个线程, 每个3秒，读取从服务器发送数据        new Thread() &#123;            public void run() &#123;                while (true) &#123;                    chatClient.readInfo();                    try &#123;                        Thread.currentThread().sleep(3000);                    &#125;catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;.start();        //发送数据给服务器端        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextLine()) &#123;            String s = scanner.nextLine();            chatClient.sendInfo(s);        &#125;    &#125;\n\n\n\n第五章 JAVA AIO深入剖析5.1 AIO编程\nJava AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。\n\n12345AIO异步非阻塞，基于NIO的，可以称之为NIO2.0    BIO                   NIO                              AIO        Socket                SocketChannel                    AsynchronousSocketChannelServerSocket          ServerSocketChannel       AsynchronousServerSocketChannel\n\n  与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可, 这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区,对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序\n  即可以理解为，read&#x2F;write方法都是异步的，完成后会主动调用回调函数。在JDK1.7中，这部分内容被称作NIO.2，主要在Java.nio.channels包下增加了下面四个异步通道：\n1234AsynchronousSocketChannelAsynchronousServerSocketChannelAsynchronousFileChannelAsynchronousDatagramChannel\n\n  BIO、NIO、AIO：\n\nJava BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。\nJava NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。\nJava AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。\n\n  BIO、NIO、AIO适用场景分析:\n\nBIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。\nNIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。\nAIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。Netty!\n\n","slug":"BIO、NIO、AIO","date":"2023-08-25T10:49:36.000Z","categories_index":"Java","tags_index":"BIO,NIO","author_index":"正茂"},{"id":"df2bd4a3cae38597aabb2824e73aaab3","title":"每日新闻60s","content":"\n","slug":"60s","date":"2023-08-25T10:49:36.000Z","categories_index":"实用","tags_index":"新闻","author_index":"正茂"},{"id":"eaa06ed45453f389a4efa6b3c6981c30","title":"SpringCloud 实用篇 01","content":"SpringCloud011.认识微服务随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？\n1.0.学习目标了解微服务架构的优缺点\n1.1.单体架构单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。\n\n单体架构的优缺点如下：\n优点：\n\n架构简单\n部署成本低\n\n缺点：\n\n耦合度高（维护困难、升级困难）\n\n1.2.分布式架构分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。\n\n分布式架构的优缺点：\n优点：\n\n降低服务耦合\n有利于服务升级和拓展\n\n缺点：\n\n服务调用关系错综复杂\n\n分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：\n\n服务拆分的粒度如何界定？\n服务之间如何调用？\n服务的调用关系如何管理？\n\n人们需要制定一套行之有效的标准来约束分布式架构。\n1.3.微服务微服务的架构特征：\n\n单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责\n自治：团队独立、技术独立、数据独立，独立部署和交付\n面向服务：服务提供统一标准的接口，与语言和技术无关\n隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n\n微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。\n因此，可以认为****微服务是一种经过良好架构设计的分布式架构方案 。\n但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。\n其中在Java领域最引人注目的就是SpringCloud提供的方案了。\n1.4.SpringCloudSpringCloud是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。\nSpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。\n其中常见的组件包括：\n\n另外，SpringCloud底层是依赖于SpringBoot的，并且有版本的兼容关系，如下：\n\n我们课堂学习的版本是 Hoxton.SR10，因此对应的SpringBoot版本是2.3.x版本。\n1.5.总结\n单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统\n分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝\n微服务：一种良好的分布式架构方案①优点：拆分粒度更小、服务更独立、耦合度更低②缺点：架构非常复杂，运维、监控、部署难度提高\nSpringCloud是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件\n\n2.服务拆分和远程调用任何分布式架构都离不开服务的拆分，微服务也是一样。\n2.1.服务拆分原则这里我总结了微服务拆分时的几个原则：\n\n不同微服务，不要重复开发相同业务\n微服务数据独立，不要访问其它微服务的数据库\n微服务可以将自己的业务暴露为接口，供其它微服务调用\n\n\n2.2.服务拆分示例以课前资料中的微服务cloud-demo为例，其结构如下：\n\ncloud-demo：父工程，管理依赖\n\norder-service：订单微服务，负责订单相关业务\nuser-service：用户微服务，负责用户相关业务\n\n要求：\n\n订单微服务和用户微服务都必须有各自的数据库，相互独立\n订单服务和用户服务都对外暴露Restful的接口\n订单服务如果需要查询用户信息，只能调用用户服务的Restful接口，不能查询用户数据库\n\n2.2.1.导入Sql语句首先，将课前资料提供的cloud-order.sql和cloud-user.sql导入到mysql中：\n\ncloud-user表中初始数据如下：\n\ncloud-order表中初始数据如下：\n\ncloud-order表中持有cloud-user表中的id字段。\n2.2.2.导入demo工程用IDEA导入课前资料提供的Demo：\n\n项目结构如下：\n\n导入后，会在IDEA右下角出现弹窗：\n\n点击弹窗，然后按下图选择：\n\n会出现这样的菜单：\n\n配置下项目使用的JDK：\n\n2.3.实现远程调用案例在order-service服务中，有一个根据id查询订单的接口：\n\n根据id查询订单，返回值是Order对象，如图：\n\n其中的user为null\n在user-service中有一个根据id查询用户的接口：\n\n查询的结果如图：\n\n2.3.1.案例需求：修改order-service中的根据id查询订单业务，要求在查询订单的同时，根据订单中包含的userId查询出用户信息，一起返回。\n因此，我们需要在order-service中 向user-service发起一个http的请求，调用http://localhost:8081/user/{userId}这个接口。\n大概的步骤是这样的：\n\n注册一个RestTemplate的实例到Spring容器\n修改order-service服务中的OrderService类中的queryOrderById方法，根据Order对象中的userId查询User\n将查询的User填充到Order对象，一起返回\n\n2.3.2.注册RestTemplate首先，我们在order-service服务中的OrderApplication启动类中，注册RestTemplate实例：\n123456789101112131415161718192021package cn.itcast.order;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@MapperScan(&quot;cn.itcast.order.mapper&quot;)@SpringBootApplicationpublic class OrderApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OrderApplication.class, args);    &#125;    @Bean    public RestTemplate restTemplate() &#123;        return new RestTemplate();    &#125;&#125;\n\n2.3.3.实现远程调用修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法：\n\n2.4.提供者与消费者在服务调用关系中，会有两个不同的角色：\n服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）\n服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）\n\n但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。\n如果服务A调用了服务B，而服务B又调用了服务C，服务B的角色是什么？\n\n对于A调用B的业务而言：A是服务消费者，B是服务提供者\n对于B调用C的业务而言：B是服务消费者，C是服务提供者\n\n因此，服务B既可以是服务提供者，也可以是服务消费者。\n3.Eureka注册中心假如我们的服务提供者user-service部署了多个实例，如图：\n\n大家思考几个问题：\n\norder-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？\n有多个user-service实例地址，order-service调用时该如何选择？\norder-service如何得知某个user-service实例是否依然健康，是不是已经宕机？\n\n3.1.Eureka的结构和作用这些问题都需要利用SpringCloud中的注册中心来解决，其中最广为人知的注册中心就是Eureka，其结构如下：\n\n回答之前的各个问题。\n问题1：order-service如何得知user-service实例地址？\n获取地址信息的流程如下：\n\nuser-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册\neureka-server保存服务名称到服务实例地址列表的映射关系\norder-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取\n\n问题2：order-service如何从多个user-service实例中选择具体的实例？\n\norder-service从实例列表中利用负载均衡算法选中一个实例地址\n向该实例地址发起远程调用\n\n问题3：order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？\n\nuser-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳\n当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除\norder-service拉取服务时，就能将故障实例排除了\n\n\n\n\n\n\n\n\n\n\n注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端\n因此，接下来我们动手实践的步骤包括：\n\n3.2.搭建eureka-server首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务\n3.2.1.创建eureka-server服务在cloud-demo父工程下，创建一个子模块：\n\n填写模块信息：\n\n然后填写服务信息：\n\n3.2.2.引入eureka依赖引入SpringCloud为eureka提供的starter依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;\n\n3.2.3.编写启动类给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：\n12345678910111213package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaApplication.class, args);    &#125;&#125;\n\n3.2.4.编写配置文件编写一个application.yml文件，内容如下：\n123456789server:  port: 10086spring:  application:    name: eureka-servereureka:  client:    service-url:       defaultZone: http://127.0.0.1:10086/eureka\n\n3.2.5.启动服务启动微服务，然后在浏览器访问：http://127.0.0.1:10086\n看到下面结果应该是成功了：\n\n3.3.服务注册下面，我们将user-service注册到eureka-server中去。\n1）引入依赖在user-service的pom文件中，引入下面的eureka-client依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）配置文件在user-service中，修改application.yml文件，添加服务名称、eureka地址：\n1234567spring:  application:    name: userserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka\n\n3）启动多个user-service实例为了演示一个服务有多个实例的场景，我们添加一个SpringBoot的启动配置，再启动一个user-service。\n首先，复制原来的user-service启动配置：\n\n然后，在弹出的窗口中，填写信息：\n\n现在，SpringBoot窗口会出现两个user-service启动配置：\n\n不过，第一个是8081端口，第二个是8082端口。\n启动两个user-service实例：\n\n查看eureka-server管理页面：\n\n3.4.服务发现下面，我们将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。\n1）引入依赖之前说过，服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。\n在order-service的pom文件中，引入下面的eureka-client依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）配置文件服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：\n在order-service中，修改application.yml文件，添加服务名称、eureka地址：\n1234567spring:  application:    name: orderserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka\n\n3）服务拉取和负载均衡最后，我们要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。\n不过这些动作不用我们去做，只需要添加一些注解即可。\n在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：\n\n修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：\n\nspring会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。\n4.Ribbon负载均衡上一节中，我们添加了@LoadBalanced注解，即可实现负载均衡功能，这是什么原理呢？\n4.1.负载均衡原理SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。\n\n那么我们发出的请求明明是http://userservice/user/1，怎么变成了http://localhost:8081的呢？\n4.2.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。\n显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。\n我们进行源码跟踪：\n1）LoadBalancerIntercepor\n可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：\n\nrequest.getURI()：获取请求uri，本例中就是 http://user-service/user/8\noriginalUri.getHost()：获取uri路径的主机名，其实就是服务id，user-service\nthis.loadBalancer.execute()：处理服务id，和用户请求。\n\n这里的this.loadBalancer是LoadBalancerClient类型，我们继续跟入。\n2）LoadBalancerClient继续跟入execute方法：\n\n代码是这样的：\n\ngetLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。\ngetServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务\n\n放行后，再次访问并跟踪，发现获取的是8081：\n\n果然实现了负载均衡。\n3）负载均衡策略IRule在刚才的代码中，可以看到获取服务使通过一个getServer方法来做负载均衡:\n!\n我们继续跟入：\n\n继续跟踪源码chooseServer方法，发现这么一段代码：\n\n我们看看这个rule是谁：\n\n这里的rule默认值是一个RoundRobinRule，看类的介绍：\n\n这不就是轮询的意思嘛。\n到这里，整个负载均衡的流程我们就清楚了。\n4）总结SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：\n\n基本流程如下：\n\n拦截我们的RestTemplate请求http://userservice/user/1\nRibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service\nDynamicServerListLoadBalancer根据user-service到eureka拉取服务列表\neureka返回列表，localhost:8081、localhost:8082\nIRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081\nRibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到http://localhost:8081/user/1，发起真实请求\n\n4.3.负载均衡策略4.3.1.负载均衡策略负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：\n\n不同规则的含义如下：\n\n\n\n内置负载均衡规则类\n规则描述\n\n\n\nRoundRobinRule\n简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。\n\n\nAvailabilityFilteringRule\n对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的..ActiveConnectionsLimit属性进行配置。\n\n\nWeightedResponseTimeRule\n为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。\n\n\nZoneAvoidanceRule\n以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。\n\n\nBestAvailableRule\n忽略那些短路的服务器，并选择并发数较低的服务器。\n\n\nRandomRule\n随机选择一个可用的服务器。\n\n\nRetryRule\n重试机制的选择逻辑\n\n\n默认的实现就是ZoneAvoidanceRule，是一种轮询方案\n4.3.2.自定义负载均衡策略通过定义IRule实现可以修改负载均衡规则，有两种方式：\n\n代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：\n\n1234@Beanpublic IRule randomRule()&#123;    return new RandomRule();&#125;\n\n\n配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：\n\n123userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 \n\n\n\n\n\n\n\n\n\n\n注意，一般用默认的负载均衡规则，不做修改。\n4.4.饥饿加载Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。\n而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：\n1234ribbon:  eager-load:    enabled: true    clients: userservice\n\n5.Nacos注册中心国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba也推出了一个名为Nacos的注册中心。\n5.1.认识和安装NacosNacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。\n\n安装方式可以参考课前资料《Nacos安装指南.md》\n5.2.服务注册到nacosNacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。\n主要差异在于：\n\n依赖不同\n服务地址不同\n\n1）引入依赖在cloud-demo父工程的pom文件中的&lt;dependencyManagement&gt;中引入SpringCloudAlibaba的依赖：\n1234567&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;    &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;    &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt;\n\n然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n\n\n\n\n\n\n\n注意：不要忘了注释掉eureka的依赖。\n2）配置nacos地址在user-service和order-service的application.yml中添加nacos地址：\n1234spring:  cloud:    nacos:      server-addr: localhost:8848\n\n\n\n\n\n\n\n\n\n\n注意：不要忘了注释掉eureka的地址\n3）重启重启微服务后，登录nacos管理页面，可以看到微服务信息：\n\n5.3.服务分级存储模型一个****服务可以有多个实例，例如我们的user-service，可以有:\n\n127.0.0.1:8081\n127.0.0.1:8082\n127.0.0.1:8083\n\n假如这些实例分布于全国各地的不同机房，例如：\n\n127.0.0.1:8081，在上海机房\n127.0.0.1:8082，在上海机房\n127.0.0.1:8083，在杭州机房\n\nNacos就将同一机房内的实例 划分为一个****集群。\n也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：\n\n微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：\n\n杭州机房内的order-service应该优先访问同机房的user-service。\n5.3.1.给user-service配置集群修改user-service的application.yml文件，添加集群配置：\n123456spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称\n\n重启两个user-service实例后，我们可以在nacos控制台看到下面结果：\n\n我们再次复制一个user-service启动配置，添加属性：\n1-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH\n\n配置如图所示：\n\n启动UserApplication3后再次查看nacos控制台：\n\n5.3.2.同集群优先的负载均衡默认的ZoneAvoidanceRule并不能实现根据同集群优先来实现负载均衡。\n因此Nacos中提供了一个NacosRule的实现，可以优先从同集群中挑选实例。\n1）给order-service配置集群信息\n修改order-service的application.yml文件，添加集群配置：\n123456spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称\n\n2）修改负载均衡规则\n修改order-service的application.yml文件，修改负载均衡规则：\n123userservice:  ribbon:    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则 \n\n5.4.权重配置实际部署中会出现这样的场景：\n服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。\n但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。\n因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。\n在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：\n\n在弹出的编辑窗口，修改权重：\n\n\n\n\n\n\n\n\n\n\n注意：如果权重修改为0，则该实例永远不会被访问\n5.5.环境隔离Nacos提供了namespace来实现环境隔离功能。\n\nnacos中可以有多个namespace\nnamespace下可以有group、service等\n不同namespace之间相互隔离，例如不同namespace的服务互相不可见\n\n\n5.5.1.创建namespace默认情况下，所有service、data、group都在同一个namespace，名为public：\n\n我们可以点击页面新增按钮，添加一个namespace：\n\n然后，填写表单：\n\n就能在页面看到一个新的namespace：\n\n5.5.2.给微服务配置namespace给微服务配置namespace只能通过修改配置来实现。\n例如，修改order-service的application.yml文件：\n1234567spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID\n\n重启order-service后，访问控制台，可以看到下面的结果：\n\n\n此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：\n\n5.6.Nacos与Eureka的区别Nacos的服务实例分为两种l类型：\n\n临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。\n非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。\n\n配置一个服务实例为永久实例：\n12345spring:  cloud:    nacos:      discovery:        ephemeral: false # 设置为非临时实例\n\nNacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：\n\n\nNacos与eureka的共同点\n都支持服务注册和服务拉取\n都支持服务提供者心跳方式做健康检测\n\n\nNacos与Eureka的区别\nNacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式\n临时实例心跳不正常会被剔除，非临时实例则不会被剔除\nNacos支持服务列表变更的消息推送模式，服务列表更新更及时\nNacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式\n\n\n\n","slug":"SpringCloud使用篇01","date":"2023-08-15T10:49:36.000Z","categories_index":"Java","tags_index":"SpringCloud","author_index":"正茂"},{"id":"6984a25a0e4d84e9bb902e845682c284","title":"SpringCloud 实用篇 02","content":"SpringCloud 实用篇 020.学习目标1.Nacos 配置管理Nacos 除了可以做注册中心，同样可以做配置管理来使用。\n1.1.统一配置管理当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。\n\nNacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。\n1.1.1.在 nacos 中添加配置文件如何在 nacos 中管理配置呢？\n\n然后在弹出的表单中，填写配置信息：\n\n\n\n\n\n\n\n\n\n\n注意：项目的核心配置，需要热更新的配置才有放到 nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。\n1.1.2.从微服务拉取配置微服务要拉取 nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。\n但如果尚未读取 application.yml，又如何得知 nacos 地址呢？\n因此 spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：\n\n1）引入 nacos-config 依赖\n首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：\n12345&lt;!--nacos配置管理依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）添加 bootstrap.yaml\n然后，在 user-service 中添加一个 bootstrap.yaml 文件，内容如下：\n12345678910spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev  cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yaml # 文件后缀名\n\n这里会根据 spring.cloud.nacos.server-addr 获取 nacos 地址，再根据\n$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;作为文件 id，来读取配置。\n本例中，就是去读取userservice-dev.yaml：\n\n3）读取 nacos 配置\n在 user-service 中的 UserController 中添加业务逻辑，读取 pattern.dateformat 配置：\n\n完整代码：\n1234567891011121314151617181920212223242526272829package cn.itcast.user.web;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.*;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @Autowired    private UserService userService;    @Value(&quot;$&#123;pattern.dateformat&#125;&quot;)    private String dateformat;        @GetMapping(&quot;now&quot;)    public String now()&#123;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));    &#125;    // ...略&#125;\n\n在页面访问，可以看到效果：\n\n1.2.配置热更新**我们最终的目的，是修改 nacos 中的配置后，微服务中无需重启即可让配置生效，也就是****配置热更新**。\n要实现配置热更新，可以使用两种方式：\n1.2.1.方式一在@Value 注入的变量所在类上添加注解@RefreshScope：\n\n1.2.2.方式二使用@ConfigurationProperties 注解代替@Value 注解。\n在 user-service 服务中，添加一个类，读取 patterrn.dateformat 属性：\n123456789101112package cn.itcast.user.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix = &quot;pattern&quot;)public class PatternProperties &#123;    private String dateformat;&#125;\n\n在 UserController 中使用这个类代替@Value：\n\n完整代码：\n123456789101112131415161718192021222324252627282930313233package cn.itcast.user.web;import cn.itcast.user.config.PatternProperties;import cn.itcast.user.pojo.User;import cn.itcast.user.service.UserService;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;@Slf4j@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @Autowired    private UserService userService;    @Autowired    private PatternProperties patternProperties;    @GetMapping(&quot;now&quot;)    public String now()&#123;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));    &#125;    // 略&#125;\n\n1.3.配置共享其实微服务启动时，会去 nacos 读取多个配置文件，例如：\n\n[spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml\n[spring.application.name].yaml，例如：userservice.yaml\n\n而[spring.application.name].yaml不包含环境，因此可以被多个环境共享。\n下面我们通过案例来测试配置共享\n1）添加一个环境共享配置我们在 nacos 中添加一个 userservice.yaml 文件：\n\n2）在 user-service 中读取共享配置在 user-service 服务中，修改 PatternProperties 类，读取新添加的属性：\n\n在 user-service 服务中，修改 UserController，添加一个方法：\n\n3）运行两个 UserApplication，使用不同的 profile修改 UserApplication2 这个启动项，改变其 profile 值：\n\n\n这样，UserApplication(8081)使用的 profile 是 dev，UserApplication2(8082)使用的 profile 是 test。\n启动 UserApplication 和 UserApplication2\n访问http://localhost:8081/user/prop，结果：\n\n访问http://localhost:8082/user/prop，结果：\n\n可以看出来，不管是 dev，还是 test 环境，都读取到了 envSharedValue 这个属性的值。\n4）配置共享的优先级当 nacos、服务本地同时出现相同属性时，优先级有高低之分：\n\n1.4.搭建 Nacos 集群Nacos 生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：\n\n2.Feign 远程调用先来看我们以前利用 RestTemplate 发起远程调用的代码：\n\n存在下面的问题：\n•代码可读性差，编程体验不统一\n•参数复杂 URL 难以维护\nFeign 是一个声明式的 http 客户端，官方地址：https://github.com/OpenFeign/feign\n其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。\n\n2.1.Feign 替代 RestTemplateFegin 的使用步骤如下：\n1）引入依赖我们在 order-service 服务的 pom 文件中引入 feign 的依赖：\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）添加注解在 order-service 的启动类添加注解开启 Feign 的功能：\n\n3）编写 Feign 的客户端在 order-service 中新建一个接口，内容如下：\n123456789101112package cn.itcast.order.client;import cn.itcast.order.pojo.User;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@FeignClient(&quot;userservice&quot;)public interface UserClient &#123;    @GetMapping(&quot;/user/&#123;id&#125;&quot;)    User findById(@PathVariable(&quot;id&quot;) Long id);&#125;\n\n这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：\n\n服务名称：userservice\n请求方式：GET\n请求路径：&#x2F;user&#x2F;{id}\n请求参数：Long id\n返回值类型：User\n\n这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。\n4）测试修改 order-service 中的 OrderService 类中的 queryOrderById 方法，使用 Feign 客户端代替 RestTemplate：\n\n是不是看起来优雅多了。\n5）总结使用 Feign 的步骤：\n① 引入依赖\n② 添加@EnableFeignClients 注解\n③ 编写 FeignClient 接口\n④ 使用 FeignClient 中定义的方法代替 RestTemplate\n2.2.自定义配置Feign 可以支持很多的自定义配置，如下表所示：\n\n\n\n类型\n作用\n说明\n\n\n\nfeign.Logger.Level\n修改日志级别\n包含四种不同的级别：NONE、BASIC、HEADERS、FULL\n\n\nfeign.codec.Decoder\n响应结果的解析器\nhttp 远程调用的结果做解析，例如解析 json 字符串为 java 对象\n\n\nfeign.codec.Encoder\n请求参数编码\n将请求参数编码，便于通过 http 请求发送\n\n\nfeign. Contract\n支持的注解格式\n默认是 SpringMVC 的注解\n\n\nfeign. Retryer\n失败重试机制\n请求失败的重试机制，默认是没有，不过会使用 Ribbon 的重试\n\n\n一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean 覆盖默认 Bean 即可。\n下面以日志为例来演示如何自定义配置。\n2.2.1.配置文件方式基于配置文件修改 feign 的日志级别可以针对单个服务：\n12345feign:    client:    config:      userservice: # 针对某个微服务的配置        loggerLevel: FULL #  日志级别\n\n也可以针对所有服务：\n12345feign:    client:    config:      default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置        loggerLevel: FULL #  日志级别\n\n而日志的级别分为四种：\n\nNONE：不记录任何日志信息，这是默认值。\nBASIC：仅记录请求的方法，URL 以及响应状态码和执行时间\nHEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息\nFULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。\n\n2.2.2.Java 代码方式也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 Logger.Level 的对象：\n123456public class DefaultFeignConfiguration  &#123;    @Bean    public Logger.Level feignLogLevel()&#123;        return Logger.Level.BASIC; // 日志级别为BASIC    &#125;&#125;\n\n**如果要****全局生效**，将其放到启动类的@EnableFeignClients 这个注解中：\n1@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)\n\n**如果是****局部生效**，则把它放到对应的@FeignClient 这个注解中：\n1@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)\n\n2.3.Feign 使用优化Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：\n•URLConnection：默认实现，不支持连接池\n•Apache HttpClient ：支持连接池\n•OKHttp：支持连接池\n**因此提高 Feign 的性能主要手段就是使用****连接池**代替默认的 URLConnection。\n这里我们用 Apache 的 HttpClient 来演示。\n1）引入依赖\n在 order-service 的 pom 文件中引入 Apache 的 HttpClient 依赖：\n12345&lt;!--httpClient的依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）配置连接池\n在 order-service 的 application.yml 中添加配置：\n123456789feign:  client:    config:      default: # default全局的配置        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息  httpclient:    enabled: true # 开启feign对HttpClient的支持    max-connections: 200 # 最大的连接数    max-connections-per-route: 50 # 每个路径的最大连接数\n\n接下来，在 FeignClientFactoryBean 中的 loadBalance 方法中打断点：\n\nDebug 方式启动 order-service 服务，可以看到这里的 client，底层就是 Apache HttpClient：\n\n总结，Feign 的优化：\n1.日志级别尽量用 basic\n2.使用 HttpClient 或 OKHttp 代替 URLConnection\n① 引入 feign-httpClient 依赖\n② 配置文件开启 httpClient 功能，设置连接池参数\n2.4.最佳实践所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。\n自习观察可以发现，Feign 的客户端与服务提供者的 controller 代码非常相似：\nfeign 客户端：\n\nUserController：\n\n有没有一种办法简化这种重复的代码编写呢？\n2.4.1.继承方式一样的代码可以通过继承来共享：\n1）定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明。\n2）Feign 客户端和 Controller 都集成改接口\n\n优点：\n\n简单\n实现了代码共享\n\n缺点：\n\n服务提供方、服务消费方紧耦合\n参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解\n\n2.4.2.抽取方式将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。\n例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。\n\n2.4.3.实现基于抽取的最佳实践1）抽取首先创建一个 module，命名为 feign-api：\n\n项目结构：\n\n在 feign-api 中然后引入 feign 的 starter 依赖\n1234&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n\n然后，order-service 中编写的 UserClient、User、DefaultFeignConfiguration 都复制到 feign-api 项目中\n\n2）在 order-service 中使用 feign-api首先，删除 order-service 中的 UserClient、User、DefaultFeignConfiguration 等类或接口。\n在 order-service 的 pom 文件中中引入 feign-api 的依赖：\n12345&lt;dependency&gt;    &lt;groupId&gt;cn.itcast.demo&lt;/groupId&gt;    &lt;artifactId&gt;feign-api&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;\n\n修改 order-service 中的所有与上述三个组件有关的导包部分，改成导入 feign-api 中的包\n3）重启测试重启后，发现服务报错了：\n\n这是因为 UserClient 现在在 cn.itcast.feign.clients 包下，\n而 order-service 的@EnableFeignClients 注解是在 cn.itcast.order 包下，不在同一个包，无法扫描到 UserClient。\n4）解决扫描包问题方式一：\n指定 Feign 应该扫描的包：\n1@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)\n\n方式二：\n指定需要加载的 Client 接口：\n1@EnableFeignClients(clients = &#123;UserClient.class&#125;)\n\n3.Gateway 服务网关Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。\n3.1.为什么需要网关Gateway 网关是我们服务的守门神，所有微服务的统一入口。\n**网关的****核心功能特性**：\n\n请求路由\n权限控制\n限流\n\n架构图：\n\n权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。\n路由和负载均衡：一切请求都必须先经过 gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。\n限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。\n在 SpringCloud 中网关的实现包括两种：\n\ngateway\nzuul\n\nZuul 是基于 Servlet 的实现，属于阻塞式编程。而 SpringCloudGateway 则是基于 Spring5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。\n3.2.gateway 快速入门下面，我们就演示下网关的基本路由功能。基本步骤如下：\n\n创建 SpringBoot 工程 gateway，引入网关依赖\n编写启动类\n编写基础配置和路由规则\n启动网关服务进行测试\n\n1）创建 gateway 服务，引入依赖创建服务：\n\n引入依赖：\n12345678910&lt;!--网关--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--nacos服务发现依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2）编写启动类123456789101112package cn.itcast.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class GatewayApplication &#123;public static void main(String[] args) &#123;SpringApplication.run(GatewayApplication.class, args);&#125;&#125;\n\n3）编写基础配置和路由规则创建 application.yml 文件，内容如下：\n123456789101112131415server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    nacos:      server-addr: localhost:8848 # nacos地址    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求\n\n我们将符合Path 规则的一切请求，都代理到 uri参数指定的地址。\n**本例中，我们将 **/user/**开头的请求，代理到lb://userservice，lb 是负载均衡，根据服务名拉取服务列表，实现负载均衡。\n4）重启测试重启网关，访问http://localhost:10010/user/1时，符合/user/**规则，请求转发到 uri：http://userservice/user/1，得到了结果：\n\n5）网关路由的流程图整个访问的流程如下：\n\n总结：\n网关搭建步骤：\n\n创建项目，引入 nacos 服务发现和 gateway 依赖\n配置 application.yml，包括服务基本信息、nacos 地址、路由\n\n路由配置包括：\n\n路由 id：路由的唯一标示\n路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡\n路由断言（predicates）：判断路由的规则，\n路由过滤器（filters）：对请求或响应做处理\n\n接下来，就重点来学习路由断言和路由过滤器的详细知识\n3.3.断言工厂我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件\n**例如 Path&#x3D;&#x2F;user&#x2F;**是按照路径匹配，这个规则是由**\norg.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory类来\n处理的，像这样的断言工厂在 SpringCloudGateway 还有十几个:\n\n\n\n名称\n说明\n示例\n\n\n\nAfter\n是某个时间点后的请求\n- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nBefore\n是某个时间点之前的请求\n- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]\n\n\nBetween\n是某两个时间点之前的请求\n- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]\n\n\nCookie\n请求必须包含某些 cookie\n- Cookie&#x3D;chocolate, ch.p\n\n\nHeader\n请求必须包含某些 header\n- Header&#x3D;X-Request-Id, \\d+\n\n\nHost\n请求必须是访问某个 host（域名）\n- Host&#x3D;**.somehost.org,**.anotherhost.org\n\n\nMethod\n请求方式必须是指定方式\n- Method&#x3D;GET,POST\n\n\nPath\n请求路径必须符合指定规则\n- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**\n\n\nQuery\n请求参数必须包含指定参数\n- Query&#x3D;name, Jack 或者- Query&#x3D;name\n\n\nRemoteAddr\n请求者的 ip 必须是指定范围\n- RemoteAddr&#x3D;192.168.1.1&#x2F;24\n\n\nWeight\n权重处理\n\n\n\n我们只需要掌握 Path 这种路由工程就可以了。\n3.4.过滤器工厂GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：\n\n3.4.1.路由过滤器的种类Spring 提供了 31 种不同的路由过滤器工厂。例如：\n\n\n\n名称\n说明\n\n\n\nAddRequestHeader\n给当前请求添加一个请求头\n\n\nRemoveRequestHeader\n移除请求中的一个请求头\n\n\nAddResponseHeader\n给响应结果中添加一个响应头\n\n\nRemoveResponseHeader\n从响应结果中移除有一个响应头\n\n\nRequestRateLimiter\n限制请求的流量\n\n\n3.4.2.请求头过滤器下面我们以 AddRequestHeader 为例来讲解。\n\n\n\n\n\n\n\n\n\n需求：给所有进入 userservice 的请求添加一个请求头：Truth&#x3D;itcast is freaking awesome!\n只需要修改 gateway 服务的 application.yml 文件，添加路由过滤即可：\n12345678910spring:  cloud:    gateway:      routes:      - id: user-service        uri: lb://userservice        predicates:        - Path=/user/**        filters: # 过滤器        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头\n\n当前过滤器写在 userservice 路由下，因此仅仅对访问 userservice 的请求有效。\n3.4.3.默认过滤器如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：\n12345678910spring:  cloud:    gateway:      routes:      - id: user-service        uri: lb://userservice        predicates:        - Path=/user/**      default-filters: # 默认过滤项      - AddRequestHeader=Truth, Itcast is freaking awesome!\n\n3.4.4.总结过滤器的作用是什么？\n① 对路由的请求或响应做加工处理，比如添加请求头\n② 配置在路由下的过滤器只对当前路由的请求生效\ndefaultFilters 的作用是什么？\n① 对所有路由都生效的过滤器\n3.5.全局过滤器上一节学习的过滤器，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。\n3.5.1.全局过滤器作用全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。区别在于 GatewayFilter 通过配置定义，处理逻辑是固定的；而 GlobalFilter 的逻辑需要自己写代码实现。\n定义方式是实现 GlobalFilter 接口。\n12345678910public interface GlobalFilter &#123;    /**     *  处理当前请求，有必要的话通过&#123;@link GatewayFilterChain&#125;将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器     * @return &#123;@code Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束     */    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);&#125;\n\n在 filter 中编写自定义逻辑，可以实现下列功能：\n\n登录状态判断\n权限校验\n请求限流等\n\n3.5.2.自定义全局过滤器需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\n\n参数中是否有 authorization，\nauthorization 参数值是否为 admin\n\n如果同时满足则放行，否则拦截\n实现：\n在 gateway 中定义一个过滤器：\n12345678910111213141516171819202122232425262728293031package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        // 1.获取请求参数        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();        // 2.获取authorization参数        String auth = params.getFirst(&quot;authorization&quot;);        // 3.校验        if (&quot;admin&quot;.equals(auth)) &#123;            // 放行            return chain.filter(exchange);        &#125;        // 4.拦截        // 4.1.禁止访问，设置状态码        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        // 4.2.结束处理        return exchange.getResponse().setComplete();    &#125;&#125;\n\n3.5.3.过滤器执行顺序请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter\n请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：\n\n排序的规则是什么呢？\n\n**每一个过滤器都必须指定一个 int 类型的 order 值，****order 值越小，优先级越高，执行顺序越靠前**。\nGlobalFilter 通过实现 Ordered 接口，或者添加@Order 注解来指定 order 值，由我们自己指定\n路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。\n当过滤器的 order 值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter 的顺序执行。\n\n详细内容，可以查看源码：\norg.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()方法是先加载 defaultFilters，然后再加载某个 route 的 filters，然后合并。\norg.springframework.cloud.gateway.handler.FilteringWebHandler#handle()方法会加载全局过滤器，与前面的过滤器合并后根据 order 排序，组织过滤器链\n3.6.跨域问题3.6.1.什么是跨域问题跨域：域名不一致就是跨域，主要包括：\n\n**域名不同： **www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com\n域名相同，端口不同：localhost:8080 和 localhost8081\n\n跨域问题：浏览器禁止请求的发起者与服务端发生跨域 ajax 请求，请求被浏览器拦截的问题\n解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看https://www.ruanyifeng.com/blog/2016/04/cors.html\n3.6.2.模拟跨域问题找到课前资料的页面文件：\n\n放入 tomcat 或者 nginx 这样的 web 服务器中，启动并访问。\n可以在浏览器控制台看到下面的错误：\n\n从 localhost:8090 访问 localhost:10010，端口不同，显然是跨域的请求。\n3.6.3.解决跨域问题在 gateway 服务的 application.yml 文件中，添加下面的配置：\n12345678910111213141516171819spring:  cloud:    gateway:      # 。。。      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          &#x27;[/**]&#x27;:            allowedOrigins: # 允许哪些网站的跨域请求              - &quot;http://localhost:8090&quot;            allowedMethods: # 允许的跨域ajax的请求方式              - &quot;GET&quot;              - &quot;POST&quot;              - &quot;DELETE&quot;              - &quot;PUT&quot;              - &quot;OPTIONS&quot;            allowedHeaders: &quot;*&quot; # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期\n","slug":"SpringCloud使用篇02","date":"2023-08-14T10:49:36.000Z","categories_index":"Java","tags_index":"SpringCloud,Java,Spring","author_index":"正茂"}]
>>>>>>> 9eb1465 (second)
